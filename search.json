[{"title":"Express框架","url":"/article/8ddaf637.html","content":"\n# express框架\n[express](https://www.expressjs.com.cn/) 是一个web框架，也是npm的一个工具包，功能和http模块类似，但功能更加强大，开发服务端效率更高\n\n基本使用步骤：\n1. 导入express框架\n2. 创建服务器实例对象\n3. 绑定事件\n4. 监听端口，启动服务器\n\n```js\n//导入express\nconst express = require('express');\n// 创建对象\nconst app = express();\n//创建路由，req请求报文的封装对象，res响应报文\napp.get('/home', (req, res) => {\n    // 如果请求的方法是get，并且url路径是/home，则执行\n    res.end('Welcome');\n})\n// 监听端口启动服务\napp.listen(3000, () => {\n    console.log('服务启动');\n});\n\n```\n\n## 路由\n**路由：**确定如何响应客户端对特定端点的请求\n\n```js 使用方法，由请求方法、路径、回调函数组成\napp.<method>(path，(req, res) => {})\n```\n\n```js\n//创建路由，req请求报文的封装对象，res响应报文\n//从上往下匹配，匹配到则不再往后匹配\napp.get('/home', (req, res) => {\n    // 如果请求的方法是get，并且url路径是/home，则执行\n    res.end('Welcome /home');\n})\n\napp.get('/', (req, res) => {\n    res.end('Welcome /');\n});\n\napp.post('/login', (req, res) => {\n    res.end('Welcome /login');\n});\n\napp.all('/test', (req, res)=>{\n    res.end('Welcome /test');\n});\n// 匹配所有路径和方法，可以放在最后进行404响应\napp.all('*', (req, res)=>{\n    res.end('404');\n});\n\n```\n\n## 获取请求报文\n\n```js\napp.get('/', (req, res) => {\n    //express兼容原生操作\n    console.log(req.method);//请求方法\n    console.log(req.url);//请求url\n    console.log(req.httpVersion);//http版本\n    console.log(req.headers);//请求头\n    //express封装方法\n    console.log(req.path);//请求路径\n    console.log(req.query);//查询字符串\n    console.log(req.ip);//用户ip\n    console.log(req.get('host'));//获取特定请求头的属性值\n\n    res.send('Welcome /');\n});\n\n```\n\n### 路由参数\n路由参数指的是 URL 路径中的参数（数据），如多篇文章按1.html、2.html往后排，匹配路由参数从而无需写多个路由\n\n获取路由参数：`req.params.id`\n\n```js\napp.get('/:id.html',(req, res) => {\n    res.send('id为' + req.params.id);\n}); \n```\n\n路由参数练习：\n\n```json\n{\n  \"singers\": [\n    {\n      \"singer_name\": \"周杰伦\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M0000025NhlN2yWrP4.webp\",\n      \"other_name\": \"Jay Chou\",\n      \"singer_id\": 4558,\n      \"id\": 1\n    },\n    {\n      \"singer_name\": \"林俊杰\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M000001BLpXF2DyJe2.webp\",\n      \"other_name\": \"JJ Lin\",\n      \"singer_id\": 4286,\n      \"id\": 2\n    },\n    {\n      \"singer_name\": \"G.E.M. 邓紫棋\",\n      \"singer_pic\": \"http://y.gtimg.cn/music/photo_new/T001R150x150M000001fNHEf1SFEFN.webp\",\n      \"other_name\": \"Gloria Tang\",\n      \"singer_id\": 13948,\n      \"id\": 3\n    }\n  ]\n}\n\n```\n\n```js\nconst express = require('express');\n// 创建对象\nconst app = express();\n//导入json文件\nconst {singers} = require('./JSON/singers.json');\n\napp.get('/singer/:id.html',(req, res) => {\n    let {id} = req.params;\n    let result = singers.find((item)=>{\n        if(item.id === Number(id)){\n            return true;\n        }\n    });\n    // console.log(result);\n    if(!result){\n        res.send(\"404\");\n        return;\n    }\n    res.send(`\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n        <title>Document</title>\n    </head>\n    <body>\n        <h2>${result.singer_name}</h2>\n        <img src=${result.singer_pic}}></img>\n    </body>\n    </html>\n    `);\n}); \n\napp.listen(3000, () => {\n    console.log('服务启动');\n})\n\n```\n\n## 响应设置\n一般响应\n\n```js\napp.get('/', (req, res)=>{\n    // 原生响应\n    res.statusCode = 200;\n    res.statusMessage = 'OK';\n    res.setHeader('Content-Type', 'text/html;charset=UTF-8');\n    // express\n    res.status(200);\n    res.set('Content-Type', 'text/html');\n    res.send('你好');//自动添加字符集，不乱码\n    // 连贯操作\n    res.status(200).set('xxx','yyy').send('你好');\n});\n\n```\n\n其它响应，一般不能多个同时成功响应\n\n```js\napp.get('/', (req, res)=>{\n    // 302重定向\n    res.redirect('https://www.baidu.com/');\n    // 下载响应\n    res.download('../3.mp4');\n    // 响应JSON\n    res.json({\n            a:1\n        });\n    // 响应文件内容\n    res.sendFile(__dirname + '/package.json');\n});\n\n```\n\n## 中间件\n中间件（Middleware）本质是一个回调函数\n\n中间件函数可以像路由回调一样访问请求对象（request），响应对象（response）\n\n**作用：**使用函数封装公共操作，简化代码\n\n**类型：**全局中间件、路由中间件\n\n每一个请求到达服务端后都会执行全局中间件函数\n满足某个路由规则的请求会触发指定路由中间件函数\n\n```js 声明中间件函数\nfunction middleware(req,res,next){\n//实现功能代码\n//执行next函数\n//调用next()执行完中间件函数后，继续执行路由中的回调函数\nnext();\n}\n```\n\n### 全局中间件\n每一个请求到达服务端后都会执行全局中间件函数\n\napp.use是专门解析中间件函数的方法，使用之后express会将http请求响应对象交给中间件函数，中间件函数处理完通过next()方法传递给下一中间件函数，直到返回响应数据\n\n可以使用 app.use() 定义多个全局中间件\n\n案例：\n\n```js 利用中间件对所有路由记录访问路径和用户ip\n// 声明中间件\nfunction middleware1(req, res, next) {\n    let {url, ip} = req;\n    fs.appendFileSync(path.resolve(__dirname + '/1.log'), `${url} ${ip}\\r\\n`);\n    // 中间件函数处理完请求后，通过next方法将http请求对象交给下一个中间件或路由，直到返回响应\n    next();\n}\nfunction middleware2(req, res, next) {\n    let {url, ip} = req;\n    console.log(url, ip);\n    next();\n}\n// 使用app.use定义全局中间件，express将http请求对象交给中间件\napp.use(middleware1);\napp.use(middleware2);\n\napp.get('/home', (req, res)=>{\n    res.send('首页');\n});\napp.get('/admin', (req, res)=>{\n    res.send('后台');\n});\n\n```\n\n### 路由中间件\n满足某个路由规则的请求会触发指定路由中间件函数\n\n只需要对某一些路由进行功能封装，则使用路由中间件，可以设置多个中间件函数\n\n```js 格式\napp.get('/路径',`中间件函数1`,`中间件函数2`,(req,res)=>{});\n```\n\n案例：\n\n```js 访问后台和设置页的请求必须携带code为123的参数\nfunction checkCode(req, res, next){\n    if (req.query.code === '123'){\n        next();//继续执行路由回调\n    }else{\n        res.send('code参数错误');\n    }\n}\napp.get('/home', (req, res)=>{\n    res.send('首页');\n});\n// 放到需要的路由上\napp.get('/admin', checkCode, (req, res)=>{\n    res.send('后台');\n});\napp.get('/setting', checkCode, (req, res)=>{\n    res.send('设置');\n});\n\n```\n\n## 静态资源中间件\nexpress内置处理静态资源的中间件\n\n```js\napp.use(express.static('<静态资源目录>'));\n```\n\n设置后，所有静态资源都会根据静态资源目录去寻找，index.html、index.css等为默认打开的资源\n\n果静态资源与路由规则同时匹配，从上而下谁先匹配谁就响应\n\n一般用路由响应动态资源，如搜索结果等，用静态资源中间件响应静态资源，如html、css等\n\n```js\n// 设置静态资源目录，会自动添加Mime类型\napp.use(express.static('../public-test'));\n//访问在public-test下的index.html\napp.get('/', (req, res)=>{\n    res.send('首页');\n});\n//访问在public-test/css下的index.html\napp.get('/css/index.css', (req, res)=>{\n    res.send('css');\n});\n\n```\n\n## 获取请求体\nexpress 可以使用 [body-parser](https://www.npmjs.com/package/body-parser) 包处理请求体，该包内置许多中间件来处理请求体，需要先npm安装`npm i body-parser`\n\n包内常用中间件，当中间件解析完请求后会向 req 对象上添加 body 属性，里面包含了请求体对象\n\n```js\n// 解析 json 格式的中间件\nvar jsonParser = bodyParser.json()\n// 解析 querystring 格式的中间件\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\n```\n\n案例：\n\n```js 获取表单post提交的用户名和密码，get请求则显示登录页面\nconst bodyParser = require('body-parser');\n// 获取表单post提交的用户名和密码，get请求则显示登录页面\napp.get('/login', (req, res)=>{\n    // 响应登录页面\n    res.sendFile(__dirname + '/login.html');\n});\n// 获取 bodyParser 包中的中间件函数\n// 解析 json 格式的中间件\nvar jsonParser = bodyParser.json()\n// 解析 querystring 格式的中间件\nvar urlencodedParser = bodyParser.urlencoded({ extended: false })\napp.post('/login', urlencodedParser, (req, res) => {\n    // 当urlencodedParser中间件执行完毕，会向req对象上添加一个body属性\n    console.log(req.body);//{ username: '543', password: '345' }\n    // 成功获取包含用户名和密码的对象\n    res.send('登录成功!');\n});\n```\n\n## 防盗链\n请求报文中的 referer 会携带当前访问资源的域名和端口，限制 referer 的值即可实现防盗链\n\n```js 全局中间件实现防盗链\napp.use((req, res, next) => {\n    // 获取请求头中的referer\n    let referer = req.get('referer');\n    // referer不为空再去执行\n    if (referer) {\n        // 解析referer\n        let url = new URL(referer);\n        // url.hostname 获取域名，判断是否是目标域名\n        if (url.hostname !== '127.0.0.1') {\n            res.status(404).send('404 Not Found');\n            return;\n        }\n    }\n    next();\n});\n\n```\n\n## 路由模块化Router\nRouter 是一个完整的中间件和路由系统，相当于一个小型的 app 对象。\n\n```js 声明Router和app\nconst router = express.Router();\nconst app = express();\n```\n\n```js home.js一个完整的路由\nconst express = require('express');\n\nconst router = express.Router();// 相当于一个小型的app对象\n\nrouter.get('/home', (req, res)=>{\n    res.send('首页');\n});\n\nrouter.get('/search', (req, res)=>{\n    res.send('搜索');\n});\n\n// 将路由暴露出去\nmodule.exports = router;\n\n```\n\n```js 在主文件需要导入路由并使用\nconst express = require('express');\n// 导入路由\nconst homeRouter = require('./home.js');\nconst adminRuter = require('./admin.js');\n\nconst app = express();\n// 使用路由\napp.use(homeRouter);\napp.use(adminRuter);\n\napp.all('*', (req, res) => {\n    res.send('404 Not Found');\n});\n\napp.listen(3000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\napp.use可以添加一个路径参数，来给路由添加前缀\n\n```js\napp.use('/', indexRouter);\napp.use('/users', usersRouter);// 路由中的路径都会自动添加这个前缀\n```\n\n## 模板引擎ejs\n模板引擎是分离**用户界面**和**业务数据**的一种技术，在许多语言都有的一种通用技术\n\n[EJS](https://ejs.devjs.cn/) 是一个高效的 Javascript 的模板引擎，用于分离html和服务端js\n\n```js\nconst ejs = require('ejs');\n// 字符串\nlet str1 = 'qx';\nlet str2 = `${str1}chuckle`;\nconsole.log(str2);// qxchuckle\n\n// 使用ejs\nlet str = '<%= str %>chuckle';\nlet result = ejs.render(str, {str:str1});\nconsole.log(result);// qxchuckle\n\n```\n\n将 ejs 模板写在单独的文件再由fs读入\n\n```js\nlet str = fs.readFileSync('./01.html').toString();\nlet [name,age] = ['chuckle',19]\nlet result = ejs.render(str, {name,age});\nconsole.log(result);\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h2><%= name %></h2>\n    <h3><%= age %></h3>\n</body>\n</html>\n\n```\n\nejs列表渲染：\n\n```js 原生js, js和html耦合在一起\nconst arr = [1,2,3,4];\nlet html = '<ul>';\narr.forEach(item=>{\n    html += `<li>${item}</li>`;\n})\nhtml += '</ul>';\nconsole.log(html);\n//<ul><li>1</li><li>2</li><li>3</li><li>4</li></ul>\n\n```\n\n```js 使用ejs, 分离html和服务端js\nconst arr = [1,2,3,4];\nlet html = `<ul>\n    <% arr.forEach(item => { %>\n        <li><%= item %></li>\n    <% }) %>\n</ul>`;\nlet result = ejs.render(html, {arr});\nconsole.log(result);\n//<ul><li>1</li><li>2</li><li>3</li><li>4</li></ul>\n\n```\n\nejs条件渲染\n\n```js\nlet isLogin = true;\nlet html = `<% if(isLogin) { %>\n    <span>登陆</span>\n<%}else{ %>\n    <span>注册</span>\n<%} %>`;\nlet result = ejs.render(html, {isLogin});\nconsole.log(result);\n// <span>登陆</span>\n\n```\n\n### express使用ejs\n使用 app.set() 设置express使用的模板引擎、设置模板文件存放位置\n\n```js\n// 设置express使用的模板引擎\napp.set('view engine', 'ejs');\n// 设置模板文件存放位置\napp.set('views', path.resolve(__dirname +'/ejs'));\n```\n\n然后就可以用res调用render方法响应渲染好的页面\n\n```js\n// res.render('<模板文件名>','<数据>');\nlet name = 'chuckle';\n// 在模板文件夹中创建home.ejs\nres.render('home', {name});\n```\n\n完整案例：\n\n```js\nconst express = require('express');\nconst path = require('path');\n\nconst app = express();\n// 设置express使用的模板引擎\napp.set('view engine', 'ejs');\n// 设置模板文件存放位置\napp.set('views', path.resolve(__dirname +'/ejs'));\n// 然后就可以用res调用render方法\napp.get('/', (req, res) => {\n    // res.render('<模板文件名>','<数据>');\n    let name = 'chuckle';\n    // 在模板文件夹中创建home.ejs\n    res.render('home', {name});\n});\n\napp.listen(3000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\n## express-generator\nexpress-generator是一个node的自动化创建项目工具，类似于vue-cli，能快速构建express项目标准骨架\n\n安装后会暴露一个全局命令：express\n\n```js 安装\nnpm install -g express-generator\nexpress -v //查看版本和帮助\n```\n\n构建项目：\n\n```js\nexpress -e <文件夹名称>// -e参数是添加ejs支持\n```\n\n1. app.js是项目主文件；\n2. views目录用于存放页面文件；\n3. routes目录用于存放路由文件；\n4. public用于存放静态文件；\n5. bin中的www是项目的启动文件；\n\n## 文件上传\n在index.js中添加两个路由,get显示表单，post接收上传的数据\n\n```js\n// 显示表单\nrouter.get('/portrait', (req,res) => {\n  res.render('portrait');\n});\n\n// 处理文件上传\nrouter.post('/portrait', (req, res)=>{\n  res.send('上传成功');\n});\n\n```\n\n新建 portrait.ejs 创建表单页面，对于文件上传，form表单必须添加 enctype=\"multipart/form-data\" 属性\n\n```ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h3>文件上传</h3>\n    <form action=\"/portrait\" method=\"post\" enctype=\"multipart/form-data\">\n        用户名：<input type=\"text\" name=\"username\"><br />\n        头像：<input type=\"file\" name=\"portrait\"><br />\n        <button>提交</button>\n    </form>\n</body>\n</html>\n\n```\n\n处理文件上传需要使用 [formidable](https://www.npmjs.com/package/formidable) 包，它是用于解析表单数据的 Node.js 模块，尤其是文件上传。\n\n```js 完整的index.js\nvar express = require('express');\nvar router = express.Router();\n// 导入formidable\nconst formidable = require('formidable');\n\n/* GET home page. */\nrouter.get('/', function(req, res, next) {\n  res.render('index', { title: 'Express' });\n});\n\n// 显示表单\nrouter.get('/portrait', (req,res) => {\n  res.render('portrait');\n});\n\n// 处理文件上传\nrouter.post('/portrait', (req, res)=>{\n  // 创建表单对象\n  const form = formidable({ \n    multiples: true,\n    // 设置上传文件的保存目录\n    uploadDir: __dirname + '/../public/images',\n    // 保持文件后缀\n    keepExtensions: true\n  });\n  // 解析表单对象\n  form.parse(req, (err, fields, files) => {\n    if (err) {\n      next(err);\n      return;\n    }\n    // fields存放除文件上传的一般表单提交\n    console.log(fields);\n    // files保存文件上传\n    console.log(files);\n    // res.json({ fields, files });\n    // 保存上传文件的存放路径，以后将此数据保存在数据库中\n    let url = '/images/' + files.portrait.newFilename;\n    res.send(url);// 给用户返回url路径\n  });\n});\n\nmodule.exports = router;\n\n```\n\n## lowdb包\n在保存一些简单数据时可以使用 [lowdb](https://www.npmjs.com/package/lowdb/v/1.0.0) 包，在json中进行增删改查数据，推荐使用1.0.0版本\n\n案例：\n\n```js\nconst low = require('lowdb')\nconst FileSync = require('lowdb/adapters/FileSync')\n// 数据存储的josn\nconst adapter = new FileSync('db.json')\n// 获取db对象\nconst db = low(adapter)\n// 初始化数据，也可以手动自定义初始化\ndb.defaults({ posts: [], user: {} }).write()\n\n// 增删改都需要最后调用write()\n// 往posts这个数组尾中添加元素\ndb.get('posts')\n    // push从尾部插入元素\n    .push({ id: 1, title: 'lowdb is awesome'})\n    .write()\ndb.get('posts')\n    // unshift从头插入元素\n    .unshift({ id: 2, title: 'lowdb is awesome'})\n    .write()\n\n// 获取数据\nlet value = db.get('posts').value();\nconsole.log(value);\n// 获取单条数据\nlet single = db.get('posts').find({id: 1}).value();\nconsole.log(single);\n\n// 删除所有匹配的数据，返回被删除的数据\ndb.get('posts').remove({id: 1}).write();\n\n// 更新数据,先获取再修改\ndb.get('posts').find({id: 2}).assign({title: 'chuckle'}).write();\n\n```\n\n## 案例-记账本\n\n<img src=https://cdn.chuckle.top/images/47-2.gif width=\"90%\" loading=\"lazy\">\n\n主要的一些文件\n\n主要路由：\n\n```js /routes/index.js\nvar express = require('express');\nvar router = express.Router();\n\n// 使用lowdb存储数据\nconst low = require('lowdb')\nconst FileSync = require('lowdb/adapters/FileSync')\n// 数据存储的josn\nconst adapter = new FileSync(__dirname + '/../data/db.json')\n// 获取db对象\nconst db = low(adapter)\n\n// 导入shortid为数据生成id\nconst shortid = require('shortid');\n\n// 记账本页面路由\nrouter.get('/', function(req, res, next) {\n  // 获取所有账单记录数据\n  let content = db.get('content').value();\n  // 将数据数组传递过去遍历渲染\n  res.render('index', {content});\n});\n\n// 添加记录页面路由\nrouter.get('/add', function(req, res, next) {\n  res.render('add');\n});\n\n// 添加记录post接口路由\nrouter.post('/add', function(req, res, next) {\n  // 生成唯一id\n  let id = shortid.generate();\n  // 往db.josn写入数据\n  db.get('content').unshift({id:id, ...req.body}).write();\n  // 跳转到提示页\n  res.render('tip',{msg: '添加成功!', url: '/'});\n});\n\n// 根据id删除数据，使用路由参数\nrouter.get('/delete/:id',(req, res) => {\n  let id =  req.params.id;// 获取路由参数\n  db.get('content').remove({id}).write();\n  res.render('tip',{msg: '删除成功!', url: '/'});\n});\n\n\nmodule.exports = router;\n\n```\n\n页面ejs：\n\n```html /views/index.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>记账本</title>\n    <link rel=\"stylesheet\" href=\"/css/index.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>记账本</h2>\n        </div>\n        <div class=\"add\">\n          <a href=\"/add\">添加</a>\n        </div>\n        <div class=\"record-box\">\n          <% content.forEach(item=>{%>\n          <div class=\"record-item\">\n            <div class=\"date\"><%= item.date %></div>\n            <div class=\"type <%= item.type==='支出'?'expenditure':'income'%>\">\n              <%= item.type %>\n            </div>\n            <div class=\"record-body\">\n              <div class=\"record-content\">\n                <div class=\"matter\"><%= item.matter %></div>\n                <div class=\"account\"><%= item.account %> 元</div>\n              </div>\n              <a href=\"/delete/<%= item.id %>\" class=\"delete\">删除</a>\n            </div>\n          </div>\n          <%})%>\n        </div>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```html /views/add.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>添加记录</title>\n    <link rel=\"stylesheet\" href=\"/css/add.css\" />\n  </head>\n\n  <body>\n    <div class=\"content\">\n      <div class=\"content-box\">\n        <div class=\"title\">\n          <h2>添加记录</h2>\n        </div>\n        <div class=\"home\">\n          <a href=\"/\">账单列表</a>\n        </div>\n        <form action=\"/add\" method=\"post\">\n          <div class=\"form-item\">\n            <label for=\"matter\">事项</label>\n            <input class=\"control\" type=\"text\" name=\"matter\" id=\"matter\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"date\">时间</label>\n            <input class=\"control\" type=\"date\" name=\"date\" id=\"date\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"type\">类型</label>\n            <select class=\"control\" name=\"type\" id=\"type\">\n              <option selected=\"\">支出</option>\n              <option>收入</option>\n            </select>\n          </div>\n          <div class=\"form-item\">\n            <label for=\"account\">金额</label>\n            <input class=\"control\" type=\"text\" name=\"account\" id=\"account\" />\n          </div>\n          <div class=\"form-item\">\n            <label for=\"remark\">备注</label>\n            <textarea class=\"control\" name=\"remark\" id=\"remark\"></textarea>\n          </div>\n          <hr />\n          <button>添加</button>\n        </form>\n      </div>\n    </div>\n  </body>\n</html>\n\n```\n\n```html /views/tip.ejs\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <link rel=\"stylesheet\" href=\"/css/tip.css\" />\n  </head>\n  <body>\n    <div class=\"content\">\n      <h3><%= msg %></h3>\n      <a href=\"<%= url %>\">返回</a>\n    </div>\n  </body>\n</html>\n\n```\n\ncss：\n\n```css /public/css/index.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\n.content{\n    max-width: 600px;\n    margin: 0 auto;\n}\n.content-box{\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    align-content: center;\n    margin: 0 10px;\n}\n.content-box>*{\n    width: 100%;\n}\n.title{\n    padding: 20px 0;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.title h2{\n    font-size: 30px;\n    font-weight: 500;\n}\n.add{\n    margin-top: 10px;\n    padding-left: 20px;\n}\n.add a{\n    text-decoration: none;\n}\n.record-box{\n    margin-top: 10px;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.record-item{\n    margin-bottom: 15px;\n    border: 1px solid rgb(226, 226, 226);\n    border-radius: 6px;\n    -webkit-border-radius: 6px;\n    -moz-border-radius: 6px;\n    -ms-border-radius: 6px;\n    -o-border-radius: 6px;\n    position: relative;\n}\n.record-item>.date{\n    height: 34px;\n    background: rgb(174, 209, 237);\n    padding: 6px 12px;\n    font-size: 14px;\n    line-height: 22px;\n}\n.record-body{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    padding: 10px 20px;\n    justify-content: space-between;\n    align-content: center;\n}\n.record-content{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    flex: 1;\n}\n.record-body>.delete{\n    padding-left: 10px;\n    margin-left: 10px;\n    border-left: 1px solid rgb(201, 201, 201);\n    color: rgb(33, 70, 181);\n}\n.record-item>.type{\n    position: absolute;\n    top: 5px;\n    right: 10px;\n    font-size: 14px;\n    padding: 0 6px;\n    height: 22px;\n    line-height: 22px;\n    color: #fff;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n}\n.type.expenditure{\n    background: rgb(241, 141, 158);\n}\n.type.income{\n    background: rgb(85, 194, 134);\n}\n\n```\n\n```css /public/css/add.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\nhr{\n    margin: 20px auto;\n    border: 0;\n    border-top: 1px solid rgb(220, 220, 220);\n}\n.content{\n    max-width: 600px;\n    margin: 0 auto;\n}\n.content-box{\n    display: flex;\n    flex-direction: column;\n    flex-wrap: wrap;\n    align-content: center;\n    margin: 0 10px;\n}\n.content-box>*{\n    width: 100%;\n}\n.home{\n    margin-top: 10px;\n    padding-left: 10px;\n}\n.title{\n    padding: 20px 0;\n    border-bottom: 1px solid rgb(220, 220, 220);\n}\n.title h2{\n    font-size: 30px;\n    font-weight: 500;\n}\n.content-box form{\n    margin-top: 10px;\n}\n.form-item{\n    margin-bottom: 15px;\n}\n.form-item label{\n    display: block;\n    height: 32px;\n    line-height: 32px;\n    font-size: 18px;\n}\n.form-item>*{\n    width: 100%;\n}\n.form-item>.control{\n    padding: 6px 12px;\n    height: 36px;\n    font-size: 16px;\n    line-height: 36px;\n    color: #363636;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n    outline: none;\n    font-family:\"Microsoft YaHei\",微软雅黑;\n}\n.form-item>.control:focus{\n    border-color: #66afe9;\n    -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n    box-shadow: inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px rgba(102, 175, 233, .6);\n}\n.form-item>textarea.control{\n    padding: 8px 12px;\n    height: 100px;\n    line-height: 1;\n    resize: none;\n}\n.content-box form>button{\n    width: 100%;\n    padding: 6px 12px;\n    margin-bottom: 15px;\n    border: 1px solid rgb(57, 162, 204);\n    background: rgb(37, 173, 204);\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n    font-size: 17px;\n    color: #fff;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.content-box form>button:hover{\n    background: rgb(32, 153, 190);\n}\n\n```\n\n```css /public/css/tip.css\nbody{\n    font-family:\"Microsoft YaHei\",微软雅黑;\n    color: #363636;\n}\n*{\n    padding: 0;\n    margin: 0;\n    box-sizing: border-box;\n    text-decoration: none;\n}\n.content{\n    margin: 0 auto;\n    max-width: 300px;\n    padding: 20px 30px;\n    background: rgba(77, 190, 215, 0.6);\n    margin-top: 20px;\n    display: flex;\n    align-items: center;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: space-between;\n    border-radius: 4px;\n    -webkit-border-radius: 4px;\n    -moz-border-radius: 4px;\n    -ms-border-radius: 4px;\n    -o-border-radius: 4px;\n}\n\n```","tags":["NodeJS","前端"],"categories":["学习笔记"]},{"title":"初识NodeJS","url":"/article/109cbe0a.html","content":"\n# 初识\nNodeJS是使用C++编写的基于ChromeV8引擎，开源、跨平台的JavaScript运行环境\n\n[中文API文档](https://nodejs.cn/api/)\n\n# Buffer\nBuffer(缓冲区)存放二进制数据的缓存区，类似数组Array\n\n```js\nlet buf = Buffer.alloc(10);//每个二进制位都清0\nlet buf_2 = Buffer.allocUnsafe(10);//不清0，可能有旧数据，但速度较快\n```\n\n字符串转二进制编码，每个字符按编码转为二进制存入\n\n```js\nlet buf_3 = Buffer.from('hello');\nconsole.log(buf_3);\n// <Buffer 68 65 6c 6c 6f>\n```\n\n将数组存入Buffer\n\n```js\nlet buf_4 = Buffer.from([111, 112, 113, 114]);\nconsole.log(buf_4);\n// <Buffer 6f 70 71 72>\n```\n\n`toString()`Buffer转字符串\n\n```js\nlet buf_4 = Buffer.from([111, 112, 113, 114]);\nconsole.log(buf_4.toString());// 默认采用UTF-8\n// opqr\n```\n\n使用下标访问Buffer\n\n```js\nlet buf_5 = Buffer.from('chuckle');\nconsole.log(buf_5[0]);//十六进制，99\nconsole.log(buf_5[0].toString(2));//转为二进制，1100011\nbuf_5[0] = 90;// 修改\nconsole.log(buf_5[0]);//十六进制，90\n```\n\n溢出，舍弃高位\n\n```js\nbuf_5[0] = 360;// 101101000\nconsole.log(buf_5[0]);//十六进制，104\nconsole.log(buf_5[0].toString(2));//1 0110 1000 => 110 1000\n```\n\nBuffer存中文，UTF-8中一汉字占三个字节\n\n```js\nlet buf_6 = Buffer.from('今天你好');\nbuf_6.write('轻笑');// 覆盖前两个\nconsole.log(buf_6);//<Buffer e8 bd bb e7 ac 91 e4 bd a0 e5 a5 bd>\nconsole.log(buf_6.toString());//轻笑你好\n```\n\n# fs模块\n文件系统（fs 模块）中的方法均有异步和同步版本，异步有回调函数，参数为err错误信息\n\n创建 text.txt 并写入内容\n\n```js\nconst fs = require('fs');\n//异步\nfs.writeFile('./text.txt', '轻笑chuckle', err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n//同步\nfs.writeFileSync('./text.txt', '轻笑chuckle');\n\n```\n\n`appendFile` 追加写入\n\n```js\nfs.appendFile('./text.txt', '\\r\\n追加内容', err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n// writeFile添加配置项实现追加写入\nfs.writeFile('./text.txt', '\\r\\n追加内容',{flag: 'a'} , err => {\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log('成功');\n});\n\n```\n\n`createWriteStream` 流式写入，适合频繁或大文件写入，与文件的连接不断开\n\n```js\nconst ws = fs.createWriteStream('.text.txt');\nws.write('1');\nws.write('2');\nws.write('3');\nws.close();// 断开连接，会自动断开，close可加可不加\n```\n\n`readFile` 文件读取\n\n```js\n// 回调函数两个参数，错误信息和文件内容\nfs.readFile('./text.txt', (err, data)=>{\n    if(err){\n        console.log(err);\n        return;\n    }\n    console.log(data.toString());\n});\n// 同步读取，直接返回文件内容\nlet data = fs.readFileSync('./text.txt');\nconsole.log(data.toString());\n\n```\n\n`createReadStream` 流式读取\n\n```js\nconst rs = fs.createReadStream('./1.mp4');\nrs.on('data', chunk =>{\n    console.log(chunk);// Buffer\n    console.log(chunk.length);// 每次读取64kb\n});\nrs.on('end', ()=>{\n    console.log('读取完成');\n});\n\n```\n\n复制文件，使用流式操作更快，占用内存更少\n\n```js\n// readFile\nfs.readFile('./text.txt', (err, data) =>{\n    if(err){\n        return console.error(err);\n    }\n    fs.writeFile('./text2.txt', data, err =>{});\n});\n// 流式操作\nconst rs = fs.createReadStream('./1.mp4');\nconst ws = fs.createWriteStream('./2.mp4');\nrs.on('data', chunk =>{\n    ws.write(chunk);\n});\n// 流式操作pipe\nrs.pipe(ws);\n\n```\n\n`rename` 文件重命名和移动\n\n```js\nfs.rename('./1.mp4', './3.mp4', err=>{});\nfs.rename('./3.mp4', './mp4/3.mp4', err=>{});\n```\n\n`unlink` 删除文件\n\n```js\nfs.unlink('./2.mp4', err=>{});\nfs.rm('./2.mp4', err=>{});\n```\n\n`mkdir` 创建文件夹\n\n```js\nfs.mkdir('./a', err=>{});\n// 递归创建\nfs.mkdir('./a/b/c', {recursive: true},err=>{});\n```\n\n`readdir` 读取文件夹，读取到一个目标文件夹下文件名的数组\n\n```js\nfs.readdir('./mp4', (err, data)=>{\n    console.log(data);// [ '3.mp4' ]\n});\n```\n\n`rmdir` 删除文件夹\n\n```js\nfs.rmdir('./a/b/c', err=>{});\n// 递归删除，文件夹非空时使用\nfs.rmdir('./a', {recursive: true},err=>{});\n// 或使用rm\nfs.rm('./a',{recursive: true} ,err=>{});\n```\n\n`stat` 查看资源状态\n\n```js\nfs.stat('./3.mp4', (err, data)=>{\n    console.log(data);// 输出信息\n    console.log(data.isDirectory());//是否是文件夹\n    console.log(data.isFile());//是否是普通文件\n});\n```\n\n**__dirname** 保存js文件所在目录的绝对路径，避免工作路径不同、工作区不同，导致相对路径不同而出bug\n\n```js\nfs.writeFileSync(__dirname + '/1.txt', 'chuckle');\n```\n\n批量重命名文件，在文件名前加上0\n\n```js\nfs.readdir(__dirname + '/rename', (err, data)=>{\n    data.forEach((item, index)=>{\n        let data = item.split('.');\n        let [num, suffix] = data;\n        if(Number(num)<10){\n            num = '0' + num;\n        }\n        fs.renameSync(`${__dirname}/rename/${item}`, `${__dirname}/rename/${num}.${suffix}`);\n    });\n});\n\n```\n\n# path模块\n`resolve` 拼接规范的绝对路径\n\n```js\nconst path = require('path');\nlet path1 = path.resolve(__dirname + '/rename');\nconsole.log(path1);// c:\\chuckle\\qx\\nodejs\\rename\n```\n\n其它方法\n\n```js\nconsole.log(path.sep);// 获取当前系统的路径分隔符\n// /\nconsole.log(path.parse(__filename));// 解析路径并返回对象\n// {\n//   root: 'c:\\\\',\n//   dir: 'c:\\\\chuckle\\\\qx\\\\nodejs',\n//   base: 'fs.js',\n//   ext: '.js',\n//   name: 'fs'\n// }\nconsole.log(path.basename(__filename));// 获取路径的基础名称\n// fs.js\nconsole.log(path.dirname(__filename));// 获取路径的目录名\n// c:\\chuckle\\qx\\nodejs\nconsole.log(path.extname(__filename));// 获取文件的扩展名\n// .js\n\n```\n\n# http模块\n搭建http服务：\n\n```js\n// 导入 http 模块\nconst http = require('http');\n// 创建服务对象\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');// 设置字符集防止乱码\n    response.end('你好');// 响应文本\n});\n\n// 监听端口，启动服务\nserver.listen(9000, ()=>{\n    // 当服务启动时运行回调函数\n    console.log('服务启动');\n});\n\n```\n\n## 获取请求报文\n\n获取请求行和请求头，修改createServe的回调函数\n\n```js\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    // 获取请求方法\n    console.log(request.method);\n    // 获取请求url，只包含路径和查询字符串\n    console.log(request.url);\n    // 获取http协议版本号\n    console.log(request.httpVersion);\n    // 获取http的请求头\n    console.log(request.headers);\n    // 获取请求头中单独的属性值\n    console.log(request.headers.host);\n    response.end('hello world');\n});\n\n```\n\n获取请求体\n\n```js\nconst server = http.createServer((request, response)=>{\n    // 当服务接收到http请求的时候运行回调函数\n    //获取请求体\n    let body = '';\n    // request也是一个可读流，绑定data事件一点点获取内容\n    request.on('data', chunk=>{\n        body += chunk;\n    })\n    // 绑定end事件\n    request.on('end', ()=>{\n        console.log(body);\n        // 响应\n        response.end('hello http');\n    });\n});\n\n```\n\n## 获取请求路径和查询字符串\n使用**url模块**获取请求路径和查询字符串\n\n```js\nconst url = require('url');// 导入url模块\nconst server = http.createServer((request, response)=>{\n    // 获取请求路径和查询字符串\n    console.log(request.url);\n    // 使用url模块解析url\n    let res = url.parse(request.url, true);// 第二个参数true将query属性值变为一个对象\n    console.log(res);\n    // Url {\n    //   protocol: null,\n    //   slashes: null,\n    //   auth: null,\n    //   host: null,\n    //   port: null,\n    //   hostname: null,\n    //   hash: null,\n    //   search: '?psw=1234&name=chuckle',\n    //   query: [Object: null prototype] { psw: '1234', name: 'chuckle' },\n    //   pathname: '/search',\n    //   path: '/search?psw=1234&name=chuckle',\n    //   href: '/search?psw=1234&name=chuckle'\n    // }\n    console.log(res.path);// 获取路径\n    console.log(res.query);// 获取查询字符串对象\n    console.log(res.query.psw);// 获取查询字符串中的属性值\n});\n\n```\n\n使用**URL类**获取请求路径和查询字符串\n\n```js\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    console.log(url);\n    // URL {\n    //   href: 'http://127.0.0.1:9000/search?psw=1234&name=chuckle',\n    //   origin: 'http://127.0.0.1:9000',\n    //   protocol: 'http:',\n    //   username: '',\n    //   password: '',\n    //   host: '127.0.0.1:9000',\n    //   hostname: '127.0.0.1',\n    //   port: '9000',\n    //   pathname: '/search',\n    //   search: '?psw=1234&name=chuckle',\n    //   searchParams: URLSearchParams { 'psw' => '1234', 'name' => 'chuckle' },\n    //   hash: ''\n    // }\n    console.log(url.pathname);// 获取路径\n    console.log(url.searchParams);// 获取查询字符串map对象\n    console.log(url.searchParams.get('psw'));// map对象用get获取属性值\n});\n\n```\n\n## 请求路径练习\n根据请求路径响应不同内容\n\n```js\nconst http = require('http');\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    // 获取请求方法\n    let {method} = request;\n    // 获取请求路径\n    let {pathname} = url;\n    // 根据请求路径响应不同内容\n    if (method === 'GET' && pathname === '/login'){\n        response.end('login');\n    }else if (method === 'GET' && pathname === '/reg'){\n        response.end('reg');\n    }else{\n        response.end('Not Found');\n    }\n});\nserver.listen(9000, ()=>{\n    console.log('服务启动');\n});\n\n```\n\n## 设置响应报文\n设置响应码、响应头、响应体\n\n```js\nconst http = require('http');\nconst server = http.createServer((request, response)=>{\n    // 1.设置响应状态码\n    response.statusCode = 200;\n    // 2.设置响应状态的描述\n    response.statusMessage = 'chuckle';\n    // 3.响应头，两个参数，响应名和值，可自定义\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');\n    response.setHeader('Server', 'nodejs');\n    response.setHeader('MyHeader', 'chuckle');\n    // 设置多个同名响应头\n    response.setHeader('test', ['a', 'b', 'c']);\n    // 4. 设置响应体，end只能执行一个，write可以有多个\n    response.write('chuckle');\n    response.write('qx');\n    // end是必须的，但设置write后一般end设为空\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n配合fs模块响应文件\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let html = fs.readFileSync(__dirname + '/2.html');\n    response.write(html);\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n## 响应文件练习\n根据文件路径响应不同内容，下面这种写法不方便，后面有优化\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let html = fs.readFileSync(__dirname + '/2.html');\n    let css = fs.readFileSync(__dirname + '/2.css');\n    let url = new URL(request.url, 'http://127.0.0.1:9000');\n    let {pathname} = url;\n    if(pathname === '/'){\n        response.write(html);\n    }else if(pathname === '/2.css'){\n        response.write(css);\n    }else {\n        response.statusCode = 404;\n        response.write('404');\n    }\n    response.end();\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n优化版：静态资源响应服务\n\n```js\nconst http = require('http');\nconst fs = require('fs');\n\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            response.statusCode = 404;\n            response.write('404');\n            response.end();\n            return;\n        }\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n## 设置资源mime类型\nmime类型用于表示文档、文件或字节流的性质和类型\n\nHTTP服务可以设置响应头 Content-Type 来表明响应体的mime类型，浏览器会根据该类型决定如何处理资源\n\n常见mime类型：\n**1、html** text/html\n**2、css** text/css\n**3、js** text/javascript\n**4、png** image/png\n**5、jpg** image/jpeg\n**6、gif** image/gif\n**7、mp4** video/mp4\n**8、mp3** audio/mpeg\n**9、json** application/json\n\n对于未知的资源类型，可以选择 application/octet-stream 刘览器在遇到该类型的响应时，会对响应体内容进行独立存储，实现下载效果\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nlet mime = {\n    // html就加上字符集，避免乱码\n    html: 'text/html;charset=utf-8',\n    css: 'text/css',\n    js: 'text/javascript',\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    gif: 'image/gif',\n    mp4: 'video/mp4',\n    mp3: 'audio/mpeg',\n    json: 'application/json',\n    other: 'application/octet-stream'\n}\n\nconst server = http.createServer((request, response)=>{\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            response.statusCode = 404;\n            response.write('404');\n            response.end();\n            return;\n        }\n        //获取文件后缀名\n        let ext = path.extname(filePath).slice(1);\n        let type = mime[ext] ? mime[ext] : mime[other];\n        console.log(type);\n        response.setHeader('Content-Type', type);\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n# 完善错误处理\n[Node.js常见系统错误](https://nodejs.cn/api/errors.html#common-system-errors)\n\n```js\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\nlet mime = {\n    // html就加上字符集，避免乱码\n    html: 'text/html;charset=utf-8',\n    css: 'text/css',\n    js: 'text/javascript',\n    png: 'image/png',\n    jpg: 'image/jpeg',\n    gif: 'image/gif',\n    mp4: 'video/mp4',\n    mp3: 'audio/mpeg',\n    json: 'application/json',\n    other: 'application/octet-stream'\n}\nlet errs = {\n    ENOENT: 404,\n    EPERM: 403\n}\n\nconst server = http.createServer((request, response)=>{\n    response.setHeader('Content-Type', 'text/html; charset=utf-8');\n    // 请求方法错误\n    console.log(request.method);\n    if(request.method !== 'GET'){\n       response.statusCode = 405;\n       response.end('出错了');\n       return;\n    }\n    let url = new URL(request.url, 'https://127.0.0.1:9000');\n    let {pathname} = url;\n    let root = __dirname;//网站根目录，资源都在这个根目录下找\n    let filePath = root + pathname;\n    fs.readFile(filePath, (err, data)=>{\n        if(err){\n            let errCode = errs[err.code] ? errs[err.code] : 500;\n            console.log(errCode);\n            response.statusCode = errCode;\n            response.write('出错了');\n            response.end();\n            return;\n        }\n        //获取文件后缀名\n        let ext = path.extname(filePath).slice(1);\n        let type = mime[ext] ? mime[ext] : mime[other];\n        response.setHeader('Content-Type', type);\n        response.write(data);\n        response.end();\n    });\n});\n\nserver.listen(9000, ()=>{\n    console.log('服务启动成功');\n});\n\n```\n\n# 模块化\n将一个复杂的程序文件，按一定规则拆分为多个文件，即模块化，每个小文件就算一个模块\n\n模块内部数据是私有的，但可以主动度外暴露出去\n\n**模块化项目：**\n编写项目时一个个模块编写，再组合起来\n\n**模块化优点：**\n1、防止命名冲突\n2、高服用性\n3、高维护性\n\n# 暴露数据\n在模块中使用`module.exports`和`exports`向外暴露数据，但两者不能同时使用\n\n隐式关系：exports = module.exports = {}\n\n```js\nlet name = 'chuckle';\nlet age = 19;\nfunction fun() {\n    console.log(name);\n}\nmodule.exports = {\n    name,\n    fun\n}\nexports.age = age;\n\n```\n\n# 导入模块\n1. 导入js/sjon文件或c编写的mode扩展插件可以省略后缀，同名优先导入js\n2. 导入自己的模块最好使用相对路径 **./**\n3. 导入其它类型的文件会以js文件处理\n4. 导入**文件夹**，首先会去找文件夹内package.json里main属性对应的文件，如果没用main属性或package.json则去找文件夹内的index.js或index.json，如果还没找到则报错，main属性对应的文件不存在也会报错\n5. 导入nodejs内置模块时，直接写模块名即可\n\n```js\nconst mod = require('./1.js');\nconst mod = require('./1');\n```\n\n# 包管理工具\n包，即package，是一组特定功能的源码集合，即别人写好的各种工具\n\n管理包，即对包进行下载、安装、删除、上传操作\n\n常见包管理工具：npm、yarn、cnpm\n\n## npm\nNode Package Manager即npm，是nodejs内置的包管理工具\n\npackage.json 是包必须有的配置文件\npackage-lock.json 存放依赖包的版本信息\n\nrequire导入npm包流程：\n1、在当前文件夹下的node_modules中找同名文件夹\n2、在上级目录中node_modules中找同名文件夹，直到磁盘根目录\n\n```js\nnpm i <包名@版本号>// 安装\nnpm r <包名>// 移除\n```\n\nnpm配置命令别名，修改package.json的 **scripts** 属性，通过npm run <命令名>运行命令，会自动向上寻找，添加start属性，可以省略run，直接npm start\n\n```json\n\"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"server\": \"node ./index.js\",\n    \"start\": \"node ./index.js\"\n},\n// 使用\nnpm run server\nnpm start\n\n```\n\n通过指定源来提高包安装速度\n\n```js\nnpm i <包名> --registry=https://registry.npmmirror.com\n```\n\n## 开发和生产依赖\n开发环境：写源代码、工程文件时的环境，一般指程序员的电脑，只能由程序员访问\n生产环境：项目代码正式运行的环境，一般指服务器，所有用户都能访问\n\n开发依赖：只在写代码时用到的依赖包，安装时添加 -D 或 --save-dev\n生产依赖：默认项，既在写代码时使用，又在代码运行时使用的依赖包，安装时添加 -S 或 --save 参数，\n\npackage.json中，dependencies属性保存生产依赖包信息，devDependencies属性保存开发依赖包信息\n\n## 全局安装\n开发和生产依赖都是局部安装的包，存放在工作目录的node_modules文件夹中\n \n全局安装 npm i -g 不受工作目录位置限制，无需导入，一般是在命令行中通过独立命令去使用\n\nnpm root -g 查看全局安装包的位置\n\n只有全局类的工具如 gulp、nodemon等才适合全局安装，通过查看包的文档来确定安装方式\n\n## cnpm\n[cnpm--npmmirror镜像站](https://npmmirror.com/)\n使用方式和npm一样，是淘宝构建的完整 npmjs.org 镜像，了解即可，大多还是使用npm\n\n修改npm的源地址来使用淘宝镜像\n\n```js\n// 查看npm的源\nnpm config list\n// 不推荐，该源无法上传包\nnpm config set registry https://registry.npmmirror.com/\n// 安装时临时指定源\nnpm i <包名> --registry=https://registry.npmmirror.com\n// 使用nrm管理源，推荐\nnpm i -g nrm\nnrm use taobao\nnrm ls// 列出可切换的所有源\nnpm install -g nrm open@8.4.2 --save// 使用nrm有报错则运行此命令\n\n```\n\n## yarn\n[yarn](https://yarnpkg.com/) 是由 Facebook 在 2016 年推出的新的 Javascript 包管理工具\n\nyarn和npm需要按需选用，包管理工具不能混用，yarn的锁文件是yarn.lock\n\n`npm i -g yarn`安装yarn\n\n常用命令：\n1. 初始化 yarn init / yarn init -y\n2. 安装包\n    1. yarn add <包名> 生产依赖\n    2. yarn add <包名> --dev 开发依赖\n    3. yarn global add <包名> 全局安装，第一次使用记得手动配置环境变量\n3. 删除包\n   1. yarn remove uniq 删除项目依赖包\n   2. yarn global remove nodemon 全局删除包\n4. 安装项目依赖 yarn\n5. 运行命令别名 yarn <别名>\n6. 全局安装包的位置 yarn global bin\n\n## 管理npm包\n\n1. 修改 package.json 中的版本号\n2. npm publish 提交包\n3. npm unpublish --force 删除包\n\n# nvm管理node版本\nnvm 全称 Node Version Manager 用来管理 node 版本的工具\n\n常用命令：\n1. nvm list available 显示所有可以下载的 Node.js 版本\n2. nvm list 显示已安装的版本\n3. nvm install 18.12.1 安装 18.12.1 版本的 Node.js\n4. nvm install latest 安装最新版的 Node.js\n5. nvm uninstall 18.12.1 删除某个版本的 Node.js\n6. nvm use 18.12.1 切换 18.12.1 的 Node.js\n\n\n\n\n","tags":["NodeJS","前端"],"categories":["学习笔记"]},{"title":"文章添加预设或实时生成的AI简介","url":"/article/17d3383a.html","content":"\n# 前言\n[@Heo](https://blog.zhheo.com/)又整新活了，给文章加上了AI，我也开写，竞速。\n\n大半夜领先一点就睡不着的屑Heo，那就挂一下同类友情项目罢[Post-Abstract-AI](https://github.com/zhheo/Post-Abstract-AI)\n\n<img src=https://cdn.chuckle.top/images/46-2.webp width=\"60%\">\n\n**有这些特性：**\n1. **真AI！**，接入tianliGPT（或是使用官方api接口），JS动态获取全文所有纯文本，传给api实时获取文章摘要（受限于tianliGPT的成本，目前仍有缓存机制）\n2. 遇到标点符号慢下来，动态打字速度\n3. setTimeout和requestAnimationFrame相结合降低性能消耗，动态清除setTimeout，交互放心\n4. 使用IntersectionObserver监听，当容器在视口不可见后停止生成摘要，重新出现在视口后继续生成\n5. 模拟GPT的光标效果\n6. 多个按钮实现多个功能，自我介绍、文章摘要、推荐相关文章等\n7. 良好兼容性，性能消耗小。\n8. 适配pjax\n  \n未来的计划：\n1. 进行封装，简单引入js后，QX_AI(<传入容器元素>)即可生成QX-AI并自动初始化\n2. 提供使用vercel中转官方api接口的项目\n\n# 实现\n**注意：**\n1、为确保 recommendList() 函数正常运行、相关推荐能正常生成，btf主题用户请打开文章页侧边栏中的两个板块：最新文章和相关推荐，非btf用户也许需要手动更改相关js\n2、tianliGPT中国大陆访问速度快，key与域名相绑定，无需担心盗刷，一次生成后续不消耗key字数，tianliGPT的key购买渠道：[购买tianliGPT-Key](https://afdian.net/item/2e07e870dad911edacb852540025c377)\n3、如有bug，请在评论区讨论，请忽略js中的不规范命名和一堆变量，会优化的咕咕咕。\n\n手动修改js中这部分常量以使用AI实时简介\n\n```js\n//默认true，使用tianliGPT，false使用官方api，记得配置Key\nconst choiceApi = true;\nconst apiKey = \"填入chatGPT的apiKey\";\n//tianliGPT的参数\nconst tlReferer = 'https://你的授权域名/';\nconst tlKey = '填入tianliGPT的key';\n```\n\n虽然以及有AI实时生成了，但还是需要预设的，在markdown文件的matter添加ai配置，放入ai事先生成好的文章简介或提升去点AI生成按钮，不想出现AI模块的文章就删去这个配置项\n\n```markdown\n---\ntitle:\nai: 暂无预设简介，请点击下方AI实时简介按钮。\n---\n```\n\n## 2.0版\n**新特性：**\n1. 真！AI，接入tianliGPT或是使用官方api接口，随意选择\n2. 前端限制请求频率、动态打断fetch\n3. 压缩文本降低key压力，纯文本1000字以上的文章，截取前500后200中间300字生成摘要，降低key字数消耗，当然，可以给 getTextContent 传入第二个参数为false，从而不压缩文本\n\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n  .post-ai\n    .ai-title\n      i.fa-brands.fa-airbnb\n      .ai-title-text QX-AI\n      .ai-tag GPT-4\n    .ai-explanation QX-AI初始化中...\n    .ai-explanation-none #{page.ai}\n    .ai-btn-box\n      .ai-btn-item 介绍自己\n      .ai-btn-item 生成本文简介\n      .ai-btn-item 推荐相关文章\n      .ai-btn-item 前往主页\n    script(src=\"/js/post-ai.js\" defer=\"true\" data-pjax)\n\n```\n\n新建`post-ai.js`\n4-16修复了若干bug\n\n```js\nfunction allAI() {\n  let animationRunning = true; // 标志变量，控制动画函数的运行\n  let explanation = document.querySelector('.ai-explanation');\n  let abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n  let post_ai = document.querySelector('.post-ai');\n  let ai_btn_item = document.querySelectorAll('.ai-btn-item');\n  let ai_str = '';\n  let ai_str_length = '';\n  let delay_init = 600;\n  let i = 0;\n  let j = 0;\n  let sto = [];\n  let elapsed = 0;\n  let completeGenerate = false;\n  let controller = new AbortController();//控制fetch\n  let signal = controller.signal;\n  //默认true，使用tianliGPT，false使用官方api，记得配置Key\n  const choiceApi = true;\n  const apiKey = \"填入chatGPT的apiKey\";\n  //tianliGPT的参数\n  const tlReferer = 'https://你的授权域名/';\n  const tlKey = '填入tianliGPT的key';\n  //-----------------------------------------------\n  const animate = (timestamp) => {\n    if (!animationRunning) {\n      return; // 动画函数停止运行\n    }\n    if (!animate.start) animate.start = timestamp;\n    elapsed = timestamp - animate.start;\n    if (elapsed >= 20) {\n      animate.start = timestamp;\n      if (i < ai_str_length - 1) {\n        let char = ai_str.charAt(i + 1);\n        let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;\n        if (explanation.firstElementChild) {\n          explanation.removeChild(explanation.firstElementChild);\n        }\n        explanation.innerHTML += char;\n        let div = document.createElement('div');\n        div.className = \"ai-cursor\";\n        explanation.appendChild(div);\n        i++;\n        if (delay === 150) {\n          document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n        }\n        if (i === ai_str_length - 1) {\n          observer.disconnect();// 暂停监听\n          explanation.removeChild(explanation.firstElementChild);\n        }\n        sto[0] = setTimeout(() => {\n          requestAnimationFrame(animate);\n        }, delay);\n      }\n    } else {\n      requestAnimationFrame(animate);\n    }\n  };\n  const observer = new IntersectionObserver((entries) => {\n    let isVisible = entries[0].isIntersecting;\n    animationRunning = isVisible; // 标志变量更新\n    if (animationRunning) {\n      delay_init = i === 0 ? 200 : 20;\n      sto[1] = setTimeout(() => {\n        if (j) {\n          i = 0;\n          j = 0;\n        }\n        if (i === 0) {\n          explanation.innerHTML = ai_str.charAt(0);\n        }\n        requestAnimationFrame(animate);\n      }, delay_init);\n    }\n  }, { threshold: 0 });\n  function clearSTO() {\n    if (sto.length) {\n      sto.forEach((item) => {\n        if (item) {\n          clearTimeout(item);\n        }\n      });\n    }\n  }\n  function resetAI(df = true) {\n    i = 0;//重置计数器\n    j = 1;\n    clearSTO();\n    animationRunning = false;\n    elapsed = 0;\n    if (df) {\n      explanation.innerHTML = '生成中. . .';\n    } else {\n      explanation.innerHTML = '请等待. . .';\n    }\n    // console.log(completeGenerate);\n    if (!completeGenerate) {\n      controller.abort();\n      // console.log(completeGenerate);\n    }\n    ai_str = '';\n    ai_str_length = '';\n    observer.disconnect();// 暂停上一次监听\n  }\n  function startAI(str, df = true) {\n    resetAI(df);\n    ai_str = str;\n    ai_str_length = ai_str.length;\n    observer.observe(post_ai);//启动新监听\n  }\n  function aiIntroduce() {\n    startAI('我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。');\n  }\n  function aiAbstract() {\n    startAI(abstract_value);\n  }\n  function aiRecommend() {\n    resetAI();\n    sto[2] = setTimeout(() => {\n      explanation.innerHTML = recommendList();\n    }, 300);\n  }\n  function aiGoHome() {\n    startAI('正在前往博客主页...', false);\n    sto[2] = setTimeout(() => {\n      pjax.loadUrl(\"/\");\n    }, 1000);\n  }\n  async function aiGenerateAbstract() {\n    // if(!verifyDomainName()){btf.snackbarShow('未经授权的域名');return;}\n    // if(!completeGenerate){\n    //   btf.snackbarShow('AI摘要正在生成，请勿重复发起');\n    //   return;\n    // }\n    if (clickFrequency()) {\n      return;\n    }\n    localStorage.setItem('aiTime', Date.now());\n    resetAI();\n    const ele = document.querySelector('#article-container');\n    const content = getTextContent(ele);\n    console.log(content);\n    const response = await getGptResponse(content, choiceApi);//true使用tianliGPT，false使用官方api\n    console.log(response);\n    startAI(response);\n  }\n  function recommendList() {\n    let info = `推荐文章：<br />`;\n    let thumbnail = document.querySelectorAll('.card-recommend-post .aside-list .aside-list-item .thumbnail');\n    if (!thumbnail||thumbnail.length===0) {\n      info = '很抱歉，无法找到类似的文章，你也可以看看本站最近更新的文章：<br />';\n      thumbnail = document.querySelectorAll('.card-recent-post .aside-list .aside-list-item .thumbnail');\n    }\n    info += '<div class=\"ai-recommend\">';\n    thumbnail.forEach((item, index) => {\n      info += `<div class=\"ai-recommend-item\"><span>推荐${index + 1}：</span><a href=\"javascript:;\" onclick=\"pjax.loadUrl('${item.href}')\" title=\"${item.title}\" data-pjax-state=\"\">${item.title}</a></div>`;\n    });\n    info += '</div>'\n    return info;\n  }\n  //ai首屏初始化，绑定按钮注册事件\n  function ai_init() {\n    explanation = document.querySelector('.ai-explanation');\n    abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n    post_ai = document.querySelector('.post-ai');\n    ai_btn_item = document.querySelectorAll('.ai-btn-item');\n    const funArr = [aiIntroduce, aiAbstract, aiRecommend, aiGenerateAbstract];\n    ai_btn_item.forEach((item, index) => {\n      item.addEventListener('click', () => {\n        funArr[index]();\n      });\n    });\n    aiIntroduce();\n  }\n  function clickFrequency(t = 3000) {\n    let time = Date.now() - localStorage.getItem('aiTime');\n    if (time < t) {\n      btf.snackbarShow(`${3 - parseInt(time / 1000)}后才能再次点击真AI简介`);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  // 真AI简介相关函数\n\n  // function verifyDomainName(){\n  //   const domain = window.location.hostname;\n  //   const authorized = ['www.qcqx.cn','www.chuckle.top','127.0.0.1'];\n  //   return authorized.includes(domain)\n  // }\n  //获取某个元素内的所有纯文本，并按顺序拼接返回\n  function getText(element) {\n    //需要排除的元素及其子元素\n    const excludeClasses = ['highlight', 'Copyright-Notice', 'post-ai', 'post-series', 'mini-sandbox',];\n    let textContent = '';\n    for (let node of element.childNodes) {\n      if (node.nodeType === Node.TEXT_NODE) {\n        //如果是纯文本节点则获取内容拼接\n        textContent += node.textContent.trim();\n      } else if (node.nodeType === Node.ELEMENT_NODE) {\n        let hasExcludeClass = false;//跟踪元素是否包含需要排除的类名\n        //遍历类名\n        for (let className of node.classList) {\n          //如果包含则hasExcludeClass设为true，且break跳出循环\n          if (excludeClasses.includes(className)) {\n            hasExcludeClass = true;\n            break;\n          }\n        }\n        //如果hasExcludeClass为false，即该标签不包含需要排除的类，可以继续向下遍历子元素\n        if (!hasExcludeClass) {\n          //不同元素内获取的文本用句号隔开\n          let innerTextContent = getText(node);\n          // if (textContent && innerTextContent) {\n          //   //如果本来有标点符号则不添加\n          //   if (/[：:,.，。?？/；;!！（）、)(]$/.test(textContent) || /^[：:,.，。?？/；;!！（）、@#￥$%&)(]/.test(innerTextContent)) {\n          //     textContent += innerTextContent;\n          //   } else {\n          //     textContent += '。' + innerTextContent;\n          //   }\n          // } else {\n          //   textContent += innerTextContent;\n          // }\n          textContent += innerTextContent;\n        }\n      }\n    }\n    //返回纯文本节点的内容\n    return textContent.replace(/\\s+/g, '');\n  }\n  //获取各级标题\n  function extractHeadings(element) {\n    const headings = element.querySelectorAll('h1, h2, h3, h4');\n    const result = [];\n    for (let i = 0; i < headings.length; i++) {\n      const heading = headings[i];\n      const headingText = heading.textContent.trim();\n      result.push(headingText);\n      const childHeadings = extractHeadings(heading);\n      result.push(...childHeadings);\n    }\n    return result.join(\";\");\n  }\n  //按比例切割字符串\n  function extractString(str) {\n    // 截取前500个字符\n    var first500 = str.substring(0, 500);\n    // 截取末尾200个字符\n    var last200 = str.substring(str.length - 200);\n    // 截取中间300个字符\n    var midStartIndex = (str.length - 300) / 2; // 计算中间部分的起始索引\n    var middle300 = str.substring(midStartIndex, midStartIndex + 300);\n    // 将三个部分拼接在一起\n    var result = first500 + middle300 + last200;\n    // 返回截取后的字符串\n    return result;\n  }\n  //获得字符串，默认进行切割，false返回原文纯文本\n  function getTextContent(element, i = true) {\n    let content;\n    if (i) {\n      content = `文章的各级标题：${extractHeadings(element)}。文章内容的截取：${extractString(getText(element))}`;\n    } else {\n      content = `${getText(element)}`;\n    }\n    return content;\n  }\n  //发送请求获得简介\n  async function getGptResponse(content, i = true) {\n    completeGenerate = false;\n    controller = new AbortController();\n    signal = controller.signal;\n    let response = '';\n    if (i) {\n      try {\n        response = await fetch('https://summary.tianli0.top/', {\n          signal: signal,\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"Referer\": tlReferer\n          },\n          body: JSON.stringify({\n            content: content,\n            key: tlKey\n          })\n        });\n        if (response.status === 429) {\n          startAI('请求过于频繁，请稍后再请求AI。');\n        }\n        if (!response.ok) {\n          throw new Error('Response not ok');\n        }\n        // 处理响应\n      } catch (error) {\n        console.error('Error occurred:', error);\n        startAI(\"QX-AI请求tianliGPT出错了，请稍后再试。\");\n      }\n      // 解析响应并返回结果\n      const data = await response.json();\n      const outputText = data.summary;\n      // console.log(outputText);\n      completeGenerate = true;\n      return outputText;\n    } else {\n      const prompt = `你是一个摘要生成工具，你需要解释我发送给你的内容，不要换行，不要超过200字，只需要介绍文章的内容，不需要提出建议和缺少的东西。请用中文回答，文章内容为：${content}`;\n      const apiUrl = \"https://api.openai.com/v1/chat/completions\";\n      try {\n        response = await fetch(apiUrl, {\n          signal: signal,\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": `Bearer ${apiKey}`\n          },\n          body: JSON.stringify({\n            model: \"gpt-3.5-turbo\",\n            messages: [{ \"role\": \"user\", \"content\": prompt }],\n          })\n        });\n        if (response.status === 429) {\n          startAI('请求过于频繁，请稍后再请求AI。');\n        }\n        if (!response.ok) {\n          throw new Error('Response not ok');\n        }\n        // 处理响应\n      } catch (error) {\n        console.error('Error occurred:', error);\n        startAI(\"QX-AI请求chatGPT出错了，请稍后再试。\");\n      }\n      // 解析响应并返回结果\n      const data = await response.json();\n      const outputText = data.choices[0].message.content;\n      completeGenerate = true;\n      return outputText;\n    }\n  }\n  ai_init();\n}\nallAI();\n\n```\n\n添加CSS，颜色变量可F12自取，建议自己重新配色(2.0版本无css更新)\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n.ai-btn-box{\n    font-size: 15.5px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-btn-item{\n    padding: 5px 10px;\n    margin: 10px 16px 0px 5px;\n    width: fit-content;\n    line-height: 1;\n    background: rgba(48, 52, 63, 0.75);\n    color: #fff;\n    border-radius: 6px 6px 6px 0;\n    -webkit-border-radius: 6px 6px 6px 0;\n    -moz-border-radius: 6px 6px 6px 0;\n    -ms-border-radius: 6px 6px 6px 0;\n    -o-border-radius: 6px 6px 6px 0;\n    user-select: none;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.ai-btn-item:hover{\n    background: #49b0f5dc;\n}\n.ai-recommend{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-recommend-item{\n    width: 50%;\n    margin-top: 2px;\n}\n@media screen and (max-width:768px){\n  .ai-btn-box{\n    justify-content: center;\n  }\n  .ai-recommend .ai-recommend-item{\n    width: 100%;\n  }\n}\n.ai-explanation-none{\n    position: absolute;\n    opacity: 0;\n    width: 0;\n    height: 0;\n    z-index: -999;\n}\n\n```\n\n\n## 1.1版\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n  .post-ai\n    .ai-title\n      i.fa-brands.fa-airbnb\n      .ai-title-text QX-AI\n      .ai-tag GPT-4\n    .ai-explanation QX-AI初始化中...\n    .ai-explanation-none #{page.ai}\n    .ai-btn-box\n      .ai-btn-item 介绍自己\n      .ai-btn-item 生成本文简介\n      .ai-btn-item 推荐相关文章\n      .ai-btn-item 前往主页\n    script(src=\"/js/post-ai.js?2\" defer=\"true\" data-pjax)\n\n```\n\n新建`post-ai.js`\n\n```js\nif (true) {\n let animationRunning = true; // 标志变量，控制动画函数的运行\n const explanation = document.querySelector('.ai-explanation');\n const abstract_value = document.querySelector('.ai-explanation-none').innerHTML;\n const post_ai = document.querySelector('.post-ai');\n let ai_str = '';\n let ai_str_length = '';\n let delay_init = 600;\n let i = 0;\n let j = 0;\n let sto = [];\n let elapsed = 0;\n const animate = (timestamp) => {\n   if (!animationRunning) {\n     return; // 动画函数停止运行\n   }\n   if (!animate.start) animate.start = timestamp;\n   elapsed = timestamp - animate.start;\n   if (elapsed >= 20) {\n     animate.start = timestamp;\n     if (i < ai_str_length-1) {\n       let char = ai_str.charAt(i+1);\n       let delay = /[,.，。!?！？]/.test(char) ? 150 : 20;\n       if(explanation.firstElementChild){\n         explanation.removeChild(explanation.firstElementChild);\n       }\n       explanation.innerHTML += char;\n       let div = document.createElement('div');\n       div.className = \"ai-cursor\";\n       explanation.appendChild(div);\n       i++;\n       if(delay === 150){\n         document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n       }\n       if(i === ai_str_length-1){\n         observer.disconnect();// 暂停监听\n         explanation.removeChild(explanation.firstElementChild);\n       }\n       sto[0] = setTimeout(() => {\n         requestAnimationFrame(animate);\n       }, delay);\n     }\n   } else {\n     requestAnimationFrame(animate);\n   }\n };\n const observer = new IntersectionObserver((entries) => {\n   let isVisible = entries[0].isIntersecting;\n   animationRunning = isVisible; // 标志变量更新\n   if(animationRunning){\n     delay_init = i===0 ? 200 : 20;\n     sto[1] = setTimeout(() => {\n       if(j){\n         i = 0;\n         j = 0;\n       }\n       if(i===0){\n         explanation.innerHTML = ai_str.charAt(0);\n       }\n       requestAnimationFrame(animate);\n     }, delay_init);\n   }\n }, { threshold: 0 });\n function clearSTO(){\n   if(sto.length){\n     sto.forEach((item)=>{\n       if(item){\n         clearTimeout(item);\n       }\n     });\n   }\n }\n function startAI(str,df=true){\n   i = 0;//重置计数器\n   j = 1;\n   clearSTO();\n   animationRunning = false;\n   elapsed = 0;\n   if(df){\n     explanation.innerHTML = '生成中. . .';\n   }else{\n     explanation.innerHTML = '请等待. . .';\n   }\n   ai_str = str;\n   ai_str_length = ai_str.length;\n   observer.disconnect();// 暂停上一次监听\n   observer.observe(post_ai);//启动新监听\n }\n function aiIntroduce(){\n   startAI('我是文章辅助AI: QX-AI，点击下方的按钮，让我生成本文简介、推荐相关文章等。');\n }\n function aiAbstract(){\n   startAI(abstract_value);\n }\n function aiRecommend(){\n   i = 0;//重置计数器\n   j = 1;\n   clearSTO();\n   animationRunning = false;\n   elapsed = 0;\n   explanation.innerHTML = '生成中. . .';\n   ai_str = '';\n   ai_str_length = '';\n   observer.disconnect();// 暂停上一次监听\n   sto[2] = setTimeout(() => {\n     explanation.innerHTML = recommendList();\n   }, 600);\n }\n function aiGoHome(){\n   startAI('正在前往博客主页...',false);\n   sto[2] = setTimeout(() => {\n     pjax.loadUrl(\"/\");\n   }, 1000);\n }\n const ai_btn_item = document.querySelectorAll('.ai-btn-item');\n ai_btn_item.forEach((item, index)=>{\n   item.addEventListener('click', ()=>{\n     switch(index) {\n       case 0:\n         aiIntroduce();\n         break;\n       case 1:\n         aiAbstract();\n         break;\n       case 2:\n         aiRecommend();\n         break;\n       case 3:\n         aiGoHome();\n       break;\n     } \n   });\n });\n function recommendList(){\n   let info = `推荐文章：<br />`;\n   let thumbnail = document.querySelectorAll('.card-recommend-post .aside-list .aside-list-item .thumbnail');\n   if(!thumbnail){\n     info = '很抱歉，无法找到类似的文章，你也可以看看本站最新发布的文章：<br />';\n     thumbnail = document.querySelectorAll('.card-recent-post .aside-list .aside-list-item .thumbnail');\n   }\n   info += '<div class=\"ai-recommend\">';\n   thumbnail.forEach((item, index)=>{\n     info += `<div class=\"ai-recommend-item\"><span>推荐${index+1}：</span><a href=\"javascript:;\" onclick=\"pjax.loadUrl('${item.href}')\" title=\"${item.title}\" data-pjax-state=\"\">${item.title}</a></div>`;\n   });\n   info += '</div>'\n   return info;\n }\n aiIntroduce();\n}\n\n```\n\n添加CSS，颜色变量可F12自取\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n.ai-btn-box{\n    font-size: 15.5px;\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-btn-item{\n    padding: 5px 10px;\n    margin: 10px 16px 0px 5px;\n    width: fit-content;\n    line-height: 1;\n    background: rgba(48, 52, 63, 0.75);\n    color: #fff;\n    border-radius: 6px 6px 6px 0;\n    -webkit-border-radius: 6px 6px 6px 0;\n    -moz-border-radius: 6px 6px 6px 0;\n    -ms-border-radius: 6px 6px 6px 0;\n    -o-border-radius: 6px 6px 6px 0;\n    user-select: none;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n.ai-btn-item:hover{\n    background: #49b0f5dc;\n}\n.ai-recommend{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n.ai-recommend-item{\n    width: 50%;\n    margin-top: 2px;\n}\n@media screen and (max-width:768px){\n  .ai-btn-box{\n    justify-content: center;\n  }\n  .ai-recommend .ai-recommend-item{\n    width: 100%;\n  }\n}\n.ai-explanation-none{\n    position: absolute;\n    opacity: 0;\n    width: 0;\n    height: 0;\n    z-index: -999;\n}\n\n```\n\n使用：在markdown文件的matter添加ai配置，放入ai事先生成好的文章简介\n\n```markdown\n---\ntitle: 文章添加AI摘要和推荐\nai: 本文介绍了如何通过手动生成GPT网页版摘要，再用JS模拟GPT打字生成效果，实现AI摘要。作者详细讲解了实现思路，包括停顿、延迟等策略，以及如何监听视口并控制生成。作者还提到了未来计划，即使用API生成更多摘要。此外，作者还给出了修改 post.pug 和 CSS 的代码。\n---\n\n```\n\n\n## 1.0版\n才两个小时就沦为旧版的屑\n修改`post.pug`，将下面代码加在合适的位置,如 article#article-container.post-content 后，注意缩进\n\n```js\nif page.ai\n   .post-ai\n   .ai-title\n   i.fa-brands.fa-airbnb\n   .ai-title-text AI摘要\n   .ai-tag GPT-4\n   .ai-explanation #{page.ai}\n   script.\n   if (true) {\n     let animationRunning = true; // 标志变量，控制动画函数的运行\n     const explanation = document.querySelector('.ai-explanation');\n     const post_ai = document.querySelector('.post-ai');\n     const ai_str = explanation.innerHTML;\n     const ai_str_length = ai_str.length;\n     let delay_init = 600;\n     let i = 0;\n     explanation.innerHTML = 'AI摘要生成中. . .';\n     const animate = (timestamp) => {\n       if (!animationRunning) {\n         return; // 动画函数停止运行\n       }\n       if (!animate.start) animate.start = timestamp;\n       const elapsed = timestamp - animate.start;\n       if (elapsed >= 20) {\n         animate.start = timestamp;\n         if (i < ai_str_length-1) {\n           let char = ai_str.charAt(i+1);\n           let delay = /[,.，。!?！？]/.test(char) ? 160 : 20;\n           if(explanation.firstElementChild){\n             explanation.removeChild(explanation.firstElementChild);\n           }\n           explanation.innerHTML += char;\n           let div = document.createElement('div');\n           div.className = \"ai-cursor\";\n           explanation.appendChild(div);\n           i++;\n           if(delay === 160){\n             document.querySelector('.ai-explanation .ai-cursor').style.opacity = \"0\";\n           }\n           if(i === ai_str_length-1){\n             observer.disconnect();// 暂停监听\n             explanation.removeChild(explanation.firstElementChild);\n           }\n           setTimeout(() => {\n             requestAnimationFrame(animate);\n           }, delay);\n         }\n       } else {\n         requestAnimationFrame(animate);\n       }\n     };\n     const observer = new IntersectionObserver((entries) => {\n       let isVisible = entries[0].isIntersecting;\n       animationRunning = isVisible; // 标志变量更新\n       if(animationRunning){\n         delay_init = i===0 ? 600 : 20;\n         setTimeout(() => {\n           if(i===0){\n             explanation.innerHTML = ai_str.charAt(0);\n           }\n           requestAnimationFrame(animate);\n         }, delay_init);\n       }\n     }, { threshold: 0 });\n     observer.observe(post_ai);\n   }\n\n```\n\n添加CSS，颜色变量F12自取\n\n```css\n.post-ai{\n    background: var(--ai-post-bg);\n    border-radius: 12px;\n    padding: 12px 16px;\n    line-height: 1.3;\n    border: var(--ai-border);\n    margin-top: 10px;\n    margin-bottom: 6px;\n}\n.ai-title{\n    display: flex;\n    color: var(--font-color);\n    border-radius: 8px;\n    align-items: center;\n    padding: 0 5px;\n}\n.ai-title i{\n    font-weight: 800;\n}\n.ai-title-text{\n    font-weight: bold;\n    margin-left: 8px;\n}\n.ai-tag{\n    font-size: 12px;\n    background-color: var(--ai-tag-bg);\n    color: rgba(255,255,255,0.9);\n    border-radius: 4px;\n    margin-left: auto;\n    line-height: 1;\n    padding: 4px 5px;\n}\n.ai-explanation{\n    margin-top: 11px;\n    font-size: 15.5px;\n    line-height: 1.4;\n}\n.ai-cursor{\n    display: inline-block;\n    width: 7px;\n    background: #333;\n    height: 16px;\n    margin-bottom: -2px;\n    opacity: 0.95;\n    margin-left: 3px;\n    transition: all 0.3s;\n    -webkit-transition: all 0.3s;\n    -moz-transition: all 0.3s;\n    -ms-transition: all 0.3s;\n    -o-transition: all 0.3s;\n}\n[data-theme=dark]\n.ai-cursor{\n    background: rgb(255, 255, 255, 0.9);\n}\n\n```\n\n# 后续\n暂无\n\n","tags":["Butterfly","Hexo","ChatGPT"],"categories":["Hexo"]},{"title":"JavaScript—DOM案例","url":"/article/b0cb9f85.html","content":"\n# 搜索框下拉栏\n\n<div id=\"search-sandbox\"></div>\n\n```html\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        ul{\n            list-style: none;\n        }\n        .search-box{\n            position: relative;\n            width: 200px;\n            margin: 20px;\n            border-radius: 6px;\n        }\n        .search-box input{\n            width: 100%;\n            height: 40px;\n            font-size: 16px;\n            line-height: 100%;\n            border: 1px solid #65a8e2;\n            outline: none;\n            padding: 0 6px;\n            border-radius: 6px;\n            transition: all 0.3s;\n        }\n        .result-list{\n            width: 100%;\n            position: absolute;\n            top: 40px;\n            border: 1px solid #65a8e2;\n            height: auto;\n            border-top: 0;\n            background: rgba(200, 236, 243, 0.7);\n            border-radius: 0 0 6px 6px;\n            display: none;\n        }\n        .result-list li{\n            height: auto;\n        }\n        .result-list a{\n            transition: all 0.3s;\n            text-decoration: none;\n            color: #363636;\n            padding: 5px 10px;\n            display: block;\n            font-size: 14px;\n        }\n        .result-list a:hover{\n            background-color: rgba(210, 210, 210, 0.9);\n        }\n    </style>\n</head>\n<body>\n    <div class=\"search-box\">\n        <input type=\"search\" placeholder=\"输入搜索内容\">\n        <ul class=\"result-list\">\n            <li><a href=\"#\">搜索词1</a></li>\n            <li><a href=\"#\">搜索词2</a></li>\n            <li><a href=\"#\">搜索词3</a></li>\n            <li><a href=\"#\">搜索词4</a></li>\n            <li><a href=\"#\">搜索词5</a></li>\n            <li><a href=\"#\">搜索词6</a></li>\n        </ul>\n    </div>\n    <script>\n        const input = document.querySelector('input');\n        const list = document.querySelector('.result-list');\n        input.addEventListener('focus',()=>{\n            list.style.display = \"block\";\n            input.style.borderRadius = '6px 6px 0 0'\n        });\n        input.addEventListener('blur',()=>{\n            list.style.display = \"none\";\n            input.style.borderRadius = '6px'\n        });\n    </script>\n</body>\n</html>\n\n```\n\n# 评论发布、字数统计\n\n<div id=\"input-count-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            box-sizing: border-box;\n        }\n\n        .comment-box {\n            display: flex;\n            width: 500px;\n            position: relative;\n            transition: all 0.3s;\n        }\n\n        .comment-avatar {\n            border-radius: 50%;\n            width: 50px;\n            height: 50px;\n            background: url('https://cdn.chuckle.top/img/head.webp') no-repeat center / cover;\n            margin-right: 15px;\n        }\n\n        #comment-tx {\n            outline: none;\n            border-color: transparent;\n            resize: none;\n            background: #f5f5f5;\n            border-radius: 4px;\n            flex: 1;\n            padding: 10px;\n            transition: all 0.3s;\n            font-size: 12px;\n            height: 60px;\n        }\n\n        #comment-tx:focus {\n            border-color: #e4e4e4;\n            background: #fff;\n            height: 85px;\n        }\n\n        .comment-box button {\n            background: #00aeec;\n            color: #fff;\n            border: none;\n            border-radius: 4px;\n            margin-left: 10px;\n            width: 70px;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        .comment-count {\n            width: 500px;\n            height: auto;\n            display: flex;\n            justify-content: flex-end;\n        }\n\n        .comment-count span {\n            margin-right: 80px;\n            color: #999;\n            margin-top: 5px;\n            transition: all 0.3s;\n            opacity: 0;\n        }\n\n        .content-list {\n            display: flex;\n            width: 500px;\n            position: relative;\n            transition: all 0.3s;\n            flex-direction: column;\n            flex-wrap: nowrap;\n        }\n\n        .content-item {\n            display: flex;\n            border-bottom: 1px solid #e4e4e4;\n            padding-bottom: 10px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-items: flex-start;\n            margin-bottom: 15px;\n        }\n\n        .content-avatar {\n            border-radius: 50%;\n            width: 50px;\n            height: 50px;\n            background: url('https://cdn.chuckle.top/img/head.webp') no-repeat center / cover;\n            margin-right: 15px;\n        }\n\n        .content-warp {\n            width: calc(100% - 65px);\n            padding-right: 8px;\n        }\n\n        .content-name {\n            font-size: 16px;\n            margin-bottom: 6px;\n        }\n\n        .content-comment {\n            font-size: 18px;\n            white-space: normal;\n            word-break: break-all;\n            word-wrap: break-word;\n            text-overflow: ellipsis;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"comment-box\">\n        <div class=\"comment-avatar\"></div>\n        <textarea id=\"comment-tx\" placeholder=\"发一条友善的评论，回车发布评论\" maxlength=\"200\"></textarea>\n        <button>发布</button>\n    </div>\n    <div class=\"comment-count\">\n        <span>0/200字</span>\n    </div>\n    <div class=\"content-list\">\n        <div class=\"content-item\">\n            <div class=\"content-avatar\"></div>\n            <div class=\"content-warp\">\n                <div class=\"content-name\">chuckle</div>\n                <div class=\"content-comment\">评论一</div>\n            </div>\n        </div>\n        <div class=\"content-item\">\n            <div class=\"content-avatar\"></div>\n            <div class=\"content-warp\">\n                <div class=\"content-name\">chuckle</div>\n                <div class=\"content-comment\">22222222222222222222222222222222222222222222222222222222222222222222222222\n                </div>\n            </div>\n        </div>\n    </div>\n    <script>\n        // 评论输入框\n        const count = document.querySelector('.comment-count span');\n        const tx = document.querySelector('#comment-tx');\n        tx.addEventListener('focus', () => {\n            count.style.opacity = 1;\n        });\n        tx.addEventListener('blur', () => {\n            count.style.opacity = 0;\n        });\n        tx.addEventListener('input', () => {\n            count.innerHTML = `${tx.value.length}/200字`\n        });\n        // 评论展示\n        const contentList = document.querySelector('.content-list');\n        function applyComment() {\n            let comment = tx.value;\n            let html = `<div class=\"content-item\">\n                <div class=\"content-avatar\"></div>\n                <div class=\"content-warp\">\n                    <div class=\"content-name\">chuckle</div>\n                    <div class=\"content-comment\">${comment}</div>\n                </div>\n            </div>`;\n            contentList.insertAdjacentHTML('afterbegin', html);\n        }\n        tx.addEventListener('keyup', (e) => {\n            if (e.key == 'Enter') {\n                if (tx.value.trim()) {\n                    applyComment();\n                }\n                tx.value = '';\n                count.innerHTML = `${tx.value.length}/200字`\n            }\n        })\n        const button = document.querySelector('.comment-box button');\n        button.addEventListener('click', () => {\n            if (tx.value.trim()) {\n                applyComment();\n            }\n            tx.value = '';\n            count.innerHTML = `${tx.value.length}/200字`\n        })\n    </script>\n</body>\n</html>\n\n```\n\n# 轮播图\n当然还是直接用插件方便[swiper](https://www.swiper.com.cn/)\n\n<div id=\"rotBox-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        .rot-box {\n            max-width: 560px;\n            height: 400px;\n            overflow: hidden;\n            border-radius: 12px;\n            box-shadow: 0 3px 8px 6px rgba(7, 17, 27, 0.05);\n            margin: 10px;\n        }\n\n        .rot-img {\n            width: 100%;\n            height: 80%;\n            display: flex;\n            flex-direction: row;\n            flex-wrap: wrap;\n            justify-content: center;\n            position: relative;\n        }\n\n        .rot-img img {\n            width: 100%;\n            height: 100%;\n            object-fit: cover;\n        }\n\n        .rot-footer {\n            height: 20%;\n            background-color: rgb(100, 67, 68);\n            padding: 12px 12px 0 12px;\n            position: relative;\n        }\n\n        .rot-toggle {\n            position: absolute;\n            right: 10px;\n            top: 15px;\n            display: flex;\n        }\n\n        .rot-toggle button {\n            margin-right: 12px;\n            width: 28px;\n            height: 28px;\n            appearance: none;\n            border: none;\n            background: rgba(255, 255, 255, 0.1);\n            color: #fff;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        .rot-toggle button:hover {\n            background: rgba(255, 255, 255, 0.2);\n        }\n\n        .rot-title {\n            margin: 0;\n            color: #fff;\n            font-size: 18px;\n            margin-bottom: 10px;\n            margin-left: 10px;\n        }\n\n        ul.rot-select {\n            margin: 0;\n            padding: 0;\n            list-style: none;\n            display: flex;\n            align-items: center;\n            margin-left: 10px;\n            height: 12px;\n        }\n\n        ul.rot-select li {\n            width: 8px;\n            height: 8px;\n            margin: 4px;\n            border-radius: 50%;\n            background: #fff;\n            opacity: 0.4;\n            cursor: pointer;\n            transition: all 0.3s;\n        }\n\n        ul.rot-select li.active {\n            width: 12px;\n            height: 12px;\n            opacity: 1;\n        }\n        @media screen and (max-width:500px) {\n            .rot-box {\n                height: 320px;\n            }\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"rot-box\">\n        <div class=\"rot-img\">\n            <img src=\"https://cdn.chuckle.top/images/41-1.webp\">\n        </div>\n        <div class=\"rot-footer\">\n            <div class=\"rot-title\">标题零</div>\n            <ul class=\"rot-select\">\n                <li class=\"active\"></li>\n            </ul>\n            <div class=\"rot-toggle\">\n                <button class=\"rot-prev\">&lt;</button>\n                <button class=\"rot-next\">&gt;</button>\n            </div>\n        </div>\n    </div>\n    <script>\n        const rotDate = [\n            {\n                url: 'https://cdn.chuckle.top/images/43-1.webp',\n                title: '标题一'\n            },\n            {\n                url: 'https://cdn.chuckle.top/images/42-1.webp',\n                title: '标题二'\n            },\n            {\n                url: 'https://cdn.chuckle.top/images/41-1.webp',\n                title: '标题三'\n            },\n            {\n                url: 'https://cdn.chuckle.top/images/38-1.webp',\n                title: '标题四'\n            },\n            {\n                url: 'https://cdn.chuckle.top/images/39-1.webp',\n                title: '标题五'\n            },\n        ];\n        //生成[0,arr长度)的随机整数\n        function getRandom(arr) {\n            return parseInt(Math.random() * arr.length);\n        }\n        const rotSelect = document.querySelector('.rot-select');\n        // 数组中有多少对象加几个li\n        rotSelect.innerHTML = '';// 先清空ul的内容\n        for (let i = 0; i < rotDate.length; i++) {\n            rotSelect.innerHTML += '<li></li>';\n        }\n        //让第一个li变成小白点\n        document.querySelector('.rot-select li:first-child').classList.toggle('active');\n        // 一开始随机选一张\n        // 获取要操作的元素\n        const img = document.querySelector('.rot-img img');\n        const title = document.querySelector('.rot-title');\n        const rot_li = document.querySelectorAll('.rot-select li');\n        // 数据数组长度\n        const dateLength = rotDate.length;\n        // 轮播展示序号，默认第一个\n        var num = 0;\n        // 轮播的对象,默认第一个\n        var rot = rotDate[num];\n        // 修改轮播容器的内容\n        function applyDate() {\n            //换标题和图片\n            rot = rotDate[num];\n            img.src = rot.url;\n            title.innerHTML = rot.title;\n            //移除之前的小白点，给当前li添加小白点\n            if (document.querySelector('.rot-select .active')) {\n                document.querySelector('.rot-select .active').classList.remove('active');\n            }\n            rot_li[num].classList.toggle('active');\n        }\n        // 随机展示一个\n        function ranDate(){\n            var random = getRandom(rotDate);\n            rot = rotDate[random];\n            num = random;\n            applyDate();\n        }\n        // 上一张\n        function prevDate() {\n            num > 0 ? --num : num = dateLength - 1;\n            applyDate();\n        }\n        // 下一张\n        function nextDate() {\n            //控制下一张是哪个\n            num = ++num % dateLength;\n            applyDate();\n        }\n        //获取两个按钮\n        const rotPrev = document.querySelector('.rot-prev');\n        const rotNext = document.querySelector('.rot-next');\n        //注册事件\n        rotPrev.addEventListener('click', () => {\n            prevDate();\n        })\n        rotNext.addEventListener('click', () => {\n            nextDate();\n        })\n        // 点击小圆点切换展示\n        rot_li.forEach((item, index, arr) => {\n            item.addEventListener('click', () => {\n                //让轮播展示序号变为当前点击的li的序号\n                num = index;\n                applyDate();\n            });\n        });\n        // 鼠标悬停停止轮播\n        const rotBox = document.querySelector('.rot-box');\n        rotBox.addEventListener('mouseenter',()=>{\n            clearInterval(itv);\n            console.log('暂停轮播');\n        });\n        // 鼠标移出恢复轮播\n        rotBox.addEventListener('mouseleave',()=>{\n            //未确保不重复定时，先清除一次\n            clearInterval(itv);\n            itv = setInterval(nextDate, 1000);\n            console.log('恢复轮播');\n        });\n        // 一开始随机展示一个，注释掉则默认展示第一个\n        //ranDate();\n        // 定时器轮播\n        var itv = setInterval(nextDate, 1000);\n        \n    </script>\n</body>\n</html>\n\n```\n\n# tab切换\n**1、for循环注册鼠标悬停版：**\n\n<div id=\"tab-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        .tab-box {\n            width: 500px;\n            border-radius: 6px;\n            overflow: hidden;\n        }\n\n        .tab-nav {\n            width: 100%;\n            height: 40px;\n            display: flex;\n            background: rgb(233, 233, 233);\n            justify-content: center;\n            border-bottom: 1px solid #333;\n        }\n\n        .tab-nav ul {\n            list-style: none;\n            display: flex;\n            align-items: flex-end;\n        }\n\n        .tab-nav ul li {\n            margin: 0 5px;\n            padding: 2px 15px 0;\n            font-size: 18px;\n            border-radius: 6px 6px 0 0;\n            transition: all 0.3s;\n            border-bottom: 1px solid #333;\n            margin-bottom: -1px;\n        }\n        .tab-nav ul li.active {\n            background: rgb(220, 220, 220);\n            border-bottom: 1px solid rgb(220, 220, 220);\n        }\n        .tab-nav ul li a {\n            text-decoration: none;\n            color: #333;\n            height: 30px;\n            display: block;\n        }\n\n        .tab-content {\n            width: 100%;\n            height: 100px;\n            background: rgb(220, 220, 220);\n        }\n        .tab-item{\n            display: none;\n        }\n        .tab-item.active{\n            display: block;\n            text-align: center;\n            padding: 10px;\n            font-size: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <ul>\n                <li class=\"active\"><a href=\"javascript:;\">栏1</a></li>\n                <li><a href=\"javascript:;\">栏2</a></li>\n                <li><a href=\"javascript:;\">栏3</a></li>\n                <li><a href=\"javascript:;\">栏4</a></li>\n                <li><a href=\"javascript:;\">栏5</a></li>\n            </ul>\n        </div>\n        <div class=\"tab-content\">\n            <div class=\"tab-item active\">项目一</div>\n            <div class=\"tab-item\">项目二</div>\n            <div class=\"tab-item\">项目三</div>\n            <div class=\"tab-item\">项目四</div>\n            <div class=\"tab-item\">项目五</div>\n        </div>\n    </div>\n    <script>\n        const tabNav = document.querySelectorAll('.tab-nav ul li');\n        const tabItem = document.querySelectorAll('.tab-item');\n        tabNav.forEach((item,index)=>{\n            item.addEventListener('mouseenter',()=>{\n                document.querySelector('.tab-nav .active').classList.remove('active');\n                document.querySelector('.tab-content .active').classList.remove('active');\n                item.classList.add('active');\n                tabItem[index].classList.add('active');\n            });\n        });\n    </script>\n</body>\n<div id=\"tab-sandbox\"></div>\n</html>\n\n```\n\n**2、事件委托鼠标点击版：**\n\n<div id=\"tab2-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        .tab-box {\n            width: 500px;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n        }\n\n        .tab-nav {\n            width: 100%;\n            height: 40px;\n            display: flex;\n            background: rgb(233, 233, 233);\n            justify-content: center;\n            border-bottom: 1px solid #333;\n        }\n\n        .tab-nav ul {\n            list-style: none;\n            display: flex;\n            align-items: flex-end;\n        }\n\n        .tab-nav ul li {\n            margin: 0 5px;\n            font-size: 18px;\n            border-bottom: 1px solid transparent;\n            margin-bottom: -1px;\n        }\n\n        .tab-nav ul li a.active {\n            background: rgb(220, 220, 220);\n            border-bottom: 1px solid rgb(220, 220, 220);\n        }\n\n        .tab-nav ul li a {\n            text-decoration: none;\n            color: #333;\n            height: 33px;\n            display: block;\n            padding: 2px 15px;\n            border-radius: 6px 6px 0 0;\n            transition: all 0.3s;\n        }\n\n        .tab-content {\n            width: 100%;\n            height: 100px;\n            background: rgb(220, 220, 220);\n        }\n\n        .tab-item {\n            display: none;\n        }\n\n        .tab-item.active {\n            display: block;\n            text-align: center;\n            padding: 10px;\n            font-size: 20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <ul>\n                <li><a href=\"javascript:;\" data-id=\"0\" class=\"active\">栏1</a></li>\n                <li><a href=\"javascript:;\" data-id=\"1\">栏2</a></li>\n                <li><a href=\"javascript:;\" data-id=\"2\">栏3</a></li>\n                <li><a href=\"javascript:;\" data-id=\"3\">栏4</a></li>\n                <li><a href=\"javascript:;\" data-id=\"4\">栏5</a></li>\n            </ul>\n        </div>\n        <div class=\"tab-content\">\n            <div class=\"tab-item active\">项目一</div>\n            <div class=\"tab-item\">项目二</div>\n            <div class=\"tab-item\">项目三</div>\n            <div class=\"tab-item\">项目四</div>\n            <div class=\"tab-item\">项目五</div>\n        </div>\n    </div>\n    <script>\n        const tabNav = document.querySelector('.tab-nav ul');\n        const tabItem = document.querySelectorAll('.tab-item');\n        //利用事件委托减少注册\n        tabNav.addEventListener('click', (e) => {\n            let tag = e.target.tagName;\n            if (tag === 'A') {\n                document.querySelector('.tab-nav .active').classList.remove('active');\n                document.querySelector('.tab-content .active').classList.remove('active');\n                e.target.classList.add('active');\n                tabItem[e.target.dataset.id].classList.add('active')\n            }\n        });\n    </script>\n</body>\n\n</html>\n\n```\n\n# 表单全选反选\n\n<div id=\"input-check-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        table {\n            border-collapse: collapse;\n            border-spacing: 0;\n            border: 1px solid #c0c0c0;\n            width: 500px;\n            text-align: center;\n        }\n\n        th {\n            background-color: rgb(40, 170, 220);\n            font: bold 16px;\n            color: #fff;\n            height: 22px;\n        }\n        td {\n            border: 1px solid #d0d0d0;\n            color: #363636;\n            padding: 6px 10px;\n            background: #f9f9f9;\n        }\n        tr td:not(:first-child){\n            min-width: 50px;\n        }\n        tr th:first-child{\n            width: 70px;\n        }\n    </style>\n</head>\n\n<body>\n    <table>\n        <tr>\n            <th>\n                <input type=\"checkbox\" id=\"check-all\">\n                <span>全选</span>\n            </th>\n            <th>书名</th>\n            <th>作者</th>\n            <th>价格</th>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>毛泽东选集</td>\n            <td>毛泽东</td>\n            <td>56</td>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>资本论</td>\n            <td>马克思</td>\n            <td>129</td>\n        </tr>\n        <tr>\n            <td>\n                <input type=\"checkbox\" class=\"check-one\">\n            </td>\n            <td>三体</td>\n            <td>刘慈欣</td>\n            <td>46</td>\n        </tr>\n    </table>\n    <script>\n        const checkAll = document.querySelector('#check-all');\n        const checks = document.querySelectorAll('.check-one');\n        checkAll.addEventListener('click',()=>{\n            checks.forEach((item)=>{\n                item.checked = checkAll.checked;\n            });\n        });\n        checks.forEach((item)=>{\n            item.addEventListener('click',()=>{\n                checkAll.checked = document.querySelectorAll('.check-one:checked').length === checks.length;\n            })\n        })\n    </script>\n</body>\n\n</html>\n\n```\n\n# 导航栏、电梯导航、哔哩tab\n\n<div id=\"nav-bl-tab-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n        body {\n            padding-bottom: 500px;\n        }\n\n        .tab-box {\n            width: 500px;\n            height: auto;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n        }\n\n        .tab-nav {\n            display: flex;\n            list-style: none;\n            border-bottom: 1px solid #333;\n            background: rgb(233, 233, 233);\n            height: 40px;\n            flex-direction: row;\n            flex-wrap: nowrap;\n            justify-content: center;\n            align-items: center;\n            position: relative;\n        }\n\n        .tab-nav a {\n            margin: 5px;\n            padding: 0 10px;\n            text-decoration: none;\n            color: #000;\n            height: 40px;\n            line-height: 40px;\n        }\n\n        .tab-nav a.active {\n            color: rgb(23, 180, 215);\n        }\n\n        .tab-bar {\n            position: absolute;\n            width: 40px;\n            height: 3px;\n            background: rgb(23, 180, 215);\n            bottom: -1px;\n            transition: all 0.3s;\n        }\n\n        .item-box {\n            background: rgb(220, 220, 220);\n        }\n\n        .item {\n            text-align: center;\n            padding: 10px;\n            display: none;\n        }\n\n        .item.active {\n            display: block;\n            height: 100px;\n        }\n\n        /* 导航栏 */\n        #nav {\n            width: 100%;\n            height: 50px;\n            text-align: center;\n            line-height: 50px;\n            background: rgba(120, 182, 191, 0.5);\n            font-size: 20px;\n            position: fixed;\n            top: -50px;\n            transition: all 0.3s;\n            z-index: 9999;\n        }\n\n        .box {\n            margin-top: 10px;\n            width: 200px;\n            height: 200px;\n            background: rgb(144, 193, 230);\n            margin-bottom: 200px;\n            border-radius: 6px;\n        }\n\n        /* 电梯导航 */\n        .ele-nav {\n            position: fixed;\n            bottom: 20%;\n            background: rgb(233, 233, 233);\n            right: 10%;\n            border: 1px solid #333;\n            border-bottom: 0;\n            border-radius: 6px;\n            overflow: hidden;\n            transition: all 0.3s;\n            opacity: 0;\n            z-index: -99;\n        }\n        .ele-item.active{\n            color: rgb(23, 180, 215);\n            background: rgb(252, 200, 200);\n        }\n        .ele-item,\n        .back-top {\n            padding: 10px;\n            border-bottom: 1px solid #333;\n            user-select: none;\n            transition: all 0.3s;\n        }\n        .ele-item:hover,\n        .back-top:hover{\n            color: rgb(23, 180, 215);\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"nav\">导航栏</div>\n    <div class=\"tab-box\">\n        <div class=\"tab-nav\">\n            <a href=\"javascript:;\" class=\"active\">栏1</a>\n            <a href=\"javascript:;\">栏2</a>\n            <a href=\"javascript:;\">栏3</a>\n            <a href=\"javascript:;\">栏4</a>\n            <a href=\"javascript:;\">栏114514</a>\n            <div class=\"tab-bar\"></div>\n        </div>\n\n        <div class=\"item-box\">\n            <div class=\"item active\">项目一</div>\n            <div class=\"item\">项目二</div>\n            <div class=\"item\">项目三</div>\n            <div class=\"item\">项目四</div>\n            <div class=\"item\">项目114514</div>\n        </div>\n    </div>\n    <div class=\"ele-nav\">\n        <div class=\"ele-item\">去第一个</div>\n        <div class=\"ele-item\">去第二个</div>\n        <div class=\"ele-item\">去第三个</div>\n        <div class=\"ele-item\">去第四个</div>\n        <div class=\"back-top\">回到顶部</div>\n    </div>\n    <div class=\"box\">第一个盒子,滚动到此(往上55像素)显示导航栏和电梯导航</div>\n    <div class=\"box\">第二个盒子</div>\n    <div class=\"box\">第三个盒子</div>\n    <div class=\"box\">第四个盒子</div>\n    <script>\n        //网页导航栏,还有电梯导航的显示和隐藏\n        const nav = document.querySelector('#nav');\n        const box = document.querySelectorAll('.box');\n        const ele_nav = document.querySelector('.ele-nav');\n        window.addEventListener('scroll', () => {\n            let n = window.scrollY;\n            let m = box[0].offsetTop;\n            let tf = n >= m-55;//减去55像素，不让电梯导航点击去第一个后消失\n            nav.style.top = tf ? '0px' : '-50px';\n            ele_nav.style.opacity = tf ? '1' : '0';\n            ele_nav.style.zIndex = tf ? '99' : '-99';\n        });\n        //bilibili导航\n        const bar = document.querySelector('.tab-bar');\n        const tabNav = document.querySelector('.tab-nav');\n        const tab_a = document.querySelectorAll('.tab-nav a');\n        const item = document.querySelectorAll('.item-box .item');\n        //给每个a依次添加data-id\n        tab_a.forEach((item, index) => {\n            item.dataset.id = index;\n        });\n        //将a的点击事件委托给tab-nav\n        tabNav.addEventListener('click', (e) => {\n            let tag = e.target.tagName;\n            if (tag === 'A') {\n                //tab导航切换\n                document.querySelector('.tab-nav a.active').classList.remove('active');\n                document.querySelector('.item.active').classList.remove('active');\n                e.target.classList.add('active');\n                item[e.target.dataset.id].classList.add('active');\n                //bar移动和动态改变宽度\n                bar.style.width = `${e.target.offsetWidth}px`;\n                bar.style.left = `${e.target.offsetLeft}px`;\n            }\n        });\n        tab_a[0].click();//先初始化一次bar的位置\n        //电梯导航\n        //给每个电梯导航依次添加data-name\n        document.querySelectorAll('.ele-item').forEach((item, index) => {\n            item.dataset.name = `b${index+1}`;\n        });\n        //给每个box依次添加电梯导航对应的自定义属性的class\n        box.forEach((item, index) => {\n            item.classList.add(`b${index+1}`);\n        });\n        //移除ele的active\n        function reactive(){\n            let ele_active = document.querySelector('.ele-item.active');\n            if(ele_active){\n                //如果有，先清除\n                ele_active.classList.remove('active');\n            }\n        }\n        //去指定盒子,事件委托\n        ele_nav.addEventListener('click', (e) => {\n            let cname = e.target.className;\n            if (cname === 'ele-item'||cname === 'ele-item active') {\n                reactive();\n                //给点击的item添加active\n                e.target.classList.add('active');\n                //去对应的盒子\n                //通过自定义属性获取对应的盒子class名\n                let box = document.querySelector(`.${e.target.dataset.name}`);\n                // 其实监听滚动后，没必要再手动去给active，但想点击后导航立刻变色的话，可以取消下面的注释\n                // //先立刻移除页面滚动监听\n                // window.removeEventListener('scroll', scroll_light_ele);\n                // //一秒后重新监听\n                // setTimeout(() => {\n                //     //防止重复注册，先移除页面滚动监听\n                //     window.removeEventListener('scroll', scroll_light_ele);\n                //     window.addEventListener('scroll', scroll_light_ele);\n                // }, 800);\n                //更新当前页面在哪个盒子的范围位置\n                box_num = e.target.dataset.name.replace(/[^\\d]/g, \" \");\n                //滚动到指定位置\n                window.scrollTo({\n                    top: box.offsetTop - 50,\n                    left: 0,\n                    behavior: 'smooth'\n                });\n            }\n            //点击返回顶部\n            if (cname === 'back-top') {\n                reactive();\n                window.scrollTo({\n                    top: 0,\n                    left: 0,\n                    behavior: 'smooth'\n                });\n                box_num = -1;\n            }\n        });\n        //获取盒子的高度数组减去55px\n        const box_top_arr = Array.from(box).map((item)=>{\n            return item.offsetTop-55;\n        })\n        var box_num = -1;//记录当前在哪个盒子范围内\n        //页面滚动到对应box让电梯导航对应导航高亮\n        function scroll_light_ele(){\n            let n = window.scrollY;\n            let num = box_top_arr.reduce((prev, item, index)=>{\n                return n >= item ? index : prev;\n            },-1);\n            if(num === box_num){\n                //说明还在这个盒子范围内，直接返回\n                return;\n            }else{\n                //更新位置\n                box_num = num;\n            }\n            if(num > -1){\n                reactive();\n                document.querySelector(`[data-name=\"b${num+1}\"]`).classList.add('active');\n            }else{\n                box_num = -1;\n            }\n        }\n        window.addEventListener('scroll', scroll_light_ele);\n    </script>\n</body>\n\n</html>\n\n```\n\n# 倒计时\n\n<div id=\"time-count-sandbox\"></div>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            padding: 0;\n            margin: 0;\n            box-sizing: border-box;\n        }\n\n        .time-box {\n            padding: 20px 15px;\n            background: rgb(30, 171, 210);\n            width: fit-content;\n            border-radius: 6px;\n            overflow: hidden;\n            margin: 10px;\n            font-size: 18px;\n        }\n\n        .time-now {\n            width: 100%;\n            text-align: center;\n        }\n\n        .time-title {\n            font-size: 26px;\n            text-align: center;\n            width: 100%;\n            margin: 6px 0;\n        }\n\n        .clock {\n            display: flex;\n            width: 100%;\n            justify-content: center;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-content: center;\n            margin: 10px 0;\n        }\n        .hour,.minutes,.second{\n            font-size: 20px;\n            margin: 2px;\n            padding: 2px 3px;\n            border-radius: 4px;\n            background: rgba(36, 36, 36, 0.65);\n            color: #fff;\n        }\n        .colon{\n            font-size: 20px;\n            font-weight: bolder;\n            padding: 2px;\n        }\n        .target{\n            width: 100%;\n            text-align: center;\n            margin: 6px 0 0;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"time-box\">\n        <div class=\"time-now\">今天是1970年1月1日</div>\n        <div class=\"time-title\">倒计时</div>\n        <div class=\"clock\">\n            <div class=\"hour\">00</div>\n            <div class=\"colon\">:</div>\n            <div class=\"minutes\">00</div>\n            <div class=\"colon\">:</div>\n            <div class=\"second\">00</div>\n        </div>\n        <div class=\"target\">目标时间00:00:00</div>\n    </div>\n\n    <script>\n        const hour = document.querySelector('.hour');\n        const minutes = document.querySelector('.minutes');\n        const second = document.querySelector('.second');\n        const time_now = document.querySelector('.time-now');\n        const target = document.querySelector('.target');\n        const now = new Date();\n        const time = '18:00:00';\n        const targetTime = `${now.getFullYear()}-${now.getMonth() + 1}-${now.getDate()} 18:00:00`;\n        const last = new Date(targetTime);\n        let count = (last.getTime() - now.getTime()) / 1000;\n        function countDown() {\n            let h = parseInt(count / 60 / 60 % 24);\n            h = h < 10 ? '0' + h : h;\n            let m = parseInt(count / 60 % 60);\n            m = m < 10 ? '0' + m : m;\n            let s = parseInt(count % 60);\n            s = s < 10 ? '0' + s : s;\n            hour.innerHTML = h;\n            minutes.innerHTML = m;\n            second.innerHTML = s;\n            count--;\n            if (count == 0) {\n                count = 0;\n            }\n        }\n        time_now.innerHTML = `今天是${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日`;\n        target.innerHTML = `目标时间${time}`\n        countDown();\n        setInterval(countDown, 1000);\n    </script>\n</body>\n\n</html>\n\n```\n\n# 学生信息表\n<a href=\"/dom/stu-info.html\" target=\"_blank\">学生信息表</a>\n\n本地存储，数据驱动，刷新不丢失\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        a {\n            text-decoration: none;\n            color: rgb(226, 14, 14);\n        }\n\n        .info-box {\n            width: 800px;\n            margin: 0 auto;\n            position: relative;\n        }\n\n        h1 {\n            text-align: center;\n            margin: 20px;\n            user-select: none;\n        }\n\n        .info {\n            width: 100%;\n            text-align: center;\n            margin: 40px 0;\n        }\n\n        .ipt-name {\n            width: fit-content;\n            display: inline-block;\n            line-height: 25px;\n            font-size: 16px;\n        }\n\n        .info input,\n        .info select {\n            width: 70px;\n            outline: none;\n            border-radius: 5px;\n            border: 1px solid #b8daff;\n            height: 25px;\n            padding: 0 5px;\n            margin: 0 15px 0 2px;\n        }\n\n        input.sname {\n            width: 80px;\n        }\n\n        input.age {\n            width: 40px;\n        }\n\n        .info button {\n            width: 60px;\n            height: 25px;\n            border-radius: 5px;\n            cursor: pointer;\n            background: rgb(82, 191, 231);\n            outline: none;\n            border: 1px solid rgb(98, 98, 98);\n            color: #fff;\n            font-size: 15px;\n        }\n\n        table {\n            margin: 0 auto;\n            width: 100%;\n            padding: 0 20px;\n            color: #363636;\n            border-collapse: collapse;\n            border-spacing: 0;\n        }\n\n        th {\n            padding: 5px 10px;\n            background: #cfe5ff;\n            font-size: 20px;\n            font-weight: 400;\n        }\n\n        td,\n        th {\n            border: 1px solid #b8daff;\n        }\n\n        td {\n            padding: 5px 10px;\n            text-align: center;\n            font-size: 16px;\n        }\n\n        tbody tr {\n            background: #fff;\n        }\n\n        tbody tr:hover {\n            background: #e1ecf8;\n        }\n        .info-num{\n            right: 10px;\n            width: fit-content;\n            position: absolute;\n            margin-top: -20px;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"info-box\">\n        <h1>新增学生信息</h1>\n        <form class=\"info\" autocomplete=\"off\">\n            <div class=\"ipt-name\">姓名</div>\n            <input type=\"text\" class=\"sname\" name=\"sname\">\n            <div class=\"ipt-name\">年龄</div>\n            <input type=\"text\" class=\"age\" name=\"age\">\n            <div class=\"ipt-name\">性别</div>\n            <select class=\"gender\" name=\"gender\">\n                <option value=\"男\">男</option>\n                <option value=\"女\">女</option>\n            </select>\n            <div class=\"ipt-name\">年级</div>\n            <select class=\"grade\" name=\"grade\">\n                <option value=\"大一\">大一</option>\n                <option value=\"大二\">大二</option>\n                <option value=\"大三\">大三</option>\n                <option value=\"大四\">大四</option>\n            </select>\n            <div class=\"ipt-name\">专业</div>\n            <select class=\"major\" name=\"major\">\n                <option value=\"计科\">计科</option>\n                <option value=\"机械\">机械</option>\n                <option value=\"会计\">会计</option>\n            </select>\n            <button class=\"add-info\">录入</button>\n        </form>\n        <h1>学生信息</h1>\n        <div class=\"info-num\">共有0条数据</div>\n        <table>\n            <thead>\n                <tr>\n                    <th>序号</th>\n                    <th>姓名</th>\n                    <th>年龄</th>\n                    <th>性别</th>\n                    <th>年级</th>\n                    <th>专业</th>\n                    <th>操作</th>\n                </tr>\n            </thead>\n            <tbody></tbody>\n        </table>\n    </div>\n    <script>\n        var arr = [\n            {\n                name: '张三',\n                age: 19,\n                gender: '男',\n                grade: '大一',\n                major: '计科'\n            },\n            {\n                name: '李四',\n                age: 18,\n                gender: '男',\n                grade: '大二',\n                major: '机械'\n            },\n            {\n                name: '李丽',\n                age: 18,\n                gender: '女',\n                grade: '大三',\n                major: '会计'\n            }\n        ];\n        const info = document.querySelector('.info');\n        const items = document.querySelectorAll('.info [name]');\n        const tbody = document.querySelector('tbody');\n        const infoNum = document.querySelector('.info-num');\n        info.addEventListener('submit', (e) => {\n            e.preventDefault();\n            let i = Array.from(items).reduce((prev, item) => {\n                return item.value === '' ? prev : prev += 1;\n            }, 0);\n            console.log(i);\n            if (i != items.length) {\n                return alert('输入内容不能为空');\n            }\n            let obj = {\n                name: info.children[1].value,\n                age: info.children[3].value,\n                gender: info.children[5].value,\n                grade: info.children[7].value,\n                major: info.children[9].value\n            }\n            console.log(obj);\n            //更新数据\n            arr.push(obj);\n            //重置表单\n            info.reset();\n            //信息本地存储\n            localStorage.setItem('info', JSON.stringify(arr));\n            //调用渲染函数\n            render();\n        });\n        function render() {\n            tbody.innerHTML = '';\n            let trArr = arr.map((item, index) => {\n                return `<tr>\n                    <td>${index + 1}</td>\n                    <td>${item.name}</td>\n                    <td>${item.age}</td>\n                    <td>${item.gender}</td>\n                    <td>${item.grade}</td>\n                    <td>${item.major}</td>\n                    <td><a href=\"javascript:\">删除</a></td>\n                </tr>`\n            });\n            tbody.innerHTML = trArr.join('');\n            infoNum.innerHTML = `共有${arr.length}条数据`;\n        }\n        //删除，事件委托\n        tbody.addEventListener('click', (e) => {\n            let target = e.target;\n            if (target.tagName === 'A') {\n                let num = e.target.parentNode.parentNode.firstElementChild.innerHTML\n                //拿到序号，删除一个\n                let tf = confirm(`确认删除第 ${num} 个学生信息吗？`);\n                if (tf) {\n                    arr.splice(num - 1, 1);\n                    localStorage.setItem('info', JSON.stringify(arr));\n                    render();\n                }\n            }\n        });\n        function infoInit() {\n            //先获取本地数据\n            let info = JSON.parse(localStorage.getItem('info'));\n            if (info) {\n                arr = info;\n            }\n            render();\n        }\n        //初始化\n        infoInit();\n    </script>\n</body>\n\n</html>\n\n```\n\n# 注册界面\n\n<a href=\"/dom/reg.html\" target=\"_blank\">注册界面</a>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        input {\n            outline: none;\n        }\n\n        a {\n            text-decoration: none;\n        }\n\n        .reg-box {\n            margin: 0 auto;\n            width: auto;\n            height: auto;\n            background: rgb(244, 242, 242);\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            border-radius: 6px;\n            transform: translate(-50%, -50%);\n            border: 1px solid #e4e4e4;\n        }\n\n        .reg-box .reg-title {\n            width: 100%;\n            text-align: center;\n            margin: 15px 0;\n            font-size: 22px;\n            font-weight: bolder;\n            color: #363636;\n        }\n\n        .reg-form {\n            margin: 10px;\n        }\n\n        .form-item {\n            display: flex;\n            position: relative;\n            width: 300px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            padding-bottom: 25px;\n            justify-content: space-between;\n            letter-spacing: 0.6px;\n        }\n\n        .form-item input {\n            width: 100%;\n            border: 1px solid #e4e4e4;\n            height: 40px;\n            font-size: 16px;\n            padding: 10px 16px;\n            border-radius: 6px;\n        }\n\n        .form-item .msg {\n            position: absolute;\n            line-height: 1;\n            width: 100%;\n            font-size: 12px;\n            color: rgb(255, 79, 126);\n            bottom: 9px;\n            padding-left: 5px;\n        }\n\n        .code-box {\n            display: flex;\n        }\n\n        .form-item [name=\"code\"] {\n            flex-shrink: 1;\n        }\n\n        .form-item a.code {\n            width: fit-content;\n            height: 40px;\n            line-height: 40px;\n            background: rgb(120, 187, 233);\n            text-align: center;\n            border-radius: 6px;\n            color: #fff;\n            margin-left: 10px;\n            padding: 0 10px;\n            flex-shrink: 0;\n            display: block;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .agree-check {\n            margin: 0 auto;\n            width: fit-content;\n        }\n\n        .form-item .agree {\n            width: 20px;\n            height: 20px;\n            cursor: pointer;\n        }\n\n        .form-item .agree:checked {\n            background: #9decbe;\n        }\n\n        .agreement {\n            width: calc(100% - 20px);\n            padding-left: 10px;\n            color: #363636;\n            line-height: 20px;\n            height: 20px;\n        }\n\n        .agreement a {\n            color: #6a9adf;\n        }\n\n        .reg-submit {\n            margin: 0 auto;\n            display: block;\n            width: calc(100% - 40px);\n            height: 40px;\n            border-radius: 8px;\n            outline: none;\n            border: none;\n            background: #9decbe;\n            font-size: 18px;\n            color: #363636;\n            margin-bottom: 15px;\n            transition: all 0.3s;\n            cursor: pointer;\n            user-select: none;\n        }\n\n        .reg-submit:hover {\n            background: #86ebb0;\n        }\n\n        .form-item .see {\n            position: absolute;\n            width: fit-content;\n            height: auto;\n            right: 10px;\n            line-height: 1;\n            cursor: pointer;\n            font-size: 14px;\n            top: 12px;\n            color: #ababab;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .form-item .see:hover {\n            color: #6a9adf;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"reg-box\">\n        <div class=\"reg-title\">新用户注册</div>\n        <form class=\"reg-form\">\n            <div class=\"form-item\">\n                <input name=\"uname\" type=\"text\" placeholder=\"设置用户名\" maxlength=\"12\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n            </div>\n            <div class=\"form-item\">\n                <input name=\"phone\" type=\"text\" placeholder=\"输入手机号\" maxlength=\"11\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n            </div>\n            <div class=\"form-item\">\n                <div class=\"code-box\">\n                    <input name=\"code\" type=\"text\" placeholder=\"输入验证码\" maxlength=\"6\" autocomplete=\"off\">\n                    <div class=\"msg\"></div>\n                    <a href=\"javascript:;\" class=\"code\">发送验证码</a>\n                </div>\n            </div>\n            <div class=\"form-item\">\n                <input name=\"password\" type=\"password\" placeholder=\"输入密码\" maxlength=\"20\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"see\">显示</div>\n            </div>\n            <div class=\"form-item\">\n                <input class=\"password-again\" type=\"password\" placeholder=\"再次输入密码\" maxlength=\"20\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"see\">显示</div>\n            </div>\n            <div class=\"form-item agree-check\">\n                <input type=\"checkbox\" class=\"agree\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"agreement\">已阅读并同意<a href=\"#\">《用户协议》</a></div>\n            </div>\n            <button class=\"reg-submit\">提交</button>\n        </form>\n    </div>\n\n    <script>\n        const code = document.querySelector('.code-box .code');\n        var code_flag = true;//控制点击有没有效果\n        const codeTime = 30;//验证码发送间隔时间，默认30秒\n        //验证码间隔验证的初始化\n        function codeInit() {\n            //如果验证码间隔倒计时还没30秒，就继续倒计时\n            let code_time = localStorage.getItem('code_time');\n            if (code_time) {\n                let time = codeTime - parseInt((new Date().getTime() - code_time) / 1000);\n                //小于0说明间隔已经满足\n                if (time > 0) {\n                    //执行控制验证码间隔函数\n                    code_limit_time(time);\n                }\n            }\n            // 发送短信验证码\n            code.addEventListener('click', () => {\n                if (code_flag) {\n                    //存入点击发送验证码时的时间戳\n                    localStorage.setItem('code_time', new Date().getTime());\n                    code_flag = false;//可以点击\n                    code_limit_time();\n                    //这里就可以去做请求短信接口\n                }\n            });\n        }\n        // 控制验证码发送间隔函数\n        function code_limit_time(i = codeTime) {\n            code.innerHTML = `${i}秒后重新获取`;\n            code.style.pointerEvents = 'none';\n            code.style.background = '#c6c6c6';\n            var stv = setInterval(() => {\n                i--;\n                code.innerHTML = `${i}秒后重新获取`;\n                if (i === 0) {\n                    code_flag = true;\n                    code.innerHTML = `重新获取`;\n                    code.style.pointerEvents = 'auto';\n                    code.style.background = 'rgb(120, 187, 233)';\n                    clearInterval(stv);\n                    //倒计时完成移除时间戳\n                    localStorage.removeItem('code_time');\n                }\n            }, 1000)\n        }\n        //输入框验证函数\n        function input_verification(input, rex, msg) {\n            let div = input.nextElementSibling;\n            if (rex.test(input.value)) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = msg;\n                return false;\n            }\n        }\n\n        // 输入框内容检查\n        const uname = document.querySelector('.form-item input[name=\"uname\"]');\n        const phone = document.querySelector('.form-item input[name=\"phone\"]');\n        const code_input = document.querySelector('.form-item input[name=\"code\"]');\n        const password = document.querySelector('.form-item input[name=\"password\"]');\n        const password_again = document.querySelector('input.password-again');\n        const agree = document.querySelector('.agree-check .agree');\n        //用户名验证\n        function inspect_uname() {\n            return input_verification(uname, /^\\w{4,12}$/g, \"4到12位用户名，只能包含数字、字母、下划线\") ? true : false;\n        }\n        //手机号验证\n        function inspect_phone() {\n            return input_verification(phone, /^1[3-9][0-9]{9}$/g, \"11位手机号\") ? true : false;\n        }\n        //检查验证码是否是6位数字\n        function inspect_code() {\n            return input_verification(code_input, /^\\d{6}$/g, \"6位数字验证码\") ? true : false;\n        }\n        //密码验证，开头必须是字母，6到20位\n        function inspect_password() {\n            return input_verification(password, /^(?=.*[a-z])(?=.*\\d)[a-z\\d]{6,20}$/gi, \"6到20位密码，必须包含数字和字母\") ? true : false;\n        }\n        //验证两次密码输入是否相同\n        function inspect_password_again() {\n            let div = password_again.nextElementSibling;\n            if (password_again.value === password.value) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"两次密码不一致\";\n                return false;\n            }\n        }\n        // 检查协议是否同意\n        function inspect_agree() {\n            let div = agree.nextElementSibling;\n            if (agree.checked) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"请同意协议\";\n                return false;\n            }\n        }\n        //监听各个输入框内容是否改变\n        uname.addEventListener('change', () => {\n            inspect_uname();\n        });\n        phone.addEventListener('change', () => {\n            inspect_phone();\n        });\n        code_input.addEventListener('change', () => {\n            inspect_code();\n        });\n        password.addEventListener('change', () => {\n            inspect_password();\n            if (password_again.value) {\n                inspect_password_again();\n            }\n        });\n        password_again.addEventListener('change', () => {\n            inspect_password_again();\n        });\n        //密码点击查看隐藏\n        const see_psw = document.querySelectorAll('.form-item .see')\n        see_psw.forEach((item, index) => {\n            item.addEventListener('click', () => {\n                let input = item.parentNode.firstElementChild;\n                if (input.type === \"password\") {\n                    item.innerHTML = \"隐藏\";\n                    input.type = \"text\";\n                } else {\n                    item.innerHTML = \"显示\";\n                    input.type = \"password\";\n                }\n            });\n        });\n        //点击提交表单\n        const btn_submit = document.querySelector('.reg-submit');\n        const reg_form = document.querySelector('.reg-form');\n        reg_form.addEventListener('submit', (e) => {\n            //提交前再次把所有输入框检查一遍\n            if (!inspect_uname()) { e.preventDefault(); }\n            if (!inspect_phone()) { e.preventDefault(); }\n            if (!inspect_code()) { e.preventDefault(); }\n            if (!inspect_password()) { e.preventDefault(); }\n            if (!inspect_password_again()) { e.preventDefault(); }\n            if (!inspect_agree()) { e.preventDefault(); }\n        })\n        //初始化函数\n        function regInit() {\n            codeInit();\n        }\n        //执行初始化\n        regInit();\n    </script>\n</body>\n\n</html>\n\n```\n\n# 登陆界面\n\n<a href=\"/dom/login.html\" target=\"_blank\">登录界面</a>\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n            box-sizing: border-box;\n        }\n\n        input {\n            outline: none;\n        }\n\n        a {\n            text-decoration: none;\n        }\n\n        .login-box {\n            margin: 0 auto;\n            width: auto;\n            height: auto;\n            background: rgb(244, 242, 242);\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            border-radius: 6px;\n            transform: translate(-50%, -50%);\n            border: 1px solid #e4e4e4;\n        }\n\n        .login-box .login-title {\n            width: 100%;\n            text-align: center;\n            margin: 12px 0;\n            font-size: 22px;\n            font-weight: bolder;\n            color: #363636;\n        }\n\n        .login-tab {\n            display: flex;\n            width: 100%;\n            justify-content: center;\n            flex-direction: row;\n            flex-wrap: wrap;\n            align-content: center;\n            align-items: center;\n            user-select: none;\n        }\n\n        .login-tab-line {\n            width: 1px;\n            height: 20px;\n            background: rgb(30, 110, 140);\n        }\n\n        .login-tab-item {\n            margin: 0px 10px;\n            transition: all 0.2s;\n        }\n\n        .login-tab-item.active {\n            color: #4b98db;\n        }\n\n        .login-form {\n            margin: 10px;\n        }\n\n        .form-item {\n            display: flex;\n            position: relative;\n            width: 300px;\n            flex-direction: row;\n            flex-wrap: wrap;\n            padding-bottom: 25px;\n            justify-content: space-between;\n            letter-spacing: 0.6px;\n        }\n\n        .form-item input {\n            width: 100%;\n            border: 1px solid #e4e4e4;\n            height: 40px;\n            font-size: 16px;\n            padding: 10px 16px;\n            border-radius: 6px;\n        }\n\n        .form-item .msg {\n            position: absolute;\n            line-height: 1;\n            width: 100%;\n            font-size: 12px;\n            color: rgb(255, 79, 126);\n            bottom: 9px;\n            padding-left: 5px;\n        }\n\n        .code-box {\n            display: flex;\n        }\n\n        .form-item [name=\"code\"] {\n            flex-shrink: 1;\n        }\n\n        .form-item a.code {\n            width: fit-content;\n            height: 40px;\n            line-height: 40px;\n            background: rgb(120, 187, 233);\n            text-align: center;\n            border-radius: 6px;\n            color: #fff;\n            margin-left: 10px;\n            padding: 0 10px;\n            flex-shrink: 0;\n            display: block;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .agree-check {\n            margin: 0 auto;\n            width: fit-content;\n        }\n\n        .form-item .agree {\n            width: 20px;\n            height: 20px;\n            cursor: pointer;\n        }\n\n        .form-item .agree:checked {\n            background: #9decbe;\n        }\n\n        .agreement {\n            width: calc(100% - 20px);\n            padding-left: 10px;\n            color: #363636;\n            line-height: 20px;\n            height: 20px;\n        }\n\n        .agreement a {\n            color: #6a9adf;\n        }\n\n        .login-submit {\n            margin: 0 auto;\n            display: block;\n            width: calc(100% - 40px);\n            height: 40px;\n            border-radius: 8px;\n            outline: none;\n            border: none;\n            background: #9decbe;\n            font-size: 18px;\n            color: #363636;\n            margin-bottom: 15px;\n            transition: all 0.3s;\n            cursor: pointer;\n            user-select: none;\n        }\n\n        .login-submit:hover {\n            background: #86ebb0;\n        }\n\n        .form-item .see {\n            position: absolute;\n            width: fit-content;\n            height: auto;\n            right: 10px;\n            line-height: 1;\n            cursor: pointer;\n            font-size: 14px;\n            top: 12px;\n            color: #ababab;\n            transition: all 0.3s;\n            user-select: none;\n        }\n\n        .form-item .see:hover {\n            color: #6a9adf;\n        }\n\n        .login-form {\n            display: none;\n        }\n\n        .login-form.active {\n            display: block;\n        }\n    </style>\n</head>\n\n<body>\n    <div class=\"login-box\">\n        <div class=\"login-title\">登陆</div>\n        <div class=\"login-tab\">\n            <div class=\"login-tab-item active\" data-id=\"0\">密码登陆</div>\n            <div class=\"login-tab-line\"></div>\n            <div class=\"login-tab-item\" data-id=\"1\">短信登陆</div>\n        </div>\n        <div class=\"form-box\">\n            <form class=\"login-form active\">\n                <div class=\"form-item\">\n                    <input name=\"uname\" type=\"text\" placeholder=\"用户名 / 手机号\" maxlength=\"13\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                </div>\n                <div class=\"form-item\">\n                    <input name=\"password\" type=\"password\" placeholder=\"密码\" maxlength=\"20\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                    <div class=\"see\">显示</div>\n                </div>\n                <button class=\"login-submit\">登录</button>\n            </form>\n            <form class=\"login-form\">\n                <div class=\"form-item\">\n                    <input name=\"phone\" type=\"text\" placeholder=\"输入手机号\" maxlength=\"11\" autocomplete=\"off\" required>\n                    <div class=\"msg\"></div>\n                </div>\n                <div class=\"form-item\">\n                    <div class=\"code-box\">\n                        <input name=\"code\" type=\"text\" placeholder=\"输入验证码\" maxlength=\"6\" autocomplete=\"off\" required>\n                        <div class=\"msg\"></div>\n                        <a href=\"javascript:;\" class=\"code\">发送验证码</a>\n                    </div>\n                </div>\n                <button class=\"login-submit\">登录</button>\n            </form>\n            <div class=\"form-item agree-check\">\n                <input type=\"checkbox\" class=\"agree\" autocomplete=\"off\">\n                <div class=\"msg\"></div>\n                <div class=\"agreement\">已阅读并同意<a href=\"#\">《用户协议》</a></div>\n            </div>\n        </div>\n    </div>\n\n\n    <script>\n        const login_tab = document.querySelector('.login-tab');\n        const login_form = document.querySelectorAll('.login-form');\n        const code = document.querySelector('.code-box .code');\n        const agree = document.querySelector('.agree-check .agree');\n        const uname = document.querySelector('.form-item input[name=\"uname\"]');\n        const phone = document.querySelector('.form-item input[name=\"phone\"]');\n        login_tab.addEventListener('click', (e) => {\n            let class_name = e.target.className;\n            if (class_name === 'login-tab-item') {\n                document.querySelector('.login-tab-item.active').classList.remove('active');\n                e.target.classList.add('active');\n                //切换登录方式清空input\n                document.querySelectorAll('.login-form.active input').forEach((item) => {\n                    item.value = '';\n                })\n                document.querySelector('.login-form.active').classList.remove('active');\n                login_form[e.target.dataset.id].classList.add('active');\n            }\n        });\n        //短信模块\n        var code_flag = true;//控制点击有没有效果\n        const codeTime = 30;//验证码发送间隔时间，默认30秒\n        function codeClick() {\n            if (code_flag) {\n                //存入点击发送验证码时的时间戳\n                localStorage.setItem('code_time', new Date().getTime());\n                code_flag = false;//可以点击\n                code_limit_time();\n                //这里就可以去做请求短信接口\n            }\n        }\n        //验证码间隔验证的初始化\n        function codeInit() {\n            //如果验证码间隔倒计时还没30秒，就继续倒计时\n            let code_time = localStorage.getItem('code_time');\n            if (code_time) {\n                let time = codeTime - parseInt((new Date().getTime() - code_time) / 1000);\n                //小于0说明间隔已经满足\n                if (time > 0) {\n                    //执行控制验证码间隔函数\n                    code_limit_time(time);\n                }\n            }\n            // 发送短信验证码\n            code.addEventListener('click', codeClick);\n        }\n        // 控制验证码发送间隔函数\n        function code_limit_time(i = codeTime) {\n            code.innerHTML = `${i}秒后重新获取`;\n            code.style.pointerEvents = 'none';\n            code.style.background = '#c6c6c6';\n            var stv = setInterval(() => {\n                i--;\n                code.innerHTML = `${i}秒后重新获取`;\n                if (i === 0) {\n                    code_flag = true;\n                    code.innerHTML = `重新获取`;\n                    code.style.pointerEvents = 'auto';\n                    code.style.background = 'rgb(120, 187, 233)';\n                    clearInterval(stv);\n                    //倒计时完成移除时间戳\n                    localStorage.removeItem('code_time');\n                }\n            }, 1000)\n        }\n        //密码点击查看隐藏\n        const see_psw = document.querySelector('.form-item .see')\n        see_psw.addEventListener('click', () => {\n            let input = see_psw.parentNode.firstElementChild;\n            if (input.type === \"password\") {\n                see_psw.innerHTML = \"隐藏\";\n                input.type = \"text\";\n            } else {\n                see_psw.innerHTML = \"显示\";\n                input.type = \"password\";\n            }\n        });\n        // 检查协议是否同意\n        function inspect_agree() {\n            console.log(11);\n            let div = agree.nextElementSibling;\n            if (agree.checked) {\n                div.innerHTML = \"\";\n                return true;\n            } else {\n                div.innerHTML = \"请同意协议\";\n                return false;\n            }\n        }\n        function subInit() {\n            login_form.forEach((item, index) => {\n                item.addEventListener('submit', (e) => {\n                    e.preventDefault();\n                    if (!inspect_agree()) {\n                        return;\n                    }\n                    //存储用户名或手机号\n                    localStorage.setItem('user', uname.value||phone.value);\n                    //这里作跳转\n                    // location.href = '/'\n                });\n            })\n        }\n        //初始化函数\n        function loginInit() {\n            codeInit();\n            subInit();\n        }\n        //执行初始化\n        loginInit();\n    </script>\n</body>\n</html>\n\n```\n\n\n\n\n<script src=\"https://cdn.chuckle.top/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.chuckle.top/js/45.js\"></script>\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript笔记DOM操作","url":"/article/6c6d4353.html","content":"\n# DOM简介\nHTML是一种纯文本格式的文件，也就是文档，[HTML基础笔记](/article/1475187a.html)\n\n**DOM：**Document Object Model 文档对象模型，将 HTML 文档结构化表示\n\nDOM 让网页 HTML 中的元素以树的方式呈现，并提供了访问、操控 DOM 树中各个节点的API，是为了让 JS 操作 HTML 元素而制定的一个规范，如今可看作是 JS 的一部分\n\n每个载入浏览器的 HTML 文档都会成为 Document 对象，Document 对象是 Window 对象的一部分，可通过 window.document 或 document 对其进行访问\n\n```html 获取DOM对象\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n    <div>一个div</div>\n    <script>\n      console.log(document);\n      console.log(window.document);\n    </script>\n</body>\n</html>\n\n```\n\n控制台输出：获取到了网页所有元素，整个html文档\n\n<img src=https://cdn.chuckle.top/images/44-2.webp width=\"70%\">\n\n**DOM树：**\n网页中的一切元素都是 DOM 树中的节点\n\n<img src=https://cdn.chuckle.top/images/44-3.webp width=\"80%\">\n\n**节点类型：**\n1. **文档节点：**文档本身，整个 document 文档\n2. **元素节点：**所有 HTML 标签元素，<head> <body> <div> <span>\n3. **属性节点：**所有标签元素内的属性，id、class、href、name\n4. **文本节点：**标签元素内的文本\n5. **注释节点：**HTML中的注释，<\\!-- 注释 --\\>\n\n# 获取DOM元素\n**获取dom节点对象的方法：**\n1. `getElementById('id名')` 根据id获取**第一个dom对象**（通常id唯一）\n2. `getElementsByClassName('class类名')` 根据class名获取**dom对象数组 NodeList**\n3. `getElementsByTagName('标签名')` 根据标签名获取**dom对象数组**\n4. `getElementsByName('name名')` 根据name属性值获取**dom对象数组**，一般不用\n5. `querySelector('CSS选择器')` 查找匹配指定CSS选择器的**第一个dom对象**\n6. `querySelectorAll('CSS选择器')` 查找匹配指定CSS选择器的所有元素，返回**dom对象数组**\n\n获取到的dom对象数组都是伪数组\n\nJS获取的都是对象，使用`console.dir()`能更直观地看一个对象。\n\n## 操作元素的内容\n获取到dom对象后，通过两个**属性**就能获取、修改元素中的内容\n1. `innerText` **不解析**标签\n2. `innerHTML` **解析**标签，通常用这个\n\n使用 += 保留元素中原有内容，并在元素中末尾添加新内容\n\n## 操作元素的属性\n获取到dom对象后，直接访问**属性**（如src、href、id、class）就能进行修改或赋值\n\n```html\n<img src=\"1.webp\" alt=\"一张图片\">\n<script>\n  const img = document.querySelector('img');\n  img.src = \"2.webp\"\n</script>\n```\n\n## 操控元素样式\n**1、通过 style 属性控制元素样式：**css带有 - 连接符的属性，在js中采用小驼峰命名法获取\n\n```html\n<div class=\"box\"></div>\n<script>\nconst box = document.querySelector('.box');\nbox.style.background = 'blue';\nbox.style.backgroundColor = 'green';//background-color\n</script>\n```\n\n**2、通过类名控制元素样式：**直接修改style属性过于麻烦，可以先把样式写给一个类，再将类名赋给 **className** 属性，+= 保留原有类名\n\n```html\n<style>\n  .box1{\n    width: 100px;\n    height: 100px;\n  }\n  .box2{\n    width: 200px;\n    background: rgb(88, 164, 192);\n  }\n</style>\n<div class=\"box1\"></div>\n<script>\n  const box = document.querySelector('.box1');\n  box.className += ' box2';\n</script>\n```\n\n使用 += 号来保留原有class还是不够规范\n\n可以使用 **classList** 属性来添加、删除、切换(有就删除，没有就加上)类名\n\n```js\n// 添加一个类名\n元素.classList.add('类名');\n// 删除一个类名\n元素.classList.remove('类名');\n// 切换一个类名\n元素.classList.toggle('类名');\n```\n\n## 操作表单元素\ninput 标签框内的文本存放在其value属性中，获取即可\n\n```js\nconst ipt = document.querySelector('input');\nconsole.log(ipt.value);\n```\n\n操作 input 的 type 属性，来控制输入框样式\n\n```js\nconst ipt = document.querySelector('input');\nipt.type = 'password';\n```\n\n一些布尔值的属性(赋任意值都代表true)，disabled、checked、selected，添加上就有效果\n\n```js\nconst ipt = document.querySelector('input');\nipt.checked = true;\n```\n\n## 自定义属性\n**标准属性：**标签自带的属性，class、id、title等\n\n**自定义属性：**H5的新东西,以 data- 开头，格式 **data-自定义后缀** ，`对象.dataset.自定义后缀` 获取\n\n```html\n<div class=\"box\" data-id=\"123456\"></div>\n<script>\n  const box = document.querySelector('.box');\n  console.log(box.dataset.id);//123456\n</script>\n```\n\n# 定时器\n**1、间歇函数** `setInterval()` 每隔一段时间自动执行一段代码\n\n```js\nsetInterval(()=>{\n  console.log(1);\n},1000);\nsetInterval(fun,1000);\n```\n\n清除间歇函数定时器 `clearInterval()` ：\n\n```js\nvar itv = setInterval(fun,1000);\nclearInterval(itv);\n```\n\n**2、延时函数** `setTimeout()` 延时一段时间后执行代码\n\n```js\nsetTimeout(()=>{\n  console.log(1);\n},1000);\n```\n\n清除延时函数定时器 `clearTimeout()`\n\n# 事件\n**DOM事件：**在文档或浏览器窗口中产生的一系列交互，如拖动元素、点击按钮、提交表单等。\n\nJavaScript 以**事件驱动**为核心，通过监听事件或给事件绑定JS，可以在事件发生时执行特定 JS 以完成交互。\n\n{% folding, 常见事件  %}\n这里都是事件名，属性名一般在事件名前加 on\n\n**鼠标事件：**\n1. **click** 鼠标左键/键盘回车\n2. **dbclick** 双击鼠标左键\n3. **mouseenter** 光标移入元素，不冒泡\n4. **mouseleave** 光标移出元素，不冒泡\n5. **mouseover** 光标移入元素，冒泡\n6. **mouseout** 光标移出元素，冒泡\n7. **mousedown** 按下任意鼠标键\n8. **mouseup** 释放任意鼠标键\n9.  **mousewheel** 鼠标滚轮滚动\n10. **mousemove** 光标在元素上移动\n\n**用户界面事件：**\n1. **load** 页面或资源加载完成\n2. **unload** 卸载完成\n3.  **error** JS出错或资源加载失败\n4.  **select** 选中文字\n5.  **resize** 调整窗口大小\n6.  **scroll** 包含滚动条的元素\n\n**焦点事件：**\n1.  **blur** 失去焦点，不冒泡\n2.  **focus** 获得焦点，不冒泡\n3.  **focusout** 失去焦点，冒泡\n4.  **focusin** 获得焦点，冒泡\n\n**键盘和输入事件：**\n1. **keydown** 按下键盘某个键\n2. **keyup** 释放键盘某个键\n3. **input** 当输入框文本改变时立即触发\n4. **change** 当输入框内容发生改变,失去焦点时触发\n5. **textInput** 文本输入\n\n**HTML5事件：**\n1. **contextmenu** 右键菜单\n2. **beforeunload** 页面卸载之前\n3. **DOMContentLoaded** DOM树构建完成\n4. **readystatechange** 加载状态变化\n5. **hashchange** URL散列值变化\n\n{% endfolding %}\n\n**事件的三要素：**事件源、事件、事件驱动程序\n\n**事件源：**触发事件的元素，获取事件源，即获取DOM节点\n**事件：**JS定义的各种事件\n**事件驱动程序：**触发事件后进行的操作\n\n## 事件监听\n使用 `addEventListener` 监听事件\n\n```js\n元素对象.addEventListener('事件类型', 执行的函数)\n```\n\n可以重复绑定。\n\n## 事件对象\n事件对象存放了事件触发时的相关信息，如鼠标点击的位置坐标、键盘按下了哪个键\n\n事件绑定的回调函数的第一个参数就是事件对象event、e\n\n```js\n元素.addEventListener('事件',(e)=>{\n  console.lig(e);\n});\n```\n\n**事件对象常见属性：**\n1. **type** 当前事件类型\n2. **clientX 、 clientY** 获取光标相对于浏览器可见窗口左上角的位置\n3. **offsetX 、 offsetY** 获取光标相对于当前DOM元素左上角的位置\n4. **key** 当前按下的键盘键的值\n\n```js 监听是否按下回车\nconst ipt = document.querySelector('input');\nipt.addEventListener('keyup', (e)=>{\n  if(e.key == 'Enter'){ console.log('回车'); };\n});\n```\n\n## 常用事件\n**1、焦点事件 focus blur** 见案例-搜索框下拉栏\n\n**2、键盘事件 keydown keyup input** 见案例-评论发布、字数统计\n\n**3、mouseover 与 mouseenter**\nmouseover/mouseout 有冒泡效果，mouseenter/mouseleave 没有冒泡效果\n\n使用mouseover，有冒泡效果，所以鼠标从监听的元素到其子元素，虽然子元素没用绑定鼠标进入事件，但该事件会冒泡到父元素的同名事件，所以也会触发进入\n\n通常用 mouseenter/mouseleave\n\n**4、加载事件 load、DOMContentLoaded**\n**load** 监听某个元素内的所有资源（dom、css、img）加载完毕\n\n```js\n//等待页面所有资源加载完毕，再执行回调函数\nwindow.addEventListener('load', ()=>{})\n//等待图片加载完毕\nimg.addEventListener('load', ()=>{})\n```\n\n**DOMContentLoaded** 监听HTML文档加载完毕该事件就被触发，不等待css等其它资源\n\n```js\ndocument.addEventListener('DOMContentLoaded', ()=>{})\n```\n\n**5、滚动事件 scroll**\n当某个元素的滚动条滚动时，触发该事件，不冒泡\n\n通常配合元素的 **scrollTop** 和 **scrollLeft** 两个属性，获取的是**数字型**，不带单位，但意思是像素px，可读写，可让js去控制滚动\n\n```js\n//整个页面卷去的高度，document.documentElement获取html标签\ndocument.documentElement.scrollTop\n//元素被卷去的高度\ndiv.scrollTop\n```\n\n这两个属性都用来获取被卷去的大小，即元素随着滚动超出可视窗口的大小（单位px）\n**scrollTop** 滚动条往下，元素向上移动，即获取该元素向上移动超出可视区域的高度\n**scrollLeft** 滚动条往右，元素向左移动，即获取该元素向左移动超出可视区域的宽度\n\n获取页面滚动高度的时候优先考虑使用 window.pageYOffset 然后在使用scrollTop\n\n```js\nvar _scrollLeft = window.scrollX || window.pageXOffset || document.documentElement.scrollLeft\nvar _scrollTop = window.scrollY || window.pageYOffset || document.documentElement.scrollTop\n```\n\n**一些小案例：**\n\n```js \nwindow.addEventListener('scroll', function () {\n    const n = document.documentElement.scrollTop\n    if (n >= 100) { // 页面滚动高度超过100px进行一些操作\n    } else { // 页面滚动高度小于100px进行恢复操作\n    }\n})\n```\n\n```js 回到顶部\nconst backTop = document.querySelector('#backTop')\nbackTop.addEventListener('click', function () {\n  // document.documentElement.scrollTop = 0\n  // window.scrollTo(x, y)\n  window.scrollTo(0, 0)\n})\n```\n\n**5、窗口尺寸变化事件 resize**\n浏览器窗口大小发生变化的时候触发的事件\n\n```js\nwindow.addEventListener('resize', ()=>{})\n```\n\n**6、移动端触摸事件 touchstart touchend touchmove**\n\n**touchstart** 手指触摸到元素时触发\n**touchend** 手指从元素离开时触发\n**touchmove** 手指在元素上滑动时触发\n\n\n## 事件流\n**事件流：**事件完整执行过程中的流动路径\n\n两个阶段：**捕获**阶段、**冒泡**阶段\n\n捕获阶段从父节点到子，冒泡阶段从子到父\n\n处理函数默认在冒泡阶段执行，从子节点到父节点，依次向上调用所有父级元素的**同名事件**。\n\n**让处理函数在捕获阶段触发：**冒泡阶段不再触发\n\n```js 传入第三个参数true\n元素.addEventListener(事件类型, 处理函数, true);\n```\n**阻止冒泡：**\n默认存在冒泡模式，子元素触发事件也会触发父级同名事件，阻止冒泡能把事件限制在当前元素内\n\n`stopPropagation()` **阻止事件流动**传播，不仅能阻止冒泡也能阻止捕获\n\n```js\n事件对象.stopPropagation();\n```\n\n## 解绑事件\n`removeEventListener()` 对某个元素解绑某个处理函数，匿名、箭头函数无法被解绑\n\n```js\n元素.removeEventListener(事件类型, 处理函数);\nbtn.removeEventListener('click', fn);\n```\n\n## 事件委托\n**事件委托：**一种技巧，减少事件注册次数，提高程序性能。\n\n事件冒泡可以用来实现事件委托，给父元素注册事件，当触发子元素的时候，会冒泡到父元素身上，从而触发父元素的事件。\n\n**案例：**当多个子元素需要注册点击事件时，可以将点击事件注册到父元素上，再由父元素的事件对象e去找被点击的子元素，`e.target` 就能找到实际触发事件的子元素，再用其className、id、tagName 来确定业务上应该要触发事件的子元素。\n\n```js\nconst ul = document.querySelector('ul');\nul.addEventListener('click', function (e) {\n    if (e.target.tagName === 'LI') {\n        e.target.style.color = 'red'\n    }\n})\n```\n\n## 阻止元素默认行为\n使用 `e.preventDefault()` 阻止元素默认行为\n\n```js 让a标签点击不跳转链接\n//<a href=\"http://www.baidu.com\">百度一下</a>\nconst a = document.querySelector('a')\na.addEventListener('click', function (e) {\n    e.preventDefault()\n})\n```\n\n# 元素的属性、方法\n获取到元素后常用的属性和方法\n## 元素的尺寸与位置\n获取元素的宽高：**clientWidth**、**clientHeight**两个属性，不包含padding、border，**offsetWidth**、**offsetHeight**包含padding、border\n\n获取窗口的宽高：`document.documentElement.clientWidth`\n\n**offsetTop**、**offsetLeft**获取元素距离自己最近一位带有定位的祖先元素的左、上位置\n\n`getBoundingClientRect()` 获取元素的大小和相对于**可视窗口**的位置，返回一个对象里面有width、height、top等属性\n\n## 元素节点操作\n**1、关系查找元素节点**，以元素节点之间的关系进行查找，父找子、子找父、找兄弟\n\n查找最近一级的**父节点**：`子元素.parentNode`\n\n查找最近一级的所有**子节点**，返回伪数组：`父元素.children`\n`firstElementChild` 第一个子节点\n`lastElementChild` 最后一个子节点\n\n**上一个**兄弟节点：`previousElementSibling`\n**下一个**兄弟节点：`nextElementSibling`\n\n**2、创建节点**\n\n`document.createElement('标签名')`\n\n**3、增加节点：**\n\n`appendChild(插入的元素)` 在指定节点的子节点列表**末尾**添加新的子节点\n\n`insertBefore(插入的元素,[放到哪个元素的前面])` 在节点的子节点列表**任意位置前**插入新的节点，默认在子节点列表的**末尾**插入\n\n**4、克隆节点**\n\n`元素.cloneNode(布尔)` 参数为true，后代节点也会被克隆，false克隆时不包含后代节点(即只克隆标签)，默认false\n\n**5、删除节点**\n\n`父元素.removeChild(子元素)` 通过父节点删除子节点\n\n\n# BOM\n**BOM** (Browser Object Model ) 是浏览器对象模型，提供了一些属性与方法\n\n## window对象\nwindow对象是一个全局对象，是BOM的顶层对象，也是js中最顶级的对象，document、alert()、console、定时器等都是其属性和方法\n\n所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法\n\nwindow对象下的属性和方法调用的时候可以省略window\n\n## location对象\nlocation拆分并保存了URL地址的各个组成部分\n\n常见属性和方法\n1. **href** 获取完整的URL地址，也可以赋值进行地址跳转\n2. **search** 获取地址中携带的参数，?后面的部分\n3. **hash** 获取地址中的哈希值，#后面的部分\n4. `reload()` 刷新当前页面，传入参数true表示强制刷新\n\n## navigator对象\nnavigator保存了浏览器的相关信息\n\n常见属性和方法\n1. **userAgent** 获取浏览器的类型、版本\n\n## history对象\nhistory管理历史记录，如前进、后退、历史记录等\n\n常见属性和方法\n1. `back()` 浏览器后退功能\n2. `forward()` 浏览器前进功能\n3. `go()` 参数1前进一个页面，-1后腿一个页面\n\n## 本地存储\n将数据存储这浏览器中，刷新页面不丢失数据，sessionStorage 和 localStorage，现在主要用**localStorage**\n\n本地存储只能存字符串或数值型\n\nlocalStorage 以**键值对**的形式存储，可以多页面共享\nsessionStorage 以**键值对**的形式存储，生命周期为关闭浏览器就消失，数据同一个页面共享\n\n新增/修改：`setItem`\n\n```js\nlocalStorage.setItem(key, value);\n```\n\n读取：`getItem`\n\n```js\nlocalStorage.getItem(key);\n```\n\n删除：`removeItem`\n\n```js\nlocalStorage.removeItem(key);\n```\n\n**存储复杂数据类型：**存一个对象\n\n由于本地存储只能存字符串，所以需要将对象先转为JSON字符串再存储，使用时再把JSON转为对象\n\n`JSON.parse()` 将数据转换为 JavaScript 对象\n`JSON.stringify()` 将 JavaScript 对象转换为 JSON 字符串\n\n```js\nconst obj = {\n    name: 'chuckle',\n    age: '19'\n}\nlocalStorage.setItem('obj', JSON.stringify(obj));\nvar obj2 = JSON.parse(localStorage.getItem('obj'));\n```\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(3)","url":"/article/7d8b8b34.html","content":"\n# JS函数简介\n\n使用**function**关键字定义函数对象，函数的typeof类型也是**function**\n\n```js\nfunction hello(){\n    console.log('hello');\n}\nconsole.log(typeof hello)//function\nconsole.log(fun instanceof Object)//true\n```\n\n使用**函数表达式**创建**匿名函数**，即将匿名函数赋值给一个变量\n\n```js\nvar fun = function(){\n\tconsole.log(\"匿名函数\");\n};\nfun();//匿名函数\n```\n\n函数是对象，也可以new出来，但一般不用这种形式，Function里面的**参数都必须是字符串格式**\n\n```js\nvar fun = new Function('a', 'b', 'console.log(a + b);');\nfun(1,2); // 3\n```\n\n使用**return**终止函数或返回一些数据，默认返回undefined\n\n**函数名**就是整个函数，JS加载的时候，只加载函数名，不加载函数体\n\n```js\nfunction fun(){\n    console.log(\"hello\");\n};\nconsole.log(fun);//输出fun(){console.log(\"hello\");}\nconsole.log(fun());//先执行函数，再输出返回值\n```\n\n## 函数的调用\n\n**1、**调用函数可以函数名调用，可以用**call()**方法\n\n```js\nfunction fun(){ console.log('hello'); }\nfun(); // hello\nfun.call(); // hello\n```\n\n**2、**在对象中保存多个函数，通过对象的方法来调用，函数作为**对象的属性**保存，这个函数就是**对象的方法**\n\n```js\nvar obj = {\n    fun1: function(){\n        console.log(\"函数一\");\n    },\n    fun2: function(){\n        console.log(\"函数二\");\n    }\n}\nobj.fun1();// 函数一\nobj.fun2();// 函数二\n\n```\n\n**3、立即执行函数**，在定义后立即执行\n\n```js\n(function() {\n\tconsole.log('立即执行函数');\n})();\n//立即执行函数\n```\n\n**4、**通过**构造函数**调用\n\n```js\nfunction Fun() {\n\tconsole.log(\"这是一个函数\");\n}\nnew Fun();// 这是一个函数\n```\n\n**5、绑定事件函数**，触发事件后立即执行的函数\n\n```js\nvar btn = document.getElementById('btn');\n//绑定事件\nbtn.onclick = function() {\n    console.log('点击按钮后，要做的事情');\n};\n```\n\n**6、定时函数**\n\n```js\nsetInterval(function () {\n    console.log(\"hello\");\n}, 1000);//每1000ms执行一次\n```\n\n## 形参和实参\n**形参：**函数在定义时要求传入的一些参数\n**实参：**调用函数时传入的一些参数\n\n实参将**按顺序传递**给函数中对应的形参\n\n```js\nfunction fun(a, b){//该函数需要两个形参\n    console.log(a + b);\n};\n//调用时传入两个实参\nfun(1, 2)// 3\n```\n\n实参和形参，数量可以不同，调用函数时，解析器不会检查实参的数量。\n\n**实参多余形参：**忽略多余的实参\n**实参少余形参：**没有接收到值的形参默认为undefined，undefined参与运算为NaN\n\n```js\nfunction fun(a, b){ console.log(a + b); };\nfun(1, 2)// 3\nfun(1, 2, 3)// 3\nfun(1)// NaN\n```\n\n调用函数时，解析器也不会检查实参类型，实参可以是**任意数据类型**\n\n## 类数组对象arguments\n在调用函数时，浏览器每次都会传递进两个隐含的参数：（箭头函数没有自己的this和arguments。）\n1. 函数的上下文对象 **this**\n2. 封装实参的对象 **arguments**\n\narguments是一个类数组对象（伪数组），不是一个真正的数组，除了length属性、可以通过索引获取元素之外没有任何数组属性和方法。\n\n`Array.from()`能将伪数组转为真数组\n\n```js\nfunction fun(a, b){ \n    console.log(arguments);// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n    console.log(Array.from(arguments));// [1, 2]\n    console.log(typeof arguments);// object，arguments 的原型是 Object，而数组的原型是 Array\n    return a + b;\n};\nfun(1, 2);\n```\n\n**案例：**将传入的实参进行求和，无论实参的个数有多少：\n\n```js\nfunction fun() {\n    var arr = Array.from(arguments);\n    var result = arr.reduce((prev, item) => {\n        return prev + item;// 累计求和\n    }, 0);\n    return result;\n}\nvar sum = fun(0, 1, 2, 3, 4, 5, 6);\nconsole.log(sum); // 21\n\n```\n\n**arguments.callee**返回正在执行的函数\n\n```js\nfunction fun() {\n    console.log(arguments.callee);\n}\nfun();// 返回了fun这个函数对象， fun() {console.log(arguments.callee);}\n```\n\n通过**arguments**修改传入的实参\n\n```js\nfunction fun(a, b){ \n    //修改传入的最后一个参数为0\n    arguments[arguments.length-1] = 0;\n    return a + b;\n};\nconsole.log(fun(1, 2));// 1\n```\n\n# 作用域\n变量或函数的作用范围。作用域在函数定义时，就确定。\n**全局作用域**：作用于整个script标签内，或作用于一个独立的JS文件\n**函数作用域**：作用于函数部\n**块级作用域**：ES6新增，作用于一个区块{}内\n\n在全局作用域中有一个全局对象 **window**(~~和微软没有半毛钱关系~~)，它代表的是浏览器的窗口，由浏览器创建。\n\n创建的**全局变量**都会作为 window 对象的**属性**保存。\n创建的**全局函数**都会作为 window 对象的**方法**保存。\n\n变量如果未经声明(没有var、let、const)就赋值，是**全局变量**\n\n```js\nvar a = 1;\n(function() {\n    var [a, b] = [0, 0];\n    console.log(a);// 0\n    console.log(window.a);// 1,访问全局变量a\n})();\nconsole.log(b);// 报错Uncaught ReferenceError:b is not defined\n```\n\n**连续赋值**时，除了第一个声明的变量之外，后面的变量都是全局变量\n\n```js\nfunction fun(){\n    var a = b = 1; // 连续赋值，a是函数作用域变量，b是全局变量\n}\nfun();\nconsole.log(a);// 报错Uncaught ReferenceError: a is not defined\nconsole.log(b);// 1\n```\n\n\n## 变量、函数提升\n\n**全局作用域的预处理：**JS在解析代码之前，将当前 JS 代码中所有变量的定义和函数的定义，放到所有代码的最前面，先进行声明但不进行赋值，默认都是undefined。\n\n任何变量，如果**未经声明**(没有var、let、const)就赋值，此变量是属于 window 的属性，而且**不会做变量提升**\n\n```js\nconsole.log(a);//undefined\nvar a = 1;\n\nconsole.log(b);//报错Uncaught ReferenceError:b is not defined\nb = 1;//赋值但没定义，相当于window.b，不进行变量提升\nconsole.log(b);//1\n```\n\n其它作用域也有类似的预处理，这就是**变量提升**，即将变量声明提升到它所在作用域的最开始的部分。\n\n**函数的声明提前（函数提升）：**\n使用**函数声明**的形式创建的函数**function fun(){}**，**会**被函数提升，可以提前调用函数，能正常执行。\n使用**函数表达式**创建的函数**var fun = function(){}**，**不会**被函数提升，但属于变量提升，不能提前调用，会被认为不是一个函数。\n\n函数的形参就相当于在函数作用域中声明了变量。\n\n```js\nconsole.log(fun1(1, 2));// 3，提前调用可以正常执行函数\nfunction fun1(a, b){ return a + b; }\n\nfun2();//报错Uncaught TypeError: fun2 is not a function\nvar fun2 = function(){}\n```\n\n**函数提升优先于变量提升**\n\n```js\nfun(); // 先函数提升，所以输出B\n\n// 函数提升\nfunction fun() {\n  console.log('B');\n}\n\nconsole.log(fun);// ƒ fun() {console.log('B');}\n\n// 变量提升，此时相当于重新声明fun变量\nvar fun = function () {\n  console.log('A');\n};\n\nfun(); // A\n\n```\n\n**函数的嵌套：**会出现**作用域链**，在嵌套函数中，变量会从内到外逐层寻找它的定义（查找时，采用就近原则）。\n\n```js\nvar a = 0;\n\nfunction fn() {\n    // 外部函数\n\n    fun();//函数提升，提前调用也正常执行\n    function fun() {\n        // 内部函数\n        console.log(a);//先找到var  a = 1\n        //输出undefined，因为实际代码中变量的调用在变量声明之前，属于变量提升，默认值为undefined\n    }\n\n    var  a = 1;\n    //fun()若内部函数在此执行，则会输出 1\n}\nfn();\n\n```\n\n# this指向\n[JavaScript的this原理--阮一峰](https://www.ruanyifeng.com/blog/2018/06/javascript-this.html)\n\n`this` 即‘当前’，指的是**函数运行时所在的环境**，它永远指向函数的真实调用者，如果没有调用者，就指向全局对象window。\n\n```js foo()绑定给多个对象\nvar a = -1;\nfunction foo(){\n    console.log(this.a);\n};\nvar obj1 = {\n    a:1,\n    foo:foo\n};\nvar obj2 = {\n    a:0,\n    foo:foo\n};\nobj1.foo();// 1\nobj2.foo();// 0\nfoo();// -1\nwindow.foo();// -1\n\n```\n\nthis在**函数调用时**绑定，函数执行时会创建一个活动记录，这个记录里包含了该函数中定义的参数，也包含函数在哪里被调用（调用栈）,this就是其中的一个属性。\n\n## 绑定规则\n1. **默认绑定：**把this绑定到**全局对象window**，以函数的形式而非对象的方法（包括普通函数、定时器函数、立即执行函数）调用时。\n2. **对象中的this：隐式绑定（上下文绑定）**对象内部方法的this指向调用此方法的对象，谁调用就指向谁\n3. **构造函数中的this：**构造函数中的this指向构造函数下创建的实例对象，构造函数返回创建的对象。\n4. **以事件绑定函数的形式调用时，this指向绑定事件的对象**\n5. **箭头函数中的this：**指向函数作用域所用的对象\n\n\n**1、默认绑定：**把this绑定到**全局对象window**，以函数的形式而非对象的方法（包括普通函数、定时器函数、立即执行函数）调用时。\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 0;\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\n\nfun();//输出 Window、0、1\nwindow.fun();//输出 Window、0、1\n//fun代码块中，this指的都是window，而a变量是全局变量，即是window的属性，所以this.a访问的是window.a\n```\n\n**2、对象中的this：隐式绑定（上下文绑定）**对象内部方法的this指向调用此方法的对象，谁调用就指向谁\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 0;// 先把对象中的a值改为0\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    //注意是函数名，因为函数名就代表了这个函数\n    fun: fun//将fun绑定给obj对象的fun属性，此时fun的this指向obj这个真实调用者\n}\nobj.fun();//输出 obj对象{a: 1, fun: ƒ}、0、1\n\n```\n\n**多层对象**时，内部方法this指向离被调用函数最近的对象\n\n```js\nvar a = 0;\nfunction fun() {\n    console.log(this);// 输出this指的是谁\n    console.log(this.a);\n    this.a++;\n    console.log(this.a);\n}\nvar obj1 = {\n    a: 1,\n    //注意是函数名，因为函数名就代表了这个函数\n    fun: fun,//将fun绑定给obj1对象的fun属性\n    obj2: {\n        a: 2,\n        fun: fun\n    }\n}\nobj1.fun();//输出 obj1对象{a: 0, obj2: {…}, fun: ƒ}、1，2\nobj1.obj2.fun();//输出 obj2对象{a: 0, fun: ƒ}、2，3\n\n```\n\n上面代码中，若obj2中没有a属性，this.a是undefined，即无论对象嵌套多少层，this只会指向**直接调用该函数**的对象（离被调用函数最近的对象）\n\n**this永远指向函数的真实调用者**\n\n```js\nvar a = 0;\nfunction fun() {\n    this.a = 2;\n    this.foo = fun2;\n}\nfunction fun2() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    fun: new fun().foo\n}\nobj.fun();// 1，多次引用的传递，实际上是obj调用了fun2\n\n```\n\n**隐式绑定的丢失:**通过赋值，导致隐式绑定的丢失。\n\n```js\nvar a = 0;\nfunction fun() {\n    console.log(this.a);\n}\nvar obj = {\n    a: 1,\n    fun: fun\n}\nobj.fun();// 1\nvar foo = obj.fun;\nfoo();// 0\n\n```\n\n上面代码中，obj的fun属性引用了fun函数的引用内存地址，在obj.fun()调用函数时，fun函数中的this会动态绑定对象(当前函数的直接调用者，即obj对象)，将obj.fun的引用地址赋值给了foo那么foo也引用了fun函数的引用内存地址，使用foo()时，fun函数中的this也会动态绑定对象(当前函数的直接调用者，即window对象)。\n\n**3、构造函数中的this：**构造函数中的this指向构造函数下创建的实例对象，构造函数返回创建的对象。\n\n```js\nfunction Fun(name, age){\n    this.name = name;// 让构造函数创建的实例对象中的name属性等于传入的实参name\n    this.age = age;\n}\nvar fun = new Fun('chuckle', 19);\nconsole.log(fun);//Fun {name: 'chuckle', age: 19}\nconsole.log(typeof fun);// object构造函数返回创建的对象\n```\n\n**4、以事件绑定函数的形式调用时，this指向绑定事件的对象**\n\n```js\nvar btn = document.getElementById('btn');\n//绑定事件\nbtn.onclick = function() {\n    console.log(this);//this指向带有btn id的整个标签\n    //<button id=\"btn\"></button>\n};\n\n```\n\n**5、箭头函数中的this：**指向函数作用域所用的对象\n\n**箭头函数的重要特征**：箭头函数**没有**自己的this和arguments，但它会继承自己**定义时**所处的**外层执行环境的this指向**，指向当前**定义时所在的对象**，call()、apply()、bind()等方法**无法改变**箭头函数继承的this指向。\n\n简单地说，箭头函数会找它的上一级作用域。如果父级作用域还是箭头函数，就再往上找，一层层找，直到找到this指向的对象\n\n```js\nvar obj = {\n    a: 1,\n    fun: ()=>{\n        console.log(this);\n    }\n}\n//obj是一个全局变量，fun是一个箭头函数，在定义时指向这个全局变量的作用域，即window对象\nobj.fun();//Window {window: Window, self: Window, document: document, name: '', location: Location, …}\n\n```\n\n多层对象时，仍然指向最外部对象定义时所在的环境\n\n```js\nvar obj1 = {\n    a: 1,\n    obj2: {\n        a: 2,\n        fun: ()=>{\n            console.log(this);\n        }\n    }\n}\n//obj2是obj1的属性，obj是一个全局变量，所以定义时箭头函数this仍然指向window对象\nobj1.obj2.fun();//Window {window: Window, self: Window, document: document, name: '', location: Location, …}\n\n```\n\n用构造函数创建对象，创建出来的对象中的箭头函数和普通函数，都指向构造函数创建出来的对象，但一个是在定义时指向obj对象，一个是在调用时指向obj对象\n\n```js\nfunction foo(){\n    console.log(this);\n}\nfunction Fun(){\n    this.fun = ()=>{\n        console.log(this);\n    };\n    this.foo = foo;\n}\nvar obj = new Fun();\nobj.fun();//Fun {fun: ƒ, foo: ƒ}\nobj.foo();//Fun {fun: ƒ, foo: ƒ}\nconsole.log(typeof obj);// object\n\n```\n\n**普通函数中的箭头函数：**\n\n箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量window。\n\n或者说，**普通函数中的箭头函数的this被绑定到该函数执行的作用域上**\n\n```js\nvar obj={\n\tbirth:1990,\n\tgetAge:function(){\n        //对象内部方法的this指向调用此方法的对象\n\t\tvar b = this.birth;// 1990\n        //箭头函数的this就是这个外层的普通函数的this，所以在定义时就指向obj\n\t\tvar fn = ()=>2023-this.birth;\n\t\treturn fn();\n\t}\n};\nobj.getAge();//33\n\n```\n\n```js\nvar birth = 2000\nvar obj={\n\tbirth:1990,\n\tgetAge:function(){\n\t\tfn = ()=>2023-this.birth;\n\t\treturn fn();\n\t}\n};\nobj.getAge();//33\nvar foo = obj.getAge;//发生隐式绑定的丢失，函数的作用域从obj对象变为全局window\nfoo();// 23，\n\n```\n\n## 改变this指向的方法\nJS在Function的porpertype属性上提供了3个方法来强行修改**函数内部**的this指向，不想改变this指向则**传入null或this**，这三个方法都**不会改变原函数的指向（动态的）**\n\n1. `call()`：传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，然后会执行这个函数\n2. `apply()`：传入两个参数，第一个是要修改的this的指向，第二个是一个数组，它保存了要传入函数的多个参数，然后会执行这个函数\n3. `bind()`：传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，不会执行这个函数，但会返回**指定this和指定实参的原函数拷贝**（一个改变了this指向和已经传入了参数的新函数）\n\n**1、`call()`：**传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，然后会执行这个函数\n\n```js 语法\nfun.call(想要将this指向的对象, 函数实参1, 函数实参2);\n```\n\n通过call()调用函数，不改变指向\n\n```js\nvar a = 1;\nfunction fun() {\n    console.log(this);// window\n    console.log(this.a);\n}\n//将this的指向又传给this，指向没有被改变\nfun.call(this); // 1\nfun(); // 1\nfun.call(); // 1\nfun.call(window); // 1\nfun.call(null); // 1\n\n```\n\n通过call()改变this指向\n\n```js\nvar a = 1;\nvar obj = {\n    a: 0\n}\nfunction fun() {\n    console.log(this);\n    console.log(this.a);\n}\nfun(); // window 1\nfun.call(obj); // obj 0\n\n```\n\n**2、`apply()`：**传入两个参数，第一个是要修改的this的指向，第二个是一个数组，它保存了要传入函数的多个参数，然后会执行这个函数\n\n```js 语法\nfun.apply(想要将this指向的对象, [函数实参1, 函数实参2]);\n```\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n};\n\nfunction fun(name) {\n    console.log(this);// 输出obj对象{name: 'chuckle', age: 19}\n    console.log(this.name);//chuckle\n    this.name = name;//改变obj的name属性为传入的实参\n    console.log(this.name);//qx\n}\n\nfun.apply(obj, ['qx']);//传一个实参，也需要传数组\nconsole.log(obj);//{name: 'qx', age: 19},name被改变\n\n```\n\n通过apply()求数组的最大值：\n\n数组本身没有求最大值的方法，但是数学对象中有**Math.max**(数字1，数字2...)，apply可以传入一个数组作为其参数，不改变其指向即可\n\n```js\nvar arr = [4, 2, 6, 5];\nvar maxValue = Math.max.apply(this, arr);// 不改变执行，传入一个数组作为参数\nconsole.log(maxValue);// 6\n```\n\n**3、`bind()`：**传入多个参数，第一个是要修改的this的指向，剩下的会传给函数当参数，不会执行这个函数，但会返回**指定this和指定实参的原函数拷贝**\n\n```js\nvar a = 1;\nvar obj = {\n    a: 0\n}\nfunction fun(a) {\n    console.log(this.a + a);\n}\nvar result = fun.bind(obj, 10); //返回指定this和指定实参的原函数拷贝\nconsole.log(typeof result);// function\nresult(10);// 10\nresult(20);// 10\n\nvar result = fun.bind(obj);\nresult(10);// 10\nresult(20);// 20\n\n```\n\n# 内存回收机制\nJS具有内存自动回收机制，周期性的找出不再继续使用的变量，然后释放其占用的内存。\n\n在闭包中，如果引用了外部的变量，则无法进行释放和回收，造成**内存泄漏**\n\n**常见内存泄漏：**全局变量、闭包、Dom元素的引用、定时器\n\nIE回收不了闭包里面引用的变量，但2023年了，主流浏览器都能回收闭包内不再使用的变量，[js闭包测试--司徒正美](https://www.cnblogs.com/rubylouvre/p/3345294.html)\n\n```js\nfor(let i = 0; i < 5; i++) {\n//for循环中是块级作用域，每执行一次循环，j就会被自动回收，所以不会报错（const 不能重新赋值）\n  const j = '局部变量'\n  console.log(j);\n}\n```\n\n# 闭包\n如果**外部作用域**有权访问另外一个**函数内部的局部变量**时，那就产生了**闭包**。这个内部函数称之为**闭包函数**\n\n**函数**和**函数内部能访问到的变量**的总和，就是一个闭包。\n\n闭包是JS函数作用域的副产品，因为JS的函数内部可以使用函数外部的变量。\n\n**闭包的生命周期:**\n**产生：**内部函数被声明时就产生了。\n**死亡：**嵌套的内部函数成为垃圾对象时。（比如fun = null，就可以让 fun 成为垃圾对象）\n\n**闭包的作用：**将函数内部的变量(局部变量)能被外部访问，隐藏一些变量，延长局部变量的生命周期\n\n```js\nfunction fun1() {\n  let a = 10;\n  return function fun2() {\n    console.log(a);\n  };\n}\n//获取到一个能访问fun1内部的变量的函数\nvar result = fun1();\n//在fun1函数的外部，执行了内部函数fun2，并访问到了fun1的内部变量a\nresult();// 10\n\n```\n\n上面的代码中，通过一些操作，让外部作用域（即全局作用域）有权访问函数fun1中的局部变量，在fun1中就产生了闭包，函数fun1是闭包函数，闭包是fun2和fun2所能访问到的变量a。\n\n**延长局部变量的生命周期：**\n\n```js\n// fun1执行完一次，局部变量就立即销毁，下次调用a还是0;\nfunction fun1() {\n  let a = 0;\n  a++;\n  console.log(a);\n}\nfun1();// 1\nfun1();// 1\n\n// 由于产生了闭包，fun2函数还要继续调用变量a，所以fun1函数中的变量a不会立即销毁，仍然保留在内存中。\n// 只有等所有函数把变量a调用完了，变量a才会销毁。\nfunction fun1() {\n  let a = 0;\n  function fun2() {\n    a++;\n    console.log(a);\n  };\n  return fun2;\n}\nvar result = fun1();\nresult();// 1\nresult();// 2\n\n```\n\n**隐藏一些变量：**\n\n打游戏时通常有血条和蓝条，我们当然不希望用户window.blood就能修改血量。将血量变量blood放进匿名函数中，在函数内部去声明一些修改血量的代码再赋给全局变量，就能在匿名函数外部通过这些函数去修改血量，但不能直接访问血量。\n\n```js\n!function(){ //匿名函数\n    let blood = 10;// 血量\n    // 扣若干滴血,默认扣1\n    window.reduceBlood = (a)=>{\n        a ? blood -= a : blood -= 1;\n        checkBlood();\n    };\n    // 增加若干滴血,默认加1\n    window.increaseBlood = (a)=>{\n        a ? blood += a : blood += 1;\n        checkBlood();\n    };\n    // 查询血量\n    window.checkBlood = ()=>{\n        console.log(`血量还有${blood}`);\n    };\n}();\n// 先连续扣血\nreduceBlood();// 血量还有9\nreduceBlood(5);// 血量还有4\n//再加血\nincreaseBlood();// 血量还有5\nincreaseBlood(5);// 血量还有10\n//查询血量\ncheckBlood(); // 血量还有10\n\n```\n\n**封装JS模块:**定义具有特定功能的JS模块，将所有的数据和功能都封装在一个函数内部，只向外暴露指定的对象或方法。模块的调用者，只能调用模块暴露的对象或方法来实现对应的功能\n\n如果不想将这三个函数直接赋给全局变量，也可以让函数返回一个装有三个方法的对象\n\n```js\nfunction Blood(){ //匿名函数\n    let blood = 10;// 血量\n    // 扣若干滴血,默认扣1\n    const reduceBlood = (a)=>{\n        a ? blood -= a : blood -= 1;\n        checkBlood();\n    };\n    // 增加若干滴血,默认加1\n    const increaseBlood = (a)=>{\n        a ? blood += a : blood += 1;\n        checkBlood();\n    };\n    // 查询血量\n    const checkBlood = ()=>{\n        console.log(`血量还有${blood}`);\n    };\n    // 返回一个对象，包含三个方法\n    return {\n        reduceBlood: reduceBlood,\n        increaseBlood: increaseBlood,\n        checkBlood: checkBlood\n    }\n};\n\nvar figure1 = new Blood();\nvar figure2 = new Blood();\n\nfigure1.checkBlood(); // 血量还有10\nfigure2.checkBlood(); // 血量还有10\n\n//可以看到，figure1和figure2是独立的,两个闭包函数是互不影响\n//减少1的血量不会减少2，血量不会互相干扰\nfigure1.reduceBlood(5);// 血量还有5\nfigure2.reduceBlood();// 血量还有9\n\n// 人物死亡需要重新创建角色，记得回收闭包\n// figure1 = null;\n\n```\n\n# 面向对象概述\nJava中已经学习过了什么是面向对象,这里不再扯概念。\n\nJS是基于**原型**的面向对象，JS中的对象（Object）是依靠**构造器**（constructor）和**原型**（prototype）构造出来的\n\n在ES6中，新引入了**类**（Class）和**继承**（Extends）来实现面向对象\n\n**面向对象的编程思想：**对代码和数据进行封装，并以对象调用的方式，对外提供统一的调用接口\n\n调用对象的属性：`obj.name`或`obj['name']`\n\n## 对象的创建\n**创建对象：**\n\n**1、对象字面量{}**\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n    obj2: {\n        a: 1,\n        b: 2\n    },\n    foo: function(){\n        console.log(`我的名字${this.name}`);\n    }\n}\nobj.foo();// 我的名字chuckle\nconsole.log(obj.name);// chuckle\nconsole.log(obj['name']);// chuckle\n\n```\n\n**2、工厂模式 new Object()** 大量创建同种对象\n\n```js\nfunction createPerson(name, age) {\n    //创建一个新的对象\n    var obj = new Object();\n    //向对象中添加属性\n    obj.name = name;\n    obj.age = age;\n    return obj;// 返回这个对象的引用\n}\n\nvar obj1 = createPerson('chuckle', 19);// {name: 'chuckle', age: 19}\nvar obj2 = createPerson('qx', 18);// {name: 'qx', age: 18}\n// 所以创建的对象都是 Object 这个类型\nconsole.log(typeof obj1);// object\nconsole.log(typeof obj2);// object\n\n```\n\n**3、构造函数**\n\n```js\nfunction Person(name, age) {\n    //构造函数中this指的是当前对象实例\n    this.name = name;\n    this.age = age;\n    this.foo = function () {\n        console.log(this.name);\n    };\n}\n\nvar p1 = new Person('chuckle', 19);\nconsole.log(p1);// Person {name: 'chuckle', age: 19, foo: ƒ}\nconsole.log(typeof p1);// object\np1.foo();// chuckle\n\n```\n\n## 构造函数\n**构造函数：**是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。\n\n创建构造函数时，里面的属性和方法前必须加this，this就表示当前要构造的对象。\n\n普通函数是直接调用，而构造函数需要使用 new 关键字来调用。\n\n**构造函数的执行流程：**\n1. 立刻创建一个对象\n2. 将新建的对象设置为函数中this，使得在构造函数中可以使用this来引用新建的对象\n3. 遂行执行函数中的代码，给这个新对象添加属性和方法\n4. 将新建的对象作为返回值返回(构造函数中无需return)\n\n```js\n// 构造函数\nfunction Student(name) {\n    this.name = name; //this指的是构造函数中的对象实例\n}\nvar stu = new Student('chuckle');// Student {name: 'chuckle'}\n\n//上面的代码相当于：\nfunction Student(name) {\n    var obj = new Object();\n    obj.name = name;\n    return obj;\n}\nvar stu = Student('chuckle');// {name: 'chuckle'}\n\n```\n\n**静态成员和实例成员：**\n**1、静态成员**:构造函数本身上添加的成员，静态成员只能通过构造函数访问，不能通过对象访问\n**2、实例成员**:构造函数内部通过this添加的成员，实例成员只能通过实例化的对象进行访问\n\n```js\nfunction Student(name) {\n    this.name = name; //this指的是构造函数中的对象实例\n}\nStudent.sName = 'qx';// 添加静态成员\nvar stu = new Student('chuckle');// 通过构造函数创建实例对象\n// 实例成员只能通过实例化的对象进行访问\nconsole.log(stu.name);// chuckle\nconsole.log(Student.name);// Student,函数的name是它的函数名\n// 静态成员只能通过构造函数访问，不能通过对象访问\nconsole.log(stu.sName);// undefined\nconsole.log(Student.sName);// qx\n\n```\n\n**类、实例**\n使用**同一个**构造函数创建的对象，都称为一类对象，也将**构造函数称为类**。通过一个构造函数创建的对象，称为该**类的实例**。\n\n使用 **instanceof** 可以检查一个对象是否为一个类的实例。\n\n```js\nfunction Person() {}\nfunction Dog() {}\nvar person = new Person();\nvar dog = new Dog();\n\nconsole.log(person instanceof Person); // true\nconsole.log(dog instanceof Person); // false\n//所有的对象都是Object的实例，所有类都是Object的子类。\nconsole.log(person instanceof Object); // true\n\n```\n\n## 对象的基本操作\n1. **向对象中添加属性：**`对象.属性名 = 属性值`\n2. **获取对象中的属性：**`对象.属性名`\n3. **修改对象的属性值：**`对象.属性名 = 新值`\n4. **删除对象的属性：**`delete 对象.属性名`\n5. **in 运算符：**`属性名 in 对象`检查一个对象中是否含有指定的属性\n\n```js\nvar obj = {};// 创建\nobj.name = 'chuckle';// 添加\nconsole.log(obj.name);// chuckle\nobj.name = 'qx';// 修改\nconsole.log(obj.name);// qx\ndelete obj.name;// 删除\nconsole.log('name' in obj);// false\n```\n\n## 遍历对象\n遍历对象时，要根据对象的结构配合使用多种方法，通常还需要配合数组的遍历方法\n\n**1、`for-in`遍历对象的属性，再使用**`对象[属性名]`**获取属性值**\n\n**for-of**用于遍历数组的元素，直接获取元素。\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\nfor(let i in obj){\n    //第一层循环获取student和teacher两个属性\n    console.log(i);//输出属性名\n    //obj[i]获取属性值，是数组，遍历数组使用for-of，虽然用for-in也行，这里都作展示\n    for(let j of obj[i]){\n        console.log(`${j.name}:${j.age}`);\n    }\n    // for(let j in obj[i]){\n    //     console.log(`${obj[i][j].name}:${obj[i][j].age}`);\n    // }\n}\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\n**2、`Object.keys`返回对象自身属性名组成的数组，`Object.values`返回对象自身属性值组成的数组**\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\n\nObject.keys(obj).forEach((key) => {\n    console.log(key);//输出属性名\n    obj[key].forEach((key) => {\n        console.log(`${key.name}:${key.age}`);\n    })\n})\n\nObject.values(obj).forEach((value) => {\n    value.forEach((key) => {\n        console.log(`${key.name}:${key.age}`);\n    })\n})\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n\nchuckle:19\nqx:18\n张三:37\n李四:35\n```\n\n**3、`Object.entries()`返回Object.keys与Object.values的结合体，一个嵌套的数组，数组内包括了属性名与属性值，下标0存储属性名**\n\n```js\nvar obj = {\n  student: [\n    { name: \"chuckle\", age: 19 },\n    { name: \"qx\", age: 18 },\n  ],\n  teacher: [\n    { name: \"张三\", age: 37 },\n    { name: \"李四\", age: 35 }\n  ]\n};\n\nObject.entries(obj).forEach((item)=>{\n    console.log(item[0]);//输出属性名\n    //属性值仍是数组，接着遍历，数组中存着对象，直接去访问对象的属性拿到属性值输出\n    item[1].forEach((item)=>{\n         console.log(`${item.name}:${item.age}`);\n    })\n})\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\n**4、`Object.getOwnPropertyNames()`与Object.keys差不多**，不同的是会返回对象的所有属性，包括了不可枚举属性，如数组对象的length\n\n**5、`Object.getOwnPropertySymbols()`返回对象内的所有Symbol属性的数组**，对象初始化的时候，内部不包含任何Symbol属性\n\n## 对象访问器\nJS提供了Getter（**get**关键字）和 Setter（**set**关键字） 来定义对象访问器（属性访问器）\n\n```js\nvar obj = {\n    name: 'chuckle',\n    age: 19,\n    get getAge() {\n        return this.age;\n    },\n    set setAge(age) {\n        this.age = age;\n    }\n}\nconsole.log(obj.getAge);// 19\nobj.setAge = 20;\nconsole.log(obj.getAge);// 20\n\n```\n\n使用 getter 和 setter 可以确保更好的**数据质量**，一些会随时间而变等的属性（如年龄），实际无需静态地存储在对象中，且可以对数据进行加工处理，类似数据库中的视图的功能\n\n```js\nvar obj = {\n    name: 'chuckle',\n    birthYear: 2003,\n    get age() {\n//年龄不适合直接存储在对象中，我们可以存储生日，而年龄属性则作为一个getter进行处理后再返回\n        return  new Date().getFullYear() - this.birthYear;\n    },\n//如果去修改年龄，实际上应该修改birth出生年份\n    set age(age) {\n        this.birthYear = new Date().getFullYear() - age;\n    }\n}\nconsole.log(obj.age);// 20，对象中实际上没有age\nobj.age = 19;\nconsole.log(obj.age);// 19\nconsole.log(obj.birthYear);// 2004\n\n```\n\n# Object对象\nJavaScript中的对象其实就是一组数据和功能的集合。\n\n**Object对象**是所有对象的祖宗，其他对象都继承自Object，即其它对象都是Object的实例\n\n每个Object类型的实例**共有的属性和实例方法**（定义在Object原型对象Object.prototype上的方法。可以被Object实例直接使用）：\n1. **constructor：**保存用于创建当前对象的构造函数。\n2. **\\_\\_proto\\_\\_：**隐式原型，指向的Object原型对象（父对象，所有类型的对象都有这个属性）\n3. **`hasOwnProperty()`：**检测实例中是否有指定属性。\n4. **`isPrototypeOf()`：**判断传入的对象是否是当前对象的原型\n5. **`propertyIsEnumerble()`：**检查指定属性能否使用for-in来枚举遍历\n6. **`toLocaleString()`：**返回对象的字符串表示\n7. **`toString()`：**返回对象的字符串表示\n8. **`valueOf()`：**返回对象的字符串，数值，或布尔表示。通常和toString() 返回的值相同。\n   \n**静态方法：**直接定义在Object对象的方法，`Object.`直接调用\n\n**控制对象状态的方法：**\n1. **`preventExtensions()`：**防止对象扩展\n2. **`isExtensible()`：**判断对象是否可扩展\n3. **`seal()`：**禁止对象配置\n4. **`isSealed()`：**判断一个对象是否可配置\n5. **`freeze()`：**冻结一个对象\n6. **`isFrozen()`：**判断一个对象是否被冻结\n\n**对象属性模型的相关方法**\n1. **`keys()`：**返回对象自身属性名组成的数组\n2. **`getOwnPropertyNames()`：**与keys()差不多，但返回对象所有属性的数组，包括了不可枚举属性，如数组对象的length\n3. **`getOwnPropertyDescriptor()`：**获取某个属性的描述对象，参数(对象,属性名的字符串)\n4. **`defineProperty()`：**通过描述对象，定义或修改某个属性。给对象添加一个属性并指定该属性的配置\n5. **`defineProperties()`：**通过描述对象，定义多个属性。\n6. **`hasOwn()`：**判断是否为自身的属性\n\n**原型链相关方法**\n1. **`is()`：**比较两个值是否严格相等，严格比较\n2. **`create()`：**指定原型对象和属性，返回一个新的对象\n3. **`values()`：**返回对象自身属性值组成的数组\n4. **`entries()`：**返回一个数组，元素是对象自身的（不含继承的）所有可遍历属性的键值对数组\n5. **`fromEntries()`：**将一个键值对数组转为对象。\n6. **`assign()`：**对象的合并，复制一个或者多个对象来创建一个对象，浅拷贝，将源对象的所有可枚举的自身属性，复制到目标对象\n7. **`getPrototypeOf()`：**获取对象的原型对象(Prototype对象)\n8. **`setPrototypeOf()`：**设置对象的原型对象\n\n`Object.keys(obj).length`获取对象的长度\n\n`Object.prototype.toString.call()`可以在任意值(对象)上调用这个方法，以判断这个值的类型\n\n```js\n//[object Number]第一个值代表是对象，第二个值表示该值的构造函数即类型\nObject.prototype.toString.call(2); // \"[object Number]\"\nObject.prototype.toString.call(\"\"); // \"[object String]\"\nObject.prototype.toString.call(true); // \"[object Boolean]\"\nObject.prototype.toString.call(undefined); // \"[object Undefined]\"\nObject.prototype.toString.call(null); // \"[object Null]\"\nObject.prototype.toString.call(Math); // \"[object Math]\"\nObject.prototype.toString.call({}); // \"[object Object]\"\nObject.prototype.toString.call([]); // \"[object Array]\"\n\n```\n\n# JSON\n**JSON**（JavaScript Object Notation），即JavaScript对象表示法，它是一种**数据交换的文本格式**，使用JS语法来描述数据对象，而不是一种编程语言。\n\n大多数语言都支持对json的解析。JS中可以原生地把json转为object对象。\n\n**数据结构：**Object、Array\n**基本类型：**string，number，true，false，null(json无法表示undefined)\n\n```json\n{}//这是一个json\nnull//也可是一个json\n1//也可是一个json\n//下面也是一个json\n[\n    {},\n    {}\n]\n\n{ \n\t\"name\":\"chuckle\", \n\t\"age\":\"19\" \n}\n\n//一个常见的json\n{\n  \"student\": [\n    { \"name\": \"chuckle\", \"age\": 19 },\n    { \"name\": \"qx\", \"age\": 18 },\n  ],\n  \"teacher\": [\n    { \"name\": \"张三\", \"age\": 37 },\n    { \"name\": \"李四\", \"age\": 35 }\n  ]\n}\n\n```\n\n对象和 json 没有长度，json.length 的打印结果是 undefined\n\n**使用for-in遍历json：**\n\n```js\n//将json存在变量中\nvar json = {\n  \"student\": [\n    { \"name\": \"chuckle\", \"age\": 19 },\n    { \"name\": \"qx\", \"age\": 18 },\n  ],\n  \"teacher\": [\n    { \"name\": \"张三\", \"age\": 37 },\n    { \"name\": \"李四\", \"age\": 35 }\n  ]\n};\n\nfor (let i in json) {\n    console.log(i);\n    for(let j in json[i]){\n        console.log(`${json[i][j].name}:${json[i][j].age}`);\n    }\n}\n\n```\n\n```md 输出\nstudent\nchuckle:19\nqx:18\nteacher\n张三:37\n李四:35\n```\n\nfor-in获取json对象的**属性**：\n\n```js\nvar json = { \"name\":\"chuckle\", \"age\":19 };\nfor (i in json) {\n    console.log(i);\n}\n// name\n// age\n```\n\nfor-in获取json对象的**属性的值**：\n\n```js\nvar json = { \"name\":\"chuckle\", \"age\":19 };\nfor (i in json) {\n    console.log(json[i]);\n}\n// chuckle\n// 19\n```\n\n前端收到的api通常也是json格式，如一言api：\n\n```json\n{\n    \"code\": 200,\n    \"type\": \"一言\",\n    \"content\": \"总觉得跟你在一起，不管多高的地方都可以到达。\"\n}\n\n```\n\n**`JSON.parse()`** 将数据转换为 JavaScript 对象\n**`JSON.stringify()`** 将 JavaScript 对象转换为字符串\n\n# Map对象\nMap对象保存键值对，元素会保持其插入时的顺序。\n\nMap的键可以是任意数据类型，包括函数、对象或任意基本类型。\n\n在需要进行很多新增操作，且需要储存许多数据的时候，使用 Map 会更高效\n\n```js 创建一个Map\nvar m = new Map();\n//或传入一个嵌套数组\nm = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n```\n\nObject与Map增删改查基本操作。\n\n```js\nvar o = {};\nvar m = new Map();\n//添加\no.x = 1;\nm.set('x', 1);\n//修改\no.x = 2;\nm.set('x', 2);\n//递增\no.x++;\nm.set('x', m.get('x')+1);\n//获取\no.x;\nm.get('x');\n//删除\ndelete o.x;\nmap.delete('x');\n\n```\n\nMap的键值对个数可以通过size属性获取\n\n```js\nvar m = new Map();\nm.set('x', 1);\nm.set('y', 2);\nconsole.log(m);//Map(2) {'x' => 1, 'y' => 2}\nconsole.log(m.size);//2\n```\n\n## Map的方法\n**基本方法：**\n1. **`get()`：**获取元素\n2. **`set()`：**设置元素\n3. **`has()`：**检查是否有指定key\n4. **`clear()`：**清空map\n5. **`delete()`：**删除指定元素\n\n**遍历方法：**\n1. **`keys()`：**提取键并返回**键**的迭代器MapIterator对象\n2. **`values()`：**提取值并返回**值**的迭代器MapIterator对象\n3. **`entries()`：**提取键值对并返回取**键值对**的迭代器MapIterator对象\n4. **`forEach()`：**传入回调函数(value, key)=>{}\n\n```js\nvar m = new Map([\n    ['x', 1],\n    ['y', 2]\n]);\n\nconsole.log(m.keys());//MapIterator {'x', 'y'}\nconsole.log(m.values());// MapIterator {1, 2}\nconsole.log(m.entries());// MapIterator {'x' => 1, 'y' => 2}\n\n//迭代器可以用for-of遍历\nfor (let [key, value] of m.entries()) {\n    console.log(key, value);//x 1, y 2\n}\n\nm.forEach((value, key) => {\n    console.log(key, value);//x 1, y 2\n})\n\n```\n\n# Set对象\n**Set**是**唯一值**的集合，与map类似，map存放的是键值对，而set只存放唯一值。\n\n**创建set对象：**\n\n```js\nvar s = new Set();\nvar s = new Set([1,2,3]);\n```\n\nset对象与数组也很像，可以互相转换\n\n```js\nvar arr1 = [1, 2, 3];\nvar s = new Set(arr1);//数组转为set对象，会去重\nvar arr2 = [...s];//set对象转为数组\n```\n\n可利用set值唯一的特性做**数组去重、并集、交集、差集**操作\n\n```js\n//1、去重\nvar s = new Set([1,2,3,3,2,1]);\nvar arr = [...s];//[1,2,3]\n\n//2、并集\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s = new Set([...arr1, ...arr2]); // {1, 2, 3, 4}\nvar arr = [...s];// [1,2,3,4]\n\n//3、交集，arr1和arr2共有的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => s2.has(x));//[2, 3]\n\n//4、差集,arr1去除arr2中的元素\nvar arr1 = [1, 2, 3];\nvar arr2 = [2, 3, 4];\nvar s1 = new Set(arr1);//把数组转为set对象方便操作\nvar s2 = new Set(arr2);\nvar result = arr1.filter(x => !s2.has(x));//[1]\n\n```\n\nSet值个数可以通过size属性获取\n\n```js\nvar s = new Set([1,2,3]);\nconsole.log(s);//Set(3) {1, 2, 3}\nconsole.log(s.size);//3\n```\n\n## Set的方法\n1. **`add()`：**添加新元素\n2. **`delete()`：**删除指定元素\n3. **`clear()`：**清空所有元素\n4. **`has()`：**判断是否存在某值\n5. **`forEach()`：**遍历每个元素，传入回调函数\n6. **`keys()`：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n7. **`values()`：**同keys()\n8. **`entries()`：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n**add()、delete()、clear()、has() ：**\n\n```js\nvar s = new Set([1,2,3]);\ns.add(4);\nconsole.log(s);//Set(4) {1, 2, 3, 4}\ns.delete(2);\ns.has(2);//false\ns.clear();\nconsole.log(s.size);// 0\n\n```\n\n**keys()、values() ：**返回一个 Iterator 对象，这个对象以插入Set 对象的顺序包含了原 Set 对象里的每个元素\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.values();\nconsole.log(setIter);//SetIterator {1, 2, 3}\nconsole.log(setIter.next().value); // 1\nconsole.log(setIter.next().value); // 2\nconsole.log(setIter.next().value); // 3\n```\n\n**entries() ：**返回 [value, value] 形式的数组迭代器对象，value 是给定集合中的每个元素，迭代器对象元素的顺序即集合对象中元素插入的顺序\n\n```js\nvar s = new Set([1,2,3]);\nvar setIter = s.entries();\nconsole.log(setIter);//SetIterator {1 => 1, 2 => 2, 3 => 3}\nconsole.log(setIter.next().value); // [1, 1]\nconsole.log(setIter.next().value); // [2, 2]\nconsole.log(setIter.next().value); // [3, 3]\n```\n\n**forEach() ：**遍历每个元素，传入回调函数，参数：回调函数、thisArg执行回调函数时可以当作this来使用。\n回调函数参数：值（key）、值（value）、set对象\n\n```js\nvar s = new Set([1,2,3]);\ns.forEach((key,value,set)=>{\n    console.log(key,value);//1 1, 2 2, 3 3\n});\n```\n\n# 浅拷贝和深拷贝\n**浅拷贝：**只拷贝最外面一层的数据；更深层次的对象，只拷贝引用，浅拷贝的时候，是属于传址，而非传值。\n**深拷贝：**拷贝多层数据；每一层级别的数据都会拷贝，深拷贝会把对象里所有的数据重新复制到新的内存空间，是最彻底的拷贝。\n\n**区分深拷贝与浅拷贝：**B复制了A，修改A，B也一样被修改是浅拷贝，B没变，是深拷贝。\n\n```js 浅拷贝举例\nvar a = [0,1,2,3];\nvar b = a;// 浅拷贝，传地址\nconsole.log(a===b);// 指向地址相同，true\na[0]=1;// 修改a\nconsole.log(b[0]);// 1，b也改变\n```\n\n通过`Object.assign()`实现浅拷贝:\n\n```js\nvar obj1 = {\n    name: 'chuckle',\n    age: 19\n};\nvar obj2 = Object.assign(obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19}\nobj2.name = \"qx\";\nconsole.log(obj1.name);//qx,修改obj2，obj1也会被修改\n\n```\n\n## 实现深拷贝\n\n**通过`for-in`递归实现深拷贝**，即递归遍历整个对象，找到简单值，将值复制\n\n```js\nvar obj1 = {\n    name: 'chuckle',\n    age: 19,\n    test: [1, 2, 3],\n    obj: {\n        name: 'giggles',\n        age: 18\n    }\n};\nvar obj2 = {};\n\ndeepCopy(obj2,obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19, test: Array(3), obj: {…}}\n//修改obj2，不影响原来的obj1\nobj2.name = 'qx';\nconsole.log(obj1.name);//'chuckle'\nconsole.log(obj2.name);//'qx'\n\nfunction deepCopy(newObj, oldObj) {\n    //遍历属性名或数组下标\n    for (let key in oldObj) {\n        // 获取属性值 oldObj[key]\n        let item = oldObj[key];//依次获取属性值\n        //下面进行创建属性与属性值的复制\n        if (item instanceof Array) {\n            // 判断这个值是否是数组\n            newObj[key] = [];\n            deepCopy(newObj[key], item);//递归\n        } else if (item instanceof Object) {\n            // 判断这个值是否是对象\n            newObj[key] = {};\n            deepCopy(newObj[key], item);//递归\n        } else {\n            // 简单数据类型，直接赋值\n            newObj[key] = item;\n        }\n    }\n}\n\n```\n\n通过JSON对象的**parse**和**stringify**方法实现**深拷贝**\n\n```js\nfunction deepClone(obj){\n    let str = JSON.stringify(obj);//将对象转为字符串这个基本类型\n    return JSON.parse(str);//再将字符串转为新对象，新对象与原对象就没有关系了\n}    \nvar obj1 = {\n    name: 'chuckle',\n    age: 19,\n    test: [1, 2, 3],\n    obj: {\n        name: 'giggles',\n        age: 18\n    }\n};\nvar obj2 = deepClone(obj1);\nconsole.log(obj2);//{name: 'chuckle', age: 19, test: Array(3), obj: {…}}\n//修改obj2，不影响原来的obj1\nobj2.name = 'qx';\nconsole.log(obj1.name);//'chuckle'\nconsole.log(obj2.name);//'qx'\n\n```\n\n数组等对象的`slice()`不是完全的**深拷贝**，因为数组中存的是对象的引用地址，slice()只将地址拷贝了过去\n\n```js\nvar a = [0, 1, [1, 1, 1], 2, 3];\nvar b = a.slice();\n//修改b的第一层不影响a\nconsole.log(a[0]);// 0\nb[0] = 9;\nconsole.log(a[0]);// 0\nconsole.log(b[0]);// 9\n//修改嵌套的多层数组有影响\nconsole.log(a[2][0]);// 1\nb[2][0] = 0;\nconsole.log(a[2][0]);// 0\nconsole.log(b[2][0]);// 0\n\n```\n\n# 迭代器Iterator\n迭代以从一个数据集中按照一定的顺序，不断取出数据的过程。\n\n**迭代与遍历的区别：**\n1. 迭代强调依次取数据的过程，不保证把所有的数据都取完\n2. 遍历强调的是要把所有的数据依次全部取出\n\n迭代器是能调用`next()`实现迭代的一种对象，该方法返回一个具有两个属性的对象（value：可迭代对象迭代至此的值，done：布尔，是否已经取出所有数据）\n\n通过可迭代对象中的迭代器工厂函数`Symbol.iterator`来生成迭代器。每次生存的迭代器之间互不干扰。\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nconsole.log(arrIter);// Array Iterator {}\nwhile(true){\n var next = arrIter.next();\n var value = next.value;\n var done = next.done;\n if(done){\n    break;\n }else{\n    console.log(value);// 1 2 3 4\n }\n}\n\n```\n\n迭代器对象可作为可迭代对象，**for-of**遍历可迭代对象\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nfor (let i of arrIter) {\n    console.log(i);// 1 2 3 4\n}\n```\n\n如果可迭代对象在迭代期间被修改了，迭代器得到的结果也是修改后的。\n\n```js\nvar arr = [1, 2, 3, 4];\nvar arrIter = arr[Symbol.iterator]();\nfor (let i of arrIter) {\n    arr[2] = 0;\n    console.log(i);// 1 2 0 4\n}\n```\n\n当迭代到 **done: true** 时迭代器会处于一种完成但并不完成的状态，还能重复调用 next()，结果都是 **{ value: undefined, done: true }**\n\n# 正则表达式\n**正则表达式：**用某种模式去匹配一类字符串的公式，[正则表达式在线测试](https://c.runoob.com/front-end/854/)\n\n**正则表达式主体和修饰符：**\n\n```md 修饰符，修饰符用于执行区分大小写和全局匹配，顺序：/gim\ni：不区分大小写的匹配\ng：全局匹配（匹配所有匹配而非在找到第一个匹配后停止）\nm：多行匹配\n```\n\n```md 方括号 和 | ，表示或，匹配某个范围内的字符\n[abc] 匹配方括号之间的任何字符\n[^abc] 任何不在方括号之间的字符\n[0-9] 匹配 0 到 9 的数字。\n[a-z] 匹配从小写 a 到小写 z 的字符\n(aa|bb|cc) 匹配aa或bb或cc\n```\n\n```md 元字符，拥有特殊含义的字符\n.(点号) 匹配单个字符，除了换行和行结束符\n\\w 匹配数字、字母及下划线。\n\\W 匹配非单词字符\n\\d 匹配数字\n\\D 匹配非数字字符\n\\s 匹配空白字符\n\\S 匹配非空白字符\n\\b 匹配单词边界\n\\B 匹配非单词边界\n\n```\n\n```md 特殊转义符\n\\n 匹配换行符 \n\\r 匹配回车符 \n\\t 匹配制表符 \n\\f 匹配换页符 \n\\v 匹配垂直制表符 \n\\0 匹配null字符\n\\\\ 匹配\\\n\\\" 匹配 \"\n\\' 匹配 '\n\\xxx 匹配以八进制数 xxx 规定的字符\n\\xdd 匹配以十六进制数 dd 规定的字符\n\\uxxxx 匹配以十六进制数 xxxx 规定的 Unicode 字符\n\n```\n\n```md 量词，限定符，定位符\n+ 重复1次或更多次\n* 重复任意次数\n{n} 重复n次\n{n,} 重复n次或更多次（最少n次)\n{n,m} 重复n到m次\n^ 限定开始位置的字符\n$ 限定结尾位置的字符，如果在正则表达式中同时使用^和$符号，则要求字符串必须完全符合正则表达式\n? 非贪婪模式，找到到第一个就不再往后匹配，正则默认贪婪匹配，在同一个匹配项中，尽量匹配更多所搜索的字符\n?=n 匹配其后有紧接指定字符串 n 的字符串\n?!n 匹配其后没有紧接指定字符串 n 的字符串\n?<=n 找到n但不匹配n\n\n```\n\n## RegExp对象\n\n在js中，正则表达式也是对象，**RegExp**是一个预定义了属性和方法的正则表达式对象\n\n```js\nvar re = /正则表达式主体/修饰符(可选);// re = /Hello/g\nvar re = new RegExp(\"正则表达式\"); // 参数是字符串\nvar re = new RegExp(\"正则表达式\", \"匹配模式\"); // 两个参数都是字符串\n```\n\n**RegExp对象的属性和方法：**\n1. **global：**\t判断是否设置了 \"g\" 修饰符\n2. **ignoreCase：**判断是否设置了 \"i\" 修饰符\n3. **multiline：**判断是否设置了 \"m\" 修饰符\n4. **lastIndex：**规定下次匹配的起始位置\n5. **source：**返回正则表达式的匹配模式\n6. **`test()`：**判断指定字符串是否符合正则规则，返回布尔\n7. **`exec()`：**返回一个数组，存放正则匹配的结果。无匹配返回 null\n8. **`toString()`：**返回正则表达式的字符串。\n\n\n`exec()`在 regexp 的属性 lastIndex 指定的字符处开始检索字符串，当它找到了与表达式相匹配的文本时，在匹配之后，它将把 regexp 的 lastIndex 属性设置为匹配文本后的第一个字符所在位置（调用test()也会改变lastIndex），可以通过反复地调用 exec() 方法来遍历字符串中的所有匹配文本，当 exec() 再也找不到匹配的文本时，它将返回 null，并且把属性 lastIndex 重置为 0\n\n**返回值：**匹配到的文本的数组，数组有四个属性，index 匹配文本第一个字符的位置，input 需匹配的原字符串，groups 当初中命名的分组时匹配到的分组对象\n\n```js\nvar str=\"Hello world! Hello china!\";\nvar re = /hello/gi;\nconsole.log(re.lastIndex);// 0\nconsole.log(re.test(str));// true\nconsole.log(re.lastIndex);// 5\nconsole.log(re.exec(str));// true\n//['Hello', index: 13, input: 'Hello world! Hello china!', groups: undefined]\nconsole.log(re.lastIndex);// 18\n\n```\n\n检查一个字符串是否是一个合法手机号\n\n以1开头（^1 表示1开头）\n第二位是3~9之间任意数字[3-9]\n三位以后任意9位数字[0-9]{9}重复9次的0-9\n\n```js\nvar str = \"15123456789\";\nvar re = /^1[3-9][0-9]{9}$/;\nconsole.log(re.test(str));// true\n```\n\n判断字符串是否为电子邮件\n\n```js\nvar str = \"916017604@qq.com\"\nvar re = /^\\w{3,}(\\.\\w+)*@[A-z0-9]+(\\.[A-z]{2,5}){1,2}$/\nconsole.log(re.test(str));// true\n```\n\n**支持正则表达式的 String 对象的方法：**\n1. **`search()`** 使用表达式来搜索匹配，然后返回匹配的位置\n2. **`replace()`** 返回模式被替换处修改后的字符串，不改变原字符串，返回替换后的字符串\n3. **`match()`** 返回匹配到的字符串的数组\n\n```js\nvar str = \"你好世界\"; \nvar n = str.match(/你好/);\nconsole.log(n[0]);// 你好\nconsole.log(str.replace(/世界/, '太阳系'));// 你好太阳系\n```\n\n```js 提取电话号码\nvar str = \"我的电话号码是15123456789\"; \nvar n = str.match(/1[3-9][0-9]{9}/);\nconsole.log(n[0]);// 15123456789\n```\n\n```js 替换url内的域名\nvar str = \"http://127.0.0.1:4000/\"; \nvar re = /(?<=(http|https):\\/\\/).+?(?=\\/)/g;\nvar n = str.replace(re, 'www.qcqx.cn');\nconsole.log(n);// http://www.qcqx.cn/\n```\n\n# 原型与原型链\n**省流：**\n原型其实就是一个对象，实例继承原型对象的属性，通过继承的这种方式，new出来的实例也有了这个属性\n\n对象的构造函数有一个 **prototype** 的属性，通过这个属性就能访问到原型\n\n对象有一个 **\\_\\_proto\\_\\_** 属性，指向构造函数的 **prototype** 的属性，所以也可以访问到原型\n\n构造函数也有 **\\_\\_proto\\_\\_** 属性，也是对象，因为所有函数都是 Function 构造的，所以都等于 Function.prototype\n\n原型也是对象，也有 **\\_\\_proto\\_\\_** 属性，通常浏览器称之为 **[[Prototype]]** ，它指向原型的原型，像单链表的next指针一样，构成原型链，直到Object构造函数，因为 Object 对象的原型 Object.prototype.__proto__ 为空null没有下一个原型了，Object.prototype是原型的终点\n\n原型与原型链其实是为了实现继承，原型就像java中的类，由构造函数构造的对象都继承了这个构造函数原型的属性和方法，当然，每个对象后续都可以添加自己的属性和方法来覆盖继承自原型的属性和方法。\n\n原型链中每个节点是构造函数的原型，每个节点有一个循环：构造函数的 prototype 属性指向它的原型，原型的 constructor 属性指向它的构造函数\n\n普通对象也可以利用 Object.create() 作为新生成对象的原型。\n\n## 原型\n每个 JS 对象一定对应一个原型对象，并从这个原型对象继承属性和方法。\n\n**对象**只有隐式原型 **\\_\\_proto\\_\\_**\n**函数**有隐式原型 **\\_\\_proto\\_\\_** ，还有显式原型 **prototype**\n\n**对象**的 **\\_\\_proto\\_\\_** 指向 **其构造函数.prototype**，或者说 **对象.\\_\\_proto\\_\\_** 等于 **其构造函数.prototype** 保存的东西是一样的\n**函数**的 **\\_\\_proto\\_\\_** 都指向**Function.prototype**，因为所有函数都是由Function构造的，值为 ƒ(){[native code]}\n\n**函数**的 **prototype** 指向一个对象，就是通常所说的原型对象，一定有两个属性，**constructor** 指向构造函数本身，**[[Prototype]]**就是\\_\\_proto\\_\\_，它连接起一个个原型，构成**原型链**，Object 对象的原型 Object.prototype.__proto__ 为空null\n\n**两种获取对象隐式原型的方式：**对象的**\\_\\_proto\\_\\_** 属性（非标准），`Object.getPrototypeOf()`方法(标准)\n**获取显式原型：**构造函数.prototype\n\n```js\nvar obj = new Object();\nconsole.log(obj.__proto__);\nconsole.log(Object.getPrototypeOf(obj));\n//{constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n//    constructor: ƒ Object()\n//    __proto__: null 原型的__proto__指向下一个原型，而Object对象的原型 Object.prototype.__proto__ 为空null\n//    原型上还有各种方法，所有Object和Object的子类都会继承这些属性和方法\n\nconsole.log(Object.__proto__);\nconsole.log(Function.prototype);\n//ƒ () { [native code] }\n\n```\n\n只有一个Object对象不够直观，新建一个构造函数，new一个Person对象\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\nconsole.log(person.__proto__);\nconsole.log(Object.getPrototypeOf(person));\n```\n\n下面的输出就是Person对象的原型，可以发现原型上并没有a属性，在构造函数中通过this直接定义实例成员，会作为实例对象的属性，而不是出现在原型上再被对象继承。\n\n```js 输出\n{constructor: ƒ}\n    constructor: ƒ Person()\n    [[Prototype]]: Object\n```\n\n这个原型上只有两个属性，我们可以在原型上添加属性和方法，所有对象都会继承这些属性和方法，哪怕是在这之前已经实例化的对象。\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\n//在原型上添加属性和方法\nObject.getPrototypeOf(person).a = 0;\nObject.getPrototypeOf(person).b = 2;\nconsole.log(Object.getPrototypeOf(person));\n```\n\n可以看到原型上出现了a属性，值为0\n\n```js 输出\n{a: 0, constructor: ƒ}\n    a: 0\n    b: 2\n    constructor: ƒ Person()\n    [[Prototype]]: Object\n```\n\n试着在实例化对象中使用继承来的a、b属性\n\n```js\nfunction Person() {\n    this.a = 1;\n}\nvar person = new Person();\n//在原型上添加属性和方法\nObject.getPrototypeOf(person).a = 0;\nObject.getPrototypeOf(person).b = 2;\n//使用继承来的a、b属性\nconsole.log(person.a);// 1\nconsole.log(person.__proto__.a);// 0\nconsole.log(person.b);// 2\n\n```\n\nperson.a 输出 1，访问的是实例成员a，也就是说对象的属性可以覆盖继承来的同名属性\n\n```js 输出\n1\n0\n2\n```\n\n再看原型中的的 constructor 属性，它指向该原型对应的构造函数，可以在控制台中展开\n\n<img src=https://cdn.chuckle.top/images/43-2.webp width=\"45%\">\n\n构成了一个循环：构造函数的 prototype 属性指向它的原型，原型的 constructor 属性指向它的构造函数\n\n## 原型链\n原型是原型链上的节点，各个原型通过 **\\_\\_proto\\_\\_** 相连接，对象可以继承原型链上从Object构造函数开始至该对象构造函数的所有原型的属性和方法，即继承了其所有父级的所有属性和方法，且逐层可以覆盖\n\n**制造原型链：**\n\n**直接操作prototype属性：**\n\n```js\nfunction Parent(){}\nfunction Child(){\n    this.a=1;\n}\nParent.prototype.b = 2;// 在原型上添加属性\nParent.c = 0;//在构造函数上添加静态成员\n// 通过原型的__proto__连接起两个原型，表示Child继承Parent\nChild.prototype.__proto__ = Parent.prototype\n// 也可以通过setPrototypeOf设置原型的原型，来连接两个原型\nObject.setPrototypeOf(Child.prototype,Parent.prototype);\n\nvar child = new Child();\n\nconsole.log(child.a);// 1,访问实例成员\nconsole.log(child.b);// 2,通过原型链继承自Parent原型上的b属性\nconsole.log(child.c);// undefined，不能通过原型链访问原型对应构造函数的静态成员\n\n```\n\n可以在控制台展开 **[[Prototype]]** 属性来查看原型链\n\n<img src=https://cdn.chuckle.top/images/43-3.webp width=\"50%\">\n\n通过 `Object.create()` 建立原型链，在Vue源码中 Object.create() 的使用频率非常高\n\n`Object.create()` 用于创建一个新对象，使用现有的对象来作为新创建对象的原型\n\n原型和普通对象都有__proto__和constructor属性，且作用都一样，利用Object.create()可以将一个普通对象作为新对象的原型\n\n```js\nfunction Parent(){\n    this.p = 0;\n}\nParent.prototype.b = 2;\nvar parent =  new Parent();\nparent.a = 1;\n\n// 使用现有的对象来作为新创建对象的原型\nvar child = Object.create(parent);\n\nconsole.log(child.b);// 2,通过原型链继承自Parent原型上的b属性\nconsole.log(child.p);// 0\nconsole.log(child.a);// 1\n\n```\n\n将原型与构造函数的循环、原型与原型的链、构造函数的实例组成一张图：\n\n<img src=https://cdn.chuckle.top/images/43-4.webp width=\"100%\">\n\n\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(2)","url":"/article/c32976c2.html","content":"\n# JS对象简介\n尽管JavaScript里没有Java，但两者都是面向对象语言，按顺序学过java这部分也是大差不差。\n\n在JavaScript中，对象是一组**无序的相关属性**和**方法**的集合。\n对象中的属性均是**键值对**，属性名是键，属性值是值。\n\n**new**关键字可以创建对象的实例。\n\n```js\nvar chuckle = ['轻笑', 19, '男'];\n//虽然数组也是个对象，这js中是引用类型，但这样定义chuckle，值的表示不直观\n//使用对象来表示，结构会更清晰\nvar chuckle = {};//也可以new Object()来创建一个对象\nchuckle.name = '轻笑';\nchuckle.age = 19;\nchuckle.sex = '男';\n\nconsole.log(chuckle);\n//{name: '轻笑', age: 19, sex: '男'}\nconsole.log(chuckle.name);//轻笑\n```\n\n对象的属性值可以是任何的数据类型，也可以是个函数\n\n```js\nvar obj = new Object();\nobj.fun = function(){\n  console.log('这是一个函数');\n};\nconsole.log(obj.fun);//获取而不执行函数\nconsole.log(obj.fun());//执行函数,这是一个函数\n```\n\n对象的属性也可以是另一个对象\n\n```js\nvar obj1 = new Object(); obj1.inObj;\nvar obj2 = new Object(); obj2.name = \"一个对象\";\n//将整个obj2对象，设置为obj1的属性，保存的是对象的地址\nobj1.inObj = obj2;\nconsole.log(obj1.inObj);//{name: '一个对象'}\nconsole.log(obj1.inObj.name);//一个对象\n```\n\n对象变量保存的是对象的地址，当两个变量指向同一个对象时，两个变量都可以修改对象中的属性。\n\n**对象的分类**:\n1. **内置对象**: 由ES标准中定义的对象，如：Object、Math、Date、String、Array、Number、Boolean、Function等。\n2. **宿主对象**: 由JS的运行环境提供的对象，如浏览器提供了BOM、DOM，console、document。\n3. **自定义对象**: 开发者创建的对象。\n\n# 基本包装类型\n基本数据类型string无法绑定属性和方法，但将其转换为**基本包装类型**，就可以。\n\n```js\nvar str = '';\nstr.name = '一个字符串';//不会报错，但无法绑定\nconsole.log(str.name);//输出undefined\n```\n\n实际上，当我们对基本数据类型调用属性和方法(如str.length)时，js会自动将其临时转换为对应的基本包装类型（隐式类型转换），再调用内置方法。\n\n**基本包装类型**包括：**Number**、**Boolean**、**String**，它们都属于引用数据类型，可以绑定属性和方法。\n\n```js\nvar strObj = new String('');\nstrObj.name = '一个字符串';\nconsole.log(strObj.name);//一个字符串\n```\n\n1. `String()`：将基本数据类型字符串，转换为 String 对象。\n2. `Number()`：将基本数据类型的数字，转换为 Number 对象。\n3. `Boolean()`：将基本数据类型的布尔值，转换为 Boolean 对象。\n\n**注意**，在实际应用中一般不会使用基本数据类型的对象\n\n在底层，字符串以字符数组的形式保存\n\n```js\nvar str = 'chuckle';//保存方式[\"c\", \"h\", \"u\", \"c\", \"k\", \"l\", \"e\"]\nconsole.log(str.length);//7\nconsole.log(str[2]); //因为是数组，可以直接访问下标，字符串中的第3个字符,u\n```\n\n# 内置对象\n**内置对象**是语言自带的一些对象，提供了最基本最常用的**属性**和**方法**。\n\n**Arguments**(函数参数集合)，**Array**(数组)，**Boolean**(布尔对象)，**Math**(数学对象)，**Date**(日期时间)，**Error**(异常对象)，**Function**(函数构造器)，**Number**(数值对象)，**Object**(基础对象)，**RegExp**(正则表达式对象)，**String**(字符串对象)\n\n# 字符串对象String\n[String字符串--JavaScript基础笔记(1)](/article/3f7cd15d.html#String字符串)\n\n**字符串的所有方法，都不会改变原字符串**\n\n1. `indexOf()/lastIndexOf()`：获取字符串中指定内容的索引\n2. `search()`：获取字符串中指定内容的索引（参数里一般是正则）\n3. `includes()`：字符串中是否包含指定的内容\n4. `startsWith()`：字符串是否以指定的内容开头\n5. `endsWith()`：字符串是否以指定的内容结尾\n6. `charAt()`和`str[index]`：返回字符串指定位置(下标)的字符\n7. `charCodeAt(index)`：返回字符串指定位置的字符的 Unicode 编码\n8. `slice()`：截取指定范围的字符串，可传入负值，代表倒数第几个字符（截取时包括该字符）\n9. `substring()`：截取指定范围的字符串**，**不可**传入负值，传入负值转为0，自动调整参数的位置，如果第二个参数小于第一个，则自动交换\n10. `substr()`：从起始位置截取指定长度的字符串**，两个参数，起始位置，**截取指定长度**\n11. `String.fromCharCode()`：据字符的 Unicode 编码获取字符\n12. `concat()`：拼接两个字符串，不如直接用+号\n13. `split()`：字符串转换为数组 【重要】\n14. `replace()`：替换字符串内容\n15. `repeat()`：重复该字符串指定次数\n16. `toUpperCase()` 和 `toLowerCase()`：大小写转换\n17. `trim()`：去除字符串头尾的空格\n\n## 查找字符\n**1、`indexOf()/lastIndexOf()`：获取字符串中指定内容的索引**\n\n`indexOf()`从前向后查找，`lastIndexOf()`从后向前，用法一致。\n\n**功能**：检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其**第一次出现**的字符串底层数组下标（0代表在开头）；如果没有找到指定的内容，则返回 -1。\n\n```js\nvar str = 'abc cba';\nconsole.log(str.indexOf('c'));//2\nconsole.log(str.lastIndexOf('c'));//4\n\nconsole.log(str.indexOf('a'));//0\nconsole.log(str.lastIndexOf('a'));//6\n```\n\n```js\nvar str = 'chuckle';\nconsole.log(str.indexOf('uc'));//2,代表uc第一个字符u是字符串中第三个字符\n```\n\n添加起始位置参数，指定查找的起始位置\n\n```js\nvar str = 'chuckle';\nconsole.log(str.indexOf('uc',2));//从下标2即字符串第三个字符开始找起，输出2\nconsole.log(str.indexOf('uc',3));//从下标3即字符串第四个字符开始找起，输出-1\n```\n\n**案例**：查找字符串\"abcabcabc\"中，所有 a 出现的位置以及次数\n\n```js\nvar str = \"abcabcabc\";\nvar num = 0;//记录次数\nvar index = -1;//记录位置下标，从-1开始\ndo{\n  index = str.indexOf('a', index + 1);//找到一个就从下一个字符下标开始找\n  if(index !== -1){\n    console.log(index);//输出下标0,3,6\n  }\n}while(index !== -1);//找到了就接着去找，直到找不到\n```\n\n**2、`search()`：获取字符串中指定内容的索引（参数里一般是正则）**\n\n**功能**：检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其**第一次出现**的字符串底层数组下标（0代表在开头）；如果没有找到指定的内容，则返回 -1。\n\n```js\nvar str = 'CHUCKLE';\nconsole.log(str.search('uc')); //-1\nconsole.log(str.search(/uc/i)); //2 正则写法，忽略大小写\n```\n\n**3、`includes()`：字符串中是否包含指定的内容**\n\n**功能**：判断字符串中是否含有指定内容。有返回 true；否则返回 false。可以传入起始位置参数。\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.includes('uc')); //true\nconsole.log(str.includes('ab')); //false\nconsole.log(str.includes('ab',5)); //false\n```\n\n**4、`startsWith()`：字符串是否以指定的内容开头**\n\n**功能**：判断字符串是否以指定的字符串开头。是返回 true；否则返回 false。可以指定起始位置下标，指定的位置则当做字符串开头。\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.startsWith('uc')); //false\nconsole.log(str.startsWith('c')); //true\nconsole.log(str.startsWith('uc',2)); //true\n```\n\n**5、`endsWith()`：字符串是否以指定的内容结尾**\n\n**功能**：判断字符串是否以指定的字符串结尾。是返回 true；否则返回 false。可以指定检索的字符串长度（检索到第几个字符）。\n\n```js\nvar str = \"chuckle\"\nconsole.log(str.endsWith('uc')); //false\nconsole.log(str.endsWith('e')); //true\nconsole.log(str.endsWith('uc',4)); //true\n```\n\n## 获取指定位置的字符\n**1、`charAt()`和`str[index]`：返回字符串指定位置(下标)的字符**\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.charAt(2));//u\nconsole.log(str[2]);//u\n```\n\n**2、`charCodeAt(index)`：返回字符串指定位置的字符的 Unicode 编码**\n\n```js 判断字符串中是否有非英文字符\nvar str = \"chuckle轻笑\";\nfor(let i = 0; i < str.length; i++){\n  let char = str.charCodeAt(i);//保存该字符的Unicode编码\n  if(!(char >= 0 && char <= 127)){//英文字符的Unicode编码在0~127\n    console.log(`存在非英文,在第${i+1}个字符`);//存在非英文,在第8个字符,存在非英文,在第9个字符\n  }\n}\n```\n\n## 字符串截取\n**1、`slice()`：截取指定范围的字符串**，可传入负值，代表倒数第几个字符（截取时包括该字符）\n\n```js 两个参数都是索引值。正数时包左不包右\n新字符串 = str.slice(开始索引, 结束索引);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.slice(2));//chuckle,从下标2开始截取到最后\nconsole.log(str.slice(2,str.length));//chuckle\nconsole.log(str.slice(2, -1));//chuckl,从下标2开始截取到倒数第一个字符，包括，-0无效\nconsole.log(str.slice(5, 2));//无效范围，返回空字符串\n```\n\n**2、`substring()`：截取指定范围的字符串**，**不可**传入负值，传入负值转为0，自动调整参数的位置，如果第二个参数小于第一个，则自动交换。\n\n```js 两个参数都是索引值。包左不包右\n新字符串 = str.substring(开始索引, 结束索引);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.substring(2)); //chuckle,从下标2开始截取到最后\nconsole.log(str.substring(2,str.length)); //chuckle\nconsole.log(str.substring(5, 2)); //chu，自动交换位置，相当于截取下标2到5\nconsole.log(str.substring(2, -1)); //qx，-1看作0，然后自动交换位置\n```\n\n**3、`substr()`：从起始位置截取指定长度的字符串**，两个参数，起始位置，**截取指定长度**\n\n```js\n新字符串 = str.substr(开始索引, 截取的长度);\n```\n\n```js\nvar str = \"qxchuckle\";\nconsole.log(str.substr(2)); //chuckle,从下标2开始截取到最后\nconsole.log(str.substr(2,100)); //chuckle，截取长度超过剩余长度时，只会截取剩余的字符\nconsole.log(str.substr(100, 10)); //空字符串，截取不到任何字符\n```\n\n## 其它方法\n\n**`String.fromCharCode()`：据字符的 Unicode 编码获取字符**\n\n```js\nvar a = String.fromCharCode(97);\nconsole.log(a);//a\n```\n\n**`concat()`：拼接两个字符串，不如直接用+号**，数组中也有此方法，用于两个数组的拼接，那边常用\n\n```js\nvar str1 = \"qx\";\nvar str2 = \"chuckle\";\nstr2 = str1.concat(str2);//qxchuckle\n```\n\n**`split()`：字符串转换为数组 【重要】**\n\n**功能**：通过指定的分隔符，将字符串拆分成数组，分隔符不会出现在数组中。不传入参数则将整个字符串作为数组的一个元素存入。\n\n```js\nvar str = \"qx,chuckle,轻笑\";\nconsole.log(str.split(',')); //['qx', 'chuckle', '轻笑']\nconsole.log(str.split('')); //['q', 'x', ',', 'c', 'h', 'u', 'c', 'k', 'l', 'e', ',', '轻', '笑']\nconsole.log(str.split()); //['qx,chuckle,轻笑']\n```\n\n**`replace()`：替换字符串内容**\n\n**功能**：将字符串中的指定内容，替换为一段字符串，默认只会替换第一个被匹配到的字符。如果要全局替换，需要使用正则。\n\n```js\n新的字符串 = str.replace(被替换的子串，新的子串);\n```\n\n```js\nvar str = \"生活就像海洋，只有咕噜咕噜\";\nstr = str.replace('咕噜咕噜','意志坚强的人才能到达彼岸');\nconsole.log(str);//生活就像海洋，只有意志坚强的人才能到达彼岸\n```\n\n**`repeat()`：重复该字符串指定次数**\n\n```js\nvar str = \"chuckle!\"\nstr = str.repeat(2);//重复两次\nconsole.log(str);//'chuckle!chuckle!'\n```\n\n**`trim()`：去除字符串头尾的空格**\n\n```js\nvar str = '   a   b   c   ';\nconsole.log(str);//'   a   b   c   '\nconsole.log(str.length);//15\n\nconsole.log(str.trim());//'a   b   c'\nconsole.log(str.trim().length);//9\n```\n\n**`toUpperCase()` 和 `toLowerCase()`：大小写转换**\n\n```js\nvar str = 'abcdEFG';\n//转换成小写\nconsole.log(str.toLowerCase()); //abcdefg\n//转换成大写\nconsole.log(str.toUpperCase()); //ABCDEFG\n```\n\n**html方法**：不常用，多数是拼接成模板字符串返回\n\n```js\nvar str = \"chuckle\";\nconsole.log(str.anchor('chuckle'));//<a name=\"chuckle\">chuckle</a>\nconsole.log(str.big());//<big>chuckle</big>\nconsole.log(str.sub());//<sub>chuckle</sub>\nconsole.log(str.sup());//<sup>chuckle</sup>\nconsole.log(str.link('https://www.qcqx.cn/'));//<a href=\"https://www.qcqx.cn/\">chuckle</a>\nconsole.log(str.bold());//<b>chuckle</b>\n```\n\n# 数值对象Number\n[Number数值型介绍--JavaScript基础笔记(1)](/article/3f7cd15d.html#Number数值型)\n\n1. `Number.isInteger()`：判断是否为整数\n2. `toFixed(num)`：保留小数点后num位（四舍五入），返回字符串\n\n**`Number.isInteger()`：判断是否为整数**\n\n```js\n布尔值 = Number.isInteger(数字);\n```\n\n```js\nvar a = 10;\nconsole.log(Number.isInteger(a));//true\na = -10;\nconsole.log(Number.isInteger(a));//true\na = 1.00;\nconsole.log(Number.isInteger(a));//true,虽然有小数点，但后面都是0，所以会被当做整数\na = 3.14;\nconsole.log(Number.isInteger(a));//false\n```\n\n**`toFixed(num)`：保留小数点后num位（四舍五入）**，返回字符串，将字符串转为整数可用**Number()**，详见[数据类型转换--JavaScript基础笔记(1)](/article/3f7cd15d.html#数据类型转换)\n\n```js 注意返回字符串！\n字符串 = nb.toFixed(num);\n```\n\n```js\nvar nb = 3.1415926;\nconsole.log(nb.toFixed(1));//3.1\nconsole.log(nb.toFixed(3));//3.142\nconsole.log(nb.toFixed(4));//3.1416\n```\n\n# 数学对象Math\n**Math**不是一个构造函数，无需创建对象即可直接使用其属性和方法，它是一个工具类，里面封装了数学运算相关的属性和方法。\n\n1. `Math.PI`：圆周率\n2. `Math.abs()`：获取绝对值\n3. `Math.random()`：生成0-1之间的随机浮点数，[0,1)\n4. `Math.floor()`：向下取整（往小取值）\n5. `Math.ceil()`：向上取整（往大取值）\n6. `Math.round()`：四舍五入取整（正数四舍五入，负数五舍六入）\n7. `Math.max(x, y, z)`：返回多个数中的最大值\n8. `Math.min(x, y, z)`：返回多个数中的最小值\n9.  `Math.pow(x,y)`：乘方：返回 x 的 y 次幂\n10. `Math.sqrt()`：开方：对一个数进行开方运算\n\n**`Math.abs()`：获取绝对值**，可传入字符串，自动做隐式转换。\n\n```js\nconsole.log(Math.abs(10));//10\nconsole.log(Math.abs(-10));//10\nconsole.log(Math.abs('-10'));//10\nconsole.log(Math.abs(-3.14));//3.14\nconsole.log(Math.abs('123abc'));//NaN\n```\n\n**`Math.random()`：生成0-1之间的随机浮点数，[0,1)**\n\n```js 一些技巧\n//生成 [0, x) 之间的随机整数\nMath.round(Math.random()*x);\n//生成 [x, y) 之间的随机整数\nMath.round(Math.random()*(y-x)+x)\n//生成 [x, y]之间的随机整数\nMath.floor(Math.random()*(y-x+1))+x;\n```\n\n# 时间对象Date\n**Date**用于处理日期和时间，Date是一个**构造函数**，需要**new实例化**后才能使用。\n\n**无参时获取系统时间**\n\n```js\nvar date = new Date();\nconsole.log(date);//Wed Mar 29 2023 15:08:02 GMT+0800 (中国标准时间)\nconsole.log(typeof date);//object\n```\n\n**传递参数**,意思是给时间对象Date设定一个具体的时间，基准时间为**1970年1月1日 00:00:00**，具体小时差别要看时区，东八区+8小时。\n\n```js 使用方法\nvar date = new Date(传入毫秒数（时间戳）);//表示基准时间加上这个毫秒数\n//至少要两个参数，不能缺少年，会自动进位，其余默认都是首时间\nvar date = new Date(年,月,日,时,分,秒,毫秒);//月份是0到11之间的整数值，表示从一月到十二月\n//传入时间字符串，有格式要求，星期 月 日 年 时:分:秒\nvar date = new Date(时间字符串);\n//Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)\n```\n\n```js\n//传入2000毫秒，表示基准时间过2s\nvar date = new Date(2000);//Thu Jan 01 1970 08:00:02 GMT+0800 (中国标准时间)\n//设定日期为2023年3月，传入2代表3月\nvar date = new Date(2023,2);//Wed Mar 01 2023 00:00:00 GMT+0800 (中国标准时间)\n//传入时间字符串，有格式要求，分隔符任意,可以看到，星期不对会自动修正\nvar date = new Date('Wed Apr 21 2023');//Fri Apr 21 2023 00:00:00 GMT+0800 (中国标准时间)\nvar date = new Date(\"2023/3/29 11:11:11\");//Wed Mar 29 2023 11:11:11 GMT+0800 (中国标准时间)\n```\n\n**常用方法**\n1. `getFullYear()`：获取年份\n2. `getMonth()`：获取月，0到11之间的整数值，表示从一月到十二月\n3. `getDate()`：获取日：1-31\n4. `getDay()`：获取星期：0-6，0代表星期日\n5. `getHours()`：获取小时：0-23\n6. `getMinutes()`：获取分钟：0-59\n7. `getSeconds()`：获取秒：0-59\n8. `getMilliseconds()`：获取毫秒\n9. `setFullYear()`：修改日期，参数：年,月,日,时,分,秒,毫秒。返回时间戳\n10. `toUTCString()`：将当日的日期（根据 UTC）转换为字符串\n11. `toJSON()`：将日期转为json格式\n12. `getTime()`：获取时间戳\n13. `toLocaleString()` 格式化输出 2023/4/12 09:39:49\n\n```js 举例：\nvar date = new Date(1680076326495);//Wed Mar 29 2023 15:52:06 GMT+0800 (中国标准时间)\nconsole.log(date.getFullYear());//2023\nconsole.log(date.getMonth());//2\nconsole.log(date.getDate());//29\nconsole.log(date.getDay());//3\nconsole.log(date.getHours());//15\nconsole.log(date.getMinutes());//52\nconsole.log(date.getSeconds());//6\nconsole.log(date.getMilliseconds());//495\n\n```\n\n**`toUTCString()`：将当日的日期（根据 UTC）转换为字符串**\n\n```js\nvar d = new Date();//Wed Mar 29 2023 16:11:02 GMT+0800 (中国标准时间)\nd.toUTCString()//'Wed, 29 Mar 2023 08:11:02 GMT'\n```\n\n**`setFullYear()`：修改日期，参数：年,月,日,时,分,秒,毫秒**,返回时间戳\n\n```js\nvar d = new Date(2023,0);\nvar t = d.setFullYear(2020,10);\nconsole.log(t);//1604160000000\nconsole.log(new Date(t));//Sun Nov 01 2020 00:00:00 GMT+0800 (中国标准时间)\n```\n\n**`toJSON()`：将日期转为json格式**\n\n```js\nvar d = new Date(2023,0);\nvar t = d.toJSON();\nconsole.log(t);//2022-12-31T16:00:00.000Z\n```\n\n## 获取时间戳\n\n**`getTime()`：获取时间戳**，也就是返回从基准时间至今的毫秒数(时间戳也可以是秒数，但函数返回的是毫秒数)。\n\n```js\nvar date = new Date(2023,0);\nconsole.log(date);//Sun Jan 01 2023 00:00:00 GMT+0800 (中国标准时间)\nvar time = date.getTime();//1672502400000\nvar date = new Date(time);//Sun Jan 01 2023 00:00:00 GMT+0800 (中国标准时间)\n```\n\n还有其它方法可以获取时间戳：\n\n```js\nvar time1 = +new Date();\nconsole.log(time1);//1680076996003\n\nvar time2 = new Date().getTime();\nconsole.log(time2);//1680076996003\n\nvar time3 = new Date().valueOf();\nconsole.log(time3);//1680076996003\n\nvar time4 = new Date() * 1;\nconsole.log(time4);//1680076996003\n\nvar time5 = Number(new Date());\nconsole.log(time5);//1680076996003\n\n```\n\n获取**当前时间的时间戳**可以用这种方法\n\n```js\nconsole.log(Date.now());//1680077268109\n```\n\n## 转为指定格式\n使用 `toLocaleString()` 简单格式化输出\n\n```js\nnew Date().toLocaleString();\n// 2023/4/12 09:39:49\n```\n\n也可以通过Date的**prototype属性**在原型上添加自定义的属性和方法，给Date对象添加**format()**方法，该方法封装如下：\n\n```js\nDate.prototype.format = function(fmt) { \n  var o = { \n    \"M+\" : this.getMonth()+1,                 //月份 \n    \"d+\" : this.getDate(),                    //日 \n    \"h+\" : this.getHours(),                   //小时 \n    \"m+\" : this.getMinutes(),                 //分 \n    \"s+\" : this.getSeconds(),                 //秒 \n    \"q+\" : Math.floor((this.getMonth()+3)/3), //季度 \n    \"S\"  : this.getMilliseconds()             //毫秒 \n  }; \n  if(/(y+)/.test(fmt)) {\n    fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\"\").substr(4 - RegExp.$1.length)); \n  }\n  for(var k in o) {\n    if(new RegExp(\"(\"+ k +\")\").test(fmt)){\n      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\"00\"+ o[k]).substr((\"\"+ o[k]).length)));\n    }\n  }\n  return fmt; \n}        \n\n```\n\n```js 使用案例,分隔符任意\nvar date = new Date(1680076326495);//Wed Mar 29 2023 15:52:06 GMT+0800 (中国标准时间)\nvar time = date.format(\"yyyy-MM-dd hh:mm:ss\");\nconsole.log(time);// 2023-03-29 15:52:06\ntime = date.format(\"yyyy/MM/dd\");\nconsole.log(time);// 2023/03/29\ntime = date.format(\"yyyy年MM月dd日 hh时mm分ss秒\");\nconsole.log(time);// 2023年03月29日 15时52分06秒\n\n```\n\n还可引入各种**时间库**来处理，如[momentjs](http://momentjs.cn/)、[Day.js](https://day.js.org/)\n\n# 数组对象Array\n下面是一个普通对象和数组对象：\n\n```js\nvar obj = {name: 'chuckle' , age: 19 };\nvar arr = [\"chuckle\",\"19\"];\n```\n\n普通对象使用字符串作为属性名，而数组使用**数字作为索引**，数组适合用于存储同类型的一组数据，如列表数据。\n\n数组中的元素可以是**任意的数据类型**，可以是对象、函数、数组。也可以同时存储**不同类型数据**。\n\n**1、使用字面量创建数组：**\n\n```js\nvar arr = []; // 创建空数组\narr = [1, 2, 3]; // 带初始值的数组\n```\n\n**2、使用构造函数创建数组对象：**\n\n```js\nvar arr = new Array(); // 创建空数组\narr = new Array(4); // 创建大小为4的数组，初始值都为空属性\narr = new Array(1,2,3); // 带初始值的数组\n```\n\nJS中的数组会**自动扩容**，当我们访问数组大小以外的下标时，会返回undefined，但可以直接给超过数组大小的下标赋值，并自动给扩容的下标赋空属性，但注意，**空属性不计入数组的长度 arr.length**。\n\n```js\nvar arr = [1, 2, 3];\nconsole.log(arr); // [1, 2, 3]\nconsole.log(arr.length); // 3\nconsole.log(arr[6]);// undefined\n\narr[6] = 7;\nconsole.log(arr); // [1, 2, 3, 空属性 × 3, 7]\nconsole.log(arr[4]); // undefined\nconsole.log(arr.length); // 4\n```\n\n## 解构赋值\n解构赋值是ES6中新增的一种赋值方式。可以方便地把数组中的元素按顺序赋值给其他多个变量。\n\n```js\nvar arr = [1, 2, [3,4]];\nvar [a, b, c] = arr;\nconsole.log(a);// 1\nconsole.log(b);// 2\nconsole.log(c);// [3,4]\n```\n\n先指定变量的默认值，**会被覆盖**\n\n```js\nvar arr = [1, 2, [3,4]];\nvar [a, b = 0, c = 0, d = 0] = arr;\nconsole.log(a);// 1\nconsole.log(b);// 2\nconsole.log(c);// [3,4]\nconsole.log(d);// 0,数组中无第四个元素，保持原值\n```\n\nES6中新增的**扩展运算符**`...`打包**剩余的数据**作为一个**新数组**。**打包时**扩展运算符只能写在最后。\n\n```js\nvar [a, ...b] = [1, 2, 3];\nconsole.log(a); // 1\nconsole.log(b); // [2, 3]\n```\n\n## 数组属性和方法\n`arr.length`：**数组的长度**，数组中元素的个数\n\n**数组的方法：**\n1. **类型相关方法：**\n   1. `Array.isArray()`：判断是否为数组\n   2. `toString()`：将数组转换为字符串\n   3. `join()`：将数组转换为字符串,可以指定分隔符\n   4. `Array.from()`：将**伪数组**或可遍历对象转为真数组\n   5. `Array.of(a,b,c)`：将多个值按顺序转为字符串\n   6. 字符串的方法：`split()`：将字符串按指定的分隔符，组装为数组\n2. **元素的添加和删除：**\n   1. `push()`：从数组**尾部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n   2. `pop()`：删除数组中**最后一个**元素，返回被删除的元素，**改变原数组**\n   3. `unshift()`：从数组**头部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n   4.  `shift()`：删除数组中**第一个**元素，返回被删除的元素，**改变原数组**\n   5.  `splice()`：从数组中删除**指定的**任意数量元素，返回**被删除元素**组成的新数组，**改变原数组**\n   6.  `slice()`：从数组中提取**指定的**任意数量元素，返回**新数组**，**不改变原数组**\n   7.  `concat()`：合并多个数组，返回合并后的新数组，**不改变原数组**\n   8.  `fill()`：用固定的值**填充数组**，返回新数组，**改变原数组**\n3.  **数组排序：**\n    1.  `reverse()`：反转数组，返回反转后的数组，**改变原数组**\n    2.  `sort()`：排序，元素默认按照**Unicode编码**，从小到大进行排序，**改变原数组**\n4.  **查找数组元素：**\n    1.  `indexOf()`：**从前往后**搜索数组中的元素，并返回它**首次**所在位置的索引。\n    2.  `lastIndexOf()`：**从后往前**搜索数组中的元素，并返回它**首次**所在位置的索引。\n    3.  `includes()`：判断数组是否包含一个指定的值，返回**布尔**\n    4.  `find(function())`：返回**第一个**符合传入测试（函数）条件的数组元素。\n    5.  `findIndex(function())`：返回**第一个**符合传入测试（函数）条件的数组元素的**索引**。\n    6.  `every(function())`：检测数组**所有元素**是否**都**符合指定(函数)条件，返回**布尔**\n    7.  `some(function())`：检测数组是否**存在**符合指定(函数)条件的元素，返回**布尔**\n    8.  `valueOf()`：返回数组本身，意义不大，数组名就代表该数组了\n5.  **遍历数组：**\n    1.  `for循环`遍历，大多数语言对于数组通用的遍历方法\n    2.  `forEach()`传入一个**回调函数**作为参数，它由我们创建但是不由我们调用，数组中有几个元素，该回调函数就会执行几次，没用返回值\n    3.  `for of`，ES6新增循环遍历数组方法\n    4.  `map()`，遍历数组，并对数组中的每一项进行加工。\n    5.  `filter()`：数组中的每一项运行回调函数，回调函数返回结果是**true**的项（符合条件的项），**组成新数组返回，不改变原数组**\n    6.  `reduce()`：参数是接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值返回\n\n### 类型相关方法\n**`Array.isArray()`：判断是否为数组**\n\n```js\nvar a = [];\nconsole.log(Array.isArray(a));//true\na = {};\nconsole.log(Array.isArray(a));//false\n```\n\n**`toString()`：将数组转换为字符串**，每一项用逗号分割。\n\n大多数的数据类型都可以使用.toString()方法，将其转换为字符串。\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(a.toString());//1,2,3,[object Object],function(){}\n```\n\n还可以使用`String()`将数组转换为字符串\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(String(a));//1,2,3,[object Object],function(){}\n```\n\n**`join()`：将数组转换为字符串,可以指定分隔符**，默认为逗号分割。\n\n```js\nvar a = [1,[2,3],{name:'chuckle',age:19},function(){}];\nconsole.log(a.join());//1,2,3,[object Object],function(){}\nconsole.log(a.join(' '));//1 2,3 [object Object] function(){}\nconsole.log(a.join('|'));//1|2,3|[object Object]|function(){}\n```\n\n可以使用`JSON.stringify()`将某个对象转换成 JSON 字符串形式，数组中的空属性会转为null。\n\n```js\nvar arr = [];\narr[5] = 6;\nconsole.log(arr); // [空属性 × 5, 6]\nconsole.log(JSON.stringify(arr)); // [null,null,null,null,null,6]\n```\n\n**字符串的方法：`split()`：将字符串按指定的分隔符，组装为数组**，默认为逗号分割，找不到指定分隔符时也会用逗号分割\n\n```js\nvar str = \"qx,chuckle,轻笑\"\nconsole.log(str.split());//['qx,chuckle,轻笑']\nconsole.log(str.split(''));//['q', 'x', ',', 'c', 'h', 'u', 'c', 'k', 'l', 'e', ',', '轻', '笑']\nconsole.log(str.split('-'));//['qx,chuckle,轻笑']\nconsole.log(str.split('c'));// ['qx,', 'hu', 'kle,轻笑']\n```\n\n**`Array.from()`：将伪数组或可遍历对象转为真数组**\n\n**伪数组**也有length属性，可以使用索引对数据进行操作，但是没有**真数组**的方法，因为该对象的原型不指向Array，需要将伪转真才能调用数组的方法。\n\n伪数组一般不会直接创建，而是通过一些js操作得到，通过浏览器方法获取标签、字符串、接受实参的函数arguments得到参数的伪数组，因为伪数组具有长度和索引，所以可以使用循环语句遍历。\n\n```js\nvar str = \"chuckle\";\nstr.push('qx');//报错str.push is not a function\nvar a = Array.from(str);\nconsole.log(a);//['c', 'h', 'u', 'c', 'k', 'l', 'e']\na.push('qx')\nconsole.log(a);// ['c', 'h', 'u', 'c', 'k', 'l', 'e', 'qx']\n```\n\n**`Array.of(a,b,c)`：将多个值按顺序转为字符串**，和`new Array()`差不多，区别是只有一个参数时，在**new Array()**表示数组的长度，而在**of()**仍然代表数组的元素\n\n```js\nvar arr = Array.of(1, [2,3], 'qx');\nconsole.log(arr);// [1, Array(2), 'qx']\narr = Array.of(3);\nconsole.log(arr);// [3]\narr = new Array(3);\nconsole.log(JSON.stringify(arr));// [null,null,null]\n```\n\n### 元素的添加和删除\n**`push()`：**从数组**尾部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.push(4,5,'123'));// 6\nconsole.log(JSON.stringify(arr));// [1, 2, 3, 4, 5, '123']\n```\n\n**`pop()`：**删除数组中**最后一个**元素，返回**被删除**的元素，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.pop());// 3\nconsole.log(JSON.stringify(arr));// [1,2]\n```\n\n**`unshift()`：**从数组**头部插入**任意数量元素，返回**新数组的长度**，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.unshift('0123',0));// 5\nconsole.log(JSON.stringify(arr));// [\"0123\",0,1,2,3]\n```\n\n**`shift()`：**删除数组中**第一个**元素，返回**被删除**的元素，**改变原数组**\n\n```js\nvar arr = [1,2,3];\nconsole.log(arr.shift());// 1\nconsole.log(JSON.stringify(arr));// [2,3]\n```\n\n**`splice()`：**从数组中删除**指定的**任意数量元素，返回**被删除元素**组成的新数组，**改变原数组**\n\n```js 语法，索引值为负代表从倒数第几个开始删\n新数组 = 原数组.splice(起始索引);\n新数组 = 原数组.splice(起始索引, 需要删除的个数);\n新数组 = 原数组.splice(起始索引, 需要删除的个数, 新的元素1, 新的元素2...);\n```\n\n```js\nvar arr = [1,2,3,4,5];\nconsole.log(arr.splice(1));// 删除下标1后的所有元素，[2, 3, 4, 5]\nconsole.log(JSON.stringify(arr));// [1]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(1,2));// 从下标1开始删两个元素，包括下标1，[2, 3]\nconsole.log(JSON.stringify(arr));// [1,4,5]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(1,2,'a','b'));// 删完后再从删除的起始位置插入'a','b'元素，[2, 3]\nconsole.log(JSON.stringify(arr));// [1,\"a\",\"b\",4,5]\n\narr = [1,2,3,4,5];\nconsole.log(arr.splice(-2));// 从倒数第2个元素开始删后面的所有元素，[4, 5]\nconsole.log(JSON.stringify(arr));// [1,2,3]\n```\n\n搭配`indexOf()`，删除指定内容的元素\n\n```js\nvar arr = [1,2,3,4,5];\nconsole.log(arr.splice(arr.indexOf(3), 1));// 删除3这个元素，[3]\nconsole.log(JSON.stringify(arr));// [1,2,4,5]\n```\n\n\n\n`slice()`：从数组中提取**指定的**任意数量元素，返回**新数组**，**不改变原数组**\n\n```js 语法，负数代表倒数索引\n新数组 = 原数组.slice(开始位置的索引);\n新数组 = 原数组.slice(开始位置的索引, 结束位置的索引);//提取的元素中，包含开始位置，不包含结束位置\n```\n\n```js\nvar arr = ['a', 'b', 'c', 'd'];\nconsole.log(arr.slice()); // 不带参数提取所有元素,['a', 'b', 'c', 'd']\nconsole.log(arr.slice(2)); // 从下标2提取后面所有元素，['c', 'd']\nconsole.log(arr.slice(-2)); // 提取最后两个元素,['c', 'd']\nconsole.log(arr.slice(1,3)); // 提取[1,3)索引的元素,['b', 'c']\nconsole.log(arr.slice(3,1)); // 范围内无元素，提取为空数组,[]\n```\n\n**`concat()`：**合并多个数组，返回合并后的新数组，**不改变原数组**\n\n```js\nvar arr1 = [1, 2, 3];\nvar arr2 = [4, 5, 6];\nvar arr3 = [7, 8, 9];\nconsole.log(arr1.concat(arr2,arr3));// [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(arr1);// 不改变原数组 [1, 2, 3]\n```\n\n**数组合并的另一种方式：**使用扩展运算符`...`\n\n```js\nvar arr1 = [1, 2, 3];\nvar arr2 = [4, 5, 6];\nvar a = [0, ...arr1, ...arr2, 7];//[0, 1, 2, 3, 4, 5, 6, 7]\n```\n\n**`fill()`：**用固定的值**填充数组**，返回新数组，**改变原数组**\n\n```js\n// 数组中每一个元素都替换为该值\n新数组 = 数组.fill(固定值);\n//从起始位置开始填充\n新数组 = 数组.fill(固定值, 起始索引);\n//从起始位置到结束位置填充，左闭右开\n新数组 = 数组.fill(固定值, 起始索引, 结束索引);\n```\n\n```js\nvar arr = new Array(6).fill(0)//创建一个元素均为0，长度为6的数组\nconsole.log(arr);// [0, 0, 0, 0, 0, 0]\narr.fill('a',2);//索引2后的所有元素填充为'a'\nconsole.log(arr);// [0, 0, 'a', 'a', 'a', 'a']\narr.fill('b',2,4);//索引[2,4)的元素填充为'b'\nconsole.log(arr);// [0, 0, 'b', 'b', 'a', 'a']\n```\n\n### 数组排序\n\n`reverse()`：反转数组，返回反转后的数组，**改变原数组**\n\n```js\nvar arr = ['a', 'b', 'c', 'd', 'e'];\nconsole.log(arr.reverse());// ['e', 'd', 'c', 'b', 'a']\nconsole.log(arr);// ['e', 'd', 'c', 'b', 'a']\n```\n\n`sort()`：排序，元素默认按照**Unicode编码**（逐个字符比较，非字符串先隐式转换为字符串），从小到大进行排序，返回排序后的新数组，**改变原数组**\n\n```js\nvar arr = ['c', 'e', 'a', 'd', 'b'];// 乱序\nconsole.log(arr.sort());// ['a', 'b', 'c', 'd', 'e']\nconsole.log(arr);// ['a', 'b', 'c', 'd', 'e']\n```\n\n当数组内元素是数字时，不能直接使用sort()排序，因为默认是按逐个字符的Unicode编码进行排序\n\n```js\nvar arr = [7, 3, 11, 4, 1, 5];\n//11排到了3的前面，没有按我们所想的从小到大排\nconsole.log(arr.sort());//[1, 11, 3, 4, 5, 7]\n```\n\n对于非字符串排序（**数字的排序**），需要传入一个比较函数，有两个参数 a 和 b（可以是数组中**任意元素**）\n\n`arr.sort(Fun(a, b))`，a：**第一个**用于比较的元素，b：**第二个**用于比较的元素，数组按照**比较函数的返回值**进行排序，而不是Unicode编码。\n\nJS规定了**Fun(a, b)返回值**的效果：\n\n1. 返回值**小于0**，让a排b**前面**\n2. 返回值**大于0**，让a排b**后面**\n3. 返回值**等于0**，a,b的相对位置**不变**\n\n对于[7, 3, 11, 4, 1, 5]这个数组，比较11和4时，不带比较函数，会按Unicode编码从小到大排序，11会排在4前面，带比较函数后，因为a-b=7大于零，所以会让4排11前面。\n\n```js\n//实现整体升序(小到大)\narr.sort((a, b) => a - b);\n//实现整体降序(大到小)\narr.sort((a, b) => b - a);\n```\n\n```js 实际用用\nvar arr = [7, 3, 11, 4, 1, 5];\narr.sort();//[1, 11, 3, 4, 5, 7]\narr.sort((a, b) => a - b);// [1, 3, 4, 5, 7, 11]\narr.sort((a, b) => b - a);// [11, 7, 5, 4, 3, 1]\n```\n\n**Fun(a, b)**具体比较什么，什么情况返回大于0的数，什么时候返回小于0，需要自己去编写，所以可以实现商品的按价格排序：\n\n```js\n//这个数组中存放了几个商品对象，试着让它们按价格升序排序\nvar commodityList = [\n  {\n    name: 'biscuit',\n    price: 10,\n  },\n  {\n    name: 'Coke',\n    price: 3,\n  },\n  {\n    name: 'toy',\n    price: 8,\n  },\n  {\n    name: 'bread',\n    price: 5,\n  },\n];\n\ncommodityList.sort((a, b) => {\n  // 比较价格，规范起见，都进行parseInt()转换，也可以用parseFloat()，看业务需要\n  return parseInt(a.price) - parseInt(b.price);\n});\n\nconsole.log(JSON.stringify(commodityList));\n\n```\n\n```js 输出如下\n[ \n  {\"name\":\"Coke\",\"price\":3},\n  {\"name\":\"bread\",\"price\":5},\n  {\"name\":\"toy\",\"price\":8},\n  {\"name\":\"biscuit\",\"price\":10}\n]\n```\n\n### 查找数组元素\n**`indexOf()`：** **从前往后**搜索数组中的元素，并返回它**首次**所在位置的索引。\n**`lastIndexOf()`：** **从后往前**搜索数组中的元素，并返回它**首次**所在位置的索引。\n\n找到元素返回其索引，没找到返回**-1**，**严格类型约束**，类似===。\n\n```js\nvar arr = ['1', 2, 1, '2'];\nconsole.log(arr.indexOf(1));// 2\nconsole.log(arr.indexOf('1'));// 0\nconsole.log(arr.indexOf('2'));// 3\nconsole.log(arr.indexOf(2));// 1\nconsole.log(arr.indexOf(3));// -1\n```\n\n可以指定第二个参数，指定查找的起始位置，包括该位置\n\n```js\nvar arr = [1, 2, 3, 4, 3, 2, 1];\n//正着从数组一半开始找\nconsole.log(arr.indexOf(1, parseInt(arr.length/2)));// 6\n//倒着从数组一半开始找\nconsole.log(arr.lastIndexOf(1, parseInt(arr.length/2)));// 0\n```\n\n**`includes()`：**判断数组是否包含一个指定的值，**严格类型约束**，返回**布尔**，可以加上第二个参数规定查找的起始位置。\n\n```js\nvar arr = [1, 2, '3', '4'];\nconsole.log(arr.includes(1)); // true\nconsole.log(arr.includes('1')); // false\nconsole.log(arr.includes(2, 2)); // false\nconsole.log(arr.includes('3', 2)); // true\n```\n\n**`find(function())`：**返回**第一个**符合传入测试（函数）条件的数组元素。\n**`findIndex(function())`：**返回**第一个**符合传入测试（函数）条件的数组元素的**索引**。\n\n找到符合条件的第一个元素就停止查找，没找到返回**find()返回undefined**，**findIndex()返回-1**\n\n```js 找到大于30的第一个元素\nvar arr = [10, 20, 30, 40, 50, 60];\n//用find\nvar result = arr.find((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;\n});\nconsole.log(result);// 40\n//用findIndex\nvar result = arr.findIndex((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;\n});\nconsole.log(result);// 3\n\n```\n\n`every(function())`：检测数组**所有元素**是否**都**符合指定(函数)条件，返回**布尔**，有一项返回 false 立刻停止遍历。\n`some(function())`：检测数组是否**存在**符合指定(函数)条件的元素，返回**布尔**，有一项返回 true 立刻停止遍历。\n\n**every()：**全部真，才为真，**some()：**一个真，就为真，\n\n```js every举例\nvar arr = [10, 20, 30, '40', '50', '60'];\nvar result = arr.every((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 0;// 判断数组中元素是否都大于0，字符串会隐式转为数值\n});\nconsole.log(result);// true\n```\n\n```js some举例\nvar arr = [10, 20, 30, '40', '50', '60'];\nvar result = arr.some((item, index, array) => {\n  // item是元素内容，index是该元素索引，array是该数组\n  return item > 30;// 判断是否有大于0的元素，字符串会隐式转为数值\n});\nconsole.log(result);// true\n```\n\n### 遍历数组\n**`for循环`遍历**，大多数语言对于数组通用的遍历方法\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nfor (let i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n//1 2 3 4 5\nconsole.log(JSON.stringify(arr));//[1,2,3,4,5]\n```\n\n这不够优雅，JS有更简单便捷遍历数组的方法\n\n**`forEach()`**传入一个**回调函数**作为参数，它由我们创建但是不由我们调用，数组中有几个元素，该回调函数就会执行几次，没用返回值\n\n```js\narr.forEach(function (item, index, array) {\n\t//做些事情\n});\n```\n\n**回调函数中传递三个参数：**\n1. **参数1（item）：**当前正在遍历的元素\n2. **参数2（index）：**当前正在遍历的元素的索引\n3. **参数3（array）：**正在遍历的数组\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\tconsole.log(`${index}:${item}`);\n});\n//0:1 1:2 2:3 3:4 4:5\n```\n\n在**forEach()**的回调函数中**不能通过参数1（item）直接修改数组中的元素**，但元素是一个对象时，可以访问并修改该对象的属性，这是因为数组中存放的是该对象的引用（地址）\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\titem += 1;//试图让数组中的元素都加1 \n});\nconsole.log(JSON.stringify(arr));//[1,2,3,4,5]很显然，做不到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\titem = {name: 'chuckle', age: 19}//试图修改数组中的元素\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"qx\",\"age\":19}]很显然，做不到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\titem.name = 'chuckle';//试图访问该对象的属性并修改\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]很显然，这是可以的\n\n```\n\n如果要修改数组中的元素，需**通过参数2（index）和3（array）**，`array[index]`来访问数组元素并修改\n\n```js\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function (item, index, array) {\n\tarray[index] += 1;//试图让数组中的元素都加1 \n});\nconsole.log(JSON.stringify(arr));//[2,3,4,5,6]可以做到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\tarray[index] = {name: 'chuckle', age: 19}//试图修改数组中的元素\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]可以做到\n\nvar arr = [{name: 'qx', age: 19}];\narr.forEach(function (item, index, array) {\n\tarray[index].name = 'chuckle';//试图访问该对象的属性并修改\n});\nconsole.log(JSON.stringify(arr));//[{\"name\":\"chuckle\",\"age\":19}]可以做到\n\n```\n\n纯粹只是遍历数组，可以用forEach()，但同时要修改元素时，最好使用**map()**，避免一些低级错误\n\n**`for of`**，ES6新增循环遍历数组方法\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nfor(let item of arr) {\n  //item是元素的拷贝，无法直接修改item来修改元素值\n\tconsole.log(item);\n}\n// 1 2 3 4 5\n```\n\n**`for in`**用于遍历无序的对象的属性，而不是有序的数组\n\n```js\nvar obj = {\n  name: 'chuckle',\n  age: '19'\n};\nfor(let key in obj) {\n  //key是属性名，obj[key]可以修改属性值\n\tconsole.log(`属性名：${key}，值：${obj[key]}`);\n}\n//属性名：name，值：chuckle\n//属性名：age，值：19\n\n```\n\n**`map()`**，遍历数组，并对数组中的每一项进行加工。\n\n对数组中每一项运行回调函数，返回每一项加工后的结果，组成的新数组，**不改变原数组**。\n\n```js 语法\nvar newArr = arr.map((item, index, array) => {\n    // item是元素内容，index是该元素索引，array是该数组\n    return newItem;//返回该项加工后的结果\n});\n```\n\n```js\nvar arr = [1, 2, 3, 4, 5];\nvar newArr = arr.map((item, index, array) => {\n    return item += 1;//返回每一项加一\n});\nconsole.log(JSON.stringify(newArr));//[2,3,4,5,6]\n```\n\n**常用案例：**将 A 数组(通常存对象)中某个属性的值，存储到 B 数组中。\n\n```js\nvar arr = [\n  { name: '张三', age: 19 },\n  { name: '李四', age: 18 },\n  { name: '王五', age: 20 },\n];\n\n//把属性name都提取出来\nvar newArr = arr.map((item) => item.name);//返回每个item的name属性\nconsole.log(JSON.stringify(newArr));//[\"张三\",\"李四\",\"王五\"]\n\n//重新组一个对象，改键名\nnewArr = arr.map((item) => ({\n  myName: item.name,\n  myAge: item.age,\n}));//把属性拿出来重新组一个对象\nconsole.log(JSON.stringify(newArr));\n//[{\"myName\":\"张三\",\"myAge\":19},{\"myName\":\"李四\",\"myAge\":18},{\"myName\":\"王五\",\"myAge\":20}]\n\n```\n\n**`filter()`：**数组中的每一项运行回调函数，回调函数返回结果是**true**的项（符合条件的项），**组成新数组返回，不改变原数组**\n\n```js\nvar arr = [7, 2, 3, 6, 7, 4];\nvar newArr = arr.filter(item => {\n    return item > 4;//item > 4回调函数返回true，filter()就把该元素放进新数组里\n});\nconsole.log(JSON.stringify(newArr));//[7,6,7]\n```\n\n```js\nvar arr = [\n  { name: '张三', age: 19 },\n  { name: '李四', age: 18 },\n  { name: '王五', age: 20 },\n];\n//筛选出年龄大于18的同学\nvar newArr = arr.filter((item) => item.age > 18);\nconsole.log(JSON.stringify(newArr));//[{\"name\":\"张三\",\"age\":19},{\"name\":\"王五\",\"age\":20}]\n//再用map()筛选出名字\nvar resultArr = newArr.map((item) => item.name);\nconsole.log(JSON.stringify(resultArr));//[\"张三\",\"王五\"]\n\n```\n\n**`reduce()`：**参数是接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值返回\n\n**reduce() 对于空数组不会执行回调函数**\n\n```js 语法\nvar result = arr.reduce((prev, item, index, array) => {}, initialValue);\n```\n\n**回调函数参数解释：**\n1. **prev**：必填，**上一次**调用回调函数时的**返回值**\n2. **item**：必填，当前正在处理的**数组元素**\n3. **index**：可选，当前正在处理的数组元素**下标**\n4. **array**：可选，**该数组**\n5. **initialValue**：可选，作为第一次调用回调函数时**传给prev**的值，最好手动初始化为0\n\n**举例 1、数组求和：**\n\n```js\nvar arr = [1, 2, 3, 4, 5, 6];\nvar result = arr.reduce((prev, item) => {\n    return prev + item;// 累计求和\n});\nconsole.log(`总和:${result}`); // 总和:21\n```\n\n**举例 2、统计某个元素出现的次数：**\n\n```js\nvar arr = [5, 2, 6, 4, 3, 6];\n\n//统计函数，传入数组arr和要统计的value，返回value出现的次数\nfunction arrCount(arr, value){\n  return arr.reduce((prev, item)=>{\n    //判断当前项item是否等于value，是则让prev计数加一并返回\n    return prev += item === value ? 1 : 0;\n  }, 0);\n}\n\nconsole.log(arrCount(arr, 6)); // 2\nconsole.log(arrCount(arr, 7)); // 0\n\n```\n\n**举例 3、找到最大的元素：**\n\n```js\nvar arr = [5, 2, 6, 7, 3, 6];\n\n//传入数组arr,返回最大元素(首次找到)的下标\nfunction maxValue(arr){\n  return arr.reduce((prev, item, index, arr) => {\n    //prev初始值为0，默认下标0的元素最大，每一项与arr[prev]比较，大于就更新prev为当前下标index\n    return prev = item > arr[prev] ? index : prev;\n  }, 0)\n}\n\nconsole.log(maxValue(arr));// 3\nconsole.log(arr[maxValue(arr)]);// 7\n\n```\n\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"JavaScript基础笔记(1)","url":"/article/3f7cd15d.html","content":"\n# 这是JavaScript\nHTML描述页面的结构，CSS展现页面的样式，**JS**在页面中描述行为、控制交互。\n\n~~JavaScript里没有Java，就像老婆饼里没有老婆。~~\n\nJavaScript是解释型语言，既是前端语言，又是后端语言，当它运行在浏览器中时是**前端语言**，**后端语言**运行在服务器中也称为服务端语言，NodeJS可以让JS运行在服务端。\n\nJavaScript基础由三部分组成，ECMAScript是语法，DOM和BOM是浏览器提供的API：\n1. **ECMAScript**: JavaScript的语法标准，至少要学习到**ES6**，它规定了JS最基础的语句、变量、函数、运算等等。\n2. **DOM**: 文档对象模型（Document Object Model），JS**操控网页元素**的API。\n3. **BOM**: 浏览器对象模型（Browser Object Model），JS**操控浏览器**的API。\n\n# 使用JS\n1. **行内**: 写在标签属性中。<input type=\"button\" value=\"点我\" href=\"javascript:;\" onclick=\"alert('你好')\" />\n```js\n<input type=\"button\" value=\"点我\" href=\"javascript:;\" onclick=\"alert('你好')\" />\n```\n2. **内嵌**: 写在`<script></script>`标签中。\n```html\n<script type=”text/javascript”>\n  alert('你好');\n</script>\n```\n3. **外链**: 在`<script></script>`标签的src属性中写上js文件的链接。\n```html\n<script type=\"text/javascript\" src=\"main.js\"></script>\n```\n\n# 执行顺序\n浏览器默认从**上至下**解析网页，JS的加载默认会阻塞网页的解析，通过JS操控网页元素，需待网页解析完后执行、写在html的最后或写在对应元素后，否则就可能因为DOM树不完整，要操控的对象还未被加载而报出undefined错误。\n\n```html\n<!-- 不等待后续网页的解析，到此就加载JS并执行 -->\n<script src=\"main.js\"></script>\n<!-- 网页的解析与JS的加载异步，但JS在网页解析完后执行 -->\n<script defer src=\"main.js\"></script>\n<!-- 网页的解析与JS的加载异步，JS加载完后立即执行 -->\n<script async src=\"main.js\"></script>\n```\n\n```js\n//待网页解析完、网页中所有资源（图片、css）都加载完毕，执行其中的代码\nwindow.onload  = function () {\n  //js代码\n  alert('你好');\n}\n```\n\n# 输出语句\n1. `console.log()`: 在控制台输出内容\n```js\nconsole.log('日志'); //普通打印\nconsole.warn('警告'); //警告打印\nconsole.error('出错了'); //错误打印\n```\n2. `alert()`: 警告对话框 <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"alert('这是一个警告')\" />\n3. `confirm()`: 确认对话框，返回true或false <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"var a = confirm('确认吗');if(a){alert('你确认了')}else{alert('未确认')}\" />\n```js\nvar a = confirm('确认吗');\nif(a){\n  alert('你确认了')\n}else{\n  alert('未确认')\n}\n```\n4. `prompt()`: 输入对话框，返回输入内容或空字符串，点取消返回NULL <input type=\"button\" value=\"测试\" href=\"javascript:;\" onclick=\"var a = prompt('输入内容');if(a){alert('你输入了：'+a)}else if(a==''){alert('你没输入任何东西')}else{alert('取消')}\" />\n```js\nvar a = prompt('输入内容');\nif(a){\n  alert('你输入了：'+ a)\n}else if(a==''){\n  alert('你没输入任何东西')\n}else{\n  alert('取消')\n}\n```\n\n# 常量、变量、标识符\n数字常量、字符串常量、布尔常量\n```js\nconsole.log(123); //123是数字\nconsole.log('123'); //'123'是字符串，''空字符串\nconsole.log('你好'); //''包裹起来的都是字符串\nif(true){ //true、false布尔常量\n  console.log('true'); \n}\n```\n\n自定义常量const\n```js\nconst a = '123'; //定义a为常量\na = '321'; //不允许修改常量\nconst a = '321'; //不允许重新声明\n```\n\n定义变量var、let(ES6)\n```js\nvar a = '123';\nlet b = 321;\n//重新定义\nvar a = '321'; //var允许重新定义\nlet b = 123; //let不允许重新定义\n//不允许var和let之间重新定义\nvar c = 123;\nlet c = 123;\n```\n\nvar可以在声明前使用，值为undefined，而let必须先声明再使用。\n\nvar是**函数作用域**，let是**块作用域**。\n\n**标识符**（一切可自主命名的，如变量名、函数名）命名规则：\n1. 区分大小写\n2. 只能由字母(A-Z、a-z)、数字(0-9)、下划线(_)、美元符( $ )组成\n3. 不能以数字开头、不允许出现空格\n4. 不能出现中划线 -\n\n# 数据类型\nJavaScript是**弱类型语言**（动态语言），无需声明变量的类型，在程序运行过程中，会根据**等号右边的值**自动确定类型。\n\n```js\nvar a = 123;\nconsole.log(typeof a);//输出number\na = '123'//强制将变量a数据类型转换为字符串\nconsole.log(typeof a);//输出string\na = Number(a);//强制将字符串'123'转换为数字123\nconsole.log(a);//输出123\n```\n\nJS中数据类型分为**基本数据类型**和**引用数据类型**\n1. **基本数据类型**（值类型）: String字符串、Number数值、BigInt(ES6)大型数值、Boolean布尔值、Null空值、Undefined未定义、Symbol(ES6)。\n2. **引用数据类型**（引用类型）：Object 对象(除了基本数据类型之外，都可称之为Object类型)。\n\n基本数据类型**传数值**，引用数据类型**传地址**。\n\n```js\nvar a = 23;\nvar b = a;//将a的值23传给b\na++;\nconsole.log(a); //24\nconsole.log(b); //23，改变a的值不影响b\n```\n\n```js\nvar a = new Object();//a、b都是引用数据类型\nb.name = '123';\nvar b = a;//传的是a的地址，a和b是同一个东西\na.name = '321';\nconsole.log(a.name); //321\nconsole.log(b.name); //321，修改a对象的属性也会修改b\n```\n\nJS中，所有的变量都保存在**栈内存**中的。\n\n基本数据类型直接保存在**栈内存**中。值与值之间独立存在。\n\n对象Object保存在**堆内存**中，创建一个新的对象，在堆内存中开辟一个新的空间，变量在**栈内存**中保存了对象的**内存地址**（对象的引用）。\n\n# String字符串\n字符串是双引号和单引号中的文本，不同类型引号可以嵌套使用。\n\n```js\nvar a = '123';\nconsole.log(a);//123\nvar b = '1\"2\"3';\nconsole.log(b);//1\"2\"3\nvar c = '12    3';\nconsole.log(c);//12    3不忽略连续多个空格\n```\n\n加入字符串进行拼接，可以被同化为字符串\n\n```js\nconsole.log(typeof(123+''));//string\n```\n\n转义字符: `\\`\n* 双引号: `\\\"`，单引号 `\\'`\n* `\\\\` 表示\\\n* `\\r` 回车，`\\n` 换行\n* `\\t` 缩进\n* `\\b` 空格\n\n字符的数量就是**字符串的长度**，获取字符串的长度`.length`：\n\n```js\nvar a = \"abc\";\nconsole.log(a.length);//3\na = \"你好\";\nconsole.log(a.length);//2\n```\n\n使用 **+** 进行**字符串拼接**：\n\n```js\nvar a = \"你好\"+\"世界\";\nconsole.log(a);//你好世界\na = \"你好\"+ 1;\nconsole.log(a);//你好世界1\na = \"你好\"+ null;\nconsole.log(a);//你好null\na = \"你好\"+ true;\nconsole.log(a);//你好true\n```\n\nES6新增**模板字符串**：**``**，可以使用`${变量名}`将其嵌入字符串，使用时需要反引号 **``** 包裹。\n```js\nvar a = 2022;\nvar b = '2023';\nconsole.log(`去年是${a}，今年是${b}`); //去年是2022，今年是2023，注意使用反引号\n```\n\n模板字符串中可以换行，不忽略连续的多个空格，保留原有格式。\n\n可以调用函数：\n\n```js\nfunction getHtml() {\n    return `<div>\n\t<span>1</span>\n\t<span>2</span>\n\t<span>3</span>\n</div>`;\n}\nconsole.log(`1${getHtml()}2`);\n/*\n1<div>\n\t<span>1</span>\n\t<span>2</span>\n\t<span>3</span>\n</div>2\n*/\n```\n\n可以嵌套使用，进行运算：\n\n```js\nvar a = 1;\nvar b = 2;\nconsole.log(`${a+`${b}`}`);//12\nconsole.log(`${a+b}`);//3\n```\n\n# Number数值型\nJS中整数和浮点数等所有的数值都是Number类型。\n\n```js\nvar a = 1;\nvar b = 1.2;\nconsole.log(typeof a);//number\nconsole.log(typeof b);//number\n```\n\n数值范围:\n\n```js\nconsole.log(Number.MAX_VALUE);//1.7976931348623157e+308\nconsole.log(Number.MIN_VALUE);//5e-324\n```\n\n数值变量超过了最大值，则会返回**Infinity**，Infinity也是一种数值，代表无穷大。\n\n```js\nvar a = Number.MAX_VALUE;\nvar b = Number.MIN_VALUE;\nconsole.log(a*2);//Infinity\nconsole.log(b/2);//0\nconsole.log(a*(-2));//-Infinity\nconsole.log(typeof Infinity);//number\n```\n\n**NaN**是一个特殊的数字，表示不是数值(Not a Number)，当运算不出数值时就会返回NaN。\n\n```js\nconsole.log(typeof NaN);//number\nconsole.log('abc' / 2);//NaN\nconsole.log('a' * '2');//NaN\n```\n\nUndefined和任何数值计算的结果均为NaN。NaN与任何值都不相等，包括NaN本身。\n\n```js\nconsole.log(undefined + 1);//NaN\nconsole.log(null + 1);//1\nconsole.log(NaN==NaN);//false\n```\n\n**隐式转换**，当有字符串介入的运算，且字符串可被转换为数值，除了+表示字符串连接，其余都会自动将字符串转为数值后进行运算。\n\n```js\nconsole.log('1' + '2');//12\nconsole.log('1' * '2');//2\nconsole.log('1' / 2);//0.5\nconsole.log('1' - 2);//-1\nconsole.log('1' + '2' * '3');//16\n```\n\n浮点数的**运算精度**并不足够准确，当需要进行高精度运算时，最好引入可靠的数学库。\n\n```js\nvar a = 0.1 + 0.2;\nconsole.log(a); //0.30000000000000004\n```\n\n# Null与Undefined\nundefined实际上是由null衍生出来的。\n\n**undefined**表示未定义，应该有值但还未赋值，连null这个值都没有赋予给它。\n**null**代表空值，本身是一个具体的值或空引用。\n\nnull和undefined值上**相等**，但类型不一样。\nnull是引用类型Object，代表空对象，存的地址为空，而undefined的类型是undefined，代表未定义的值。\n\n```js\nconsole.log(null == undefined);//true\nconsole.log(null === undefined);//false\n\nconsole.log(typeof null);//object\nconsole.log(typeof undefined);//undefined\n```\n\nnull转为数值是0，undefined转为数值是NaN。\n任何值和null运算，null可看做0。任何数据类型和undefined运算，结果都是NaN。\n\n```js\nconsole.log(Number(null));//0\nconsole.log(Number(undefined));//NaN\n\nconsole.log(null+1);//1\nconsole.log(undefined+1);//NaN\n```\n\n**出现undefined的情况**：\n1. 变量被声明了，但是没有被赋值\n2. 变量未声明（未定义）时\n3. 调用函数时，未传参\n4. 函数无返回值时\n5. 访问一个对象中没有的属性\n\n```js\nconsole.log(a);//undefined\nvar a;\nconsole.log(a);//undefined\n\nfunction Fun(item) {\n  console.log(item);\n}\nconsole.log(Fun());//undefined\nFun();//undefined\n```\n\n**出现null的情况**：\n1. 访问一个不存在的dom节点\n2. 作为对象原型链的终点出现\n\n# 数据类型转换\n变量的**数据类型转换**：将一种数据类型转换为另外一种数据类型。（通常在基本数据类型中互相转换）\n\n1. **显式类型转换**\n  1. `toString()` 转换为字符串\n  2. `String()` 强制转换为字符串\n  3. `Number()` 转为数值，保留小数\n  4. `parseInt()` 字符串转整数,**直接舍去小数部分**\n  5. `parseFloat()` 在parseInt()的基础上可以获得小数部分\n  6. `Boolean()` \n2. **隐式类型转换**\n  1. `isNaN()` \n  2. 自增/自减\n  3. 正号/负号\n  4. 加号(字符串拼接)\n  5. 其它数值运算符\n  6. 逻辑运算符：会先非布尔值转换为布尔值，再运算\n  7. 关系运算符：运算结果都是布尔值\n\n## 转为字符串\n\n`toString()`:\n\n```js\nvar a = 123;\nconsole.log(a.toString());//\"123\"\na = true;\nconsole.log(a.toString());//\"true\"\na = [1, 2, 3];\nconsole.log(a.toString());//\"1,2,3\"\na = { name: 'qx', age: 18 };\nconsole.log(a.toString());//\"[object Object]\"\n```\n\nnull和undefined这没有toString()方法，调用会报错\n\n```js\nvar a = null; \nconsole.log(a.toString());//Cannot read properties of null (reading 'toString')\na = undefined;\nconsole.log(a.toString());//Cannot read properties of null (reading 'toString')\n```\n\nNumber类型的变量，在调用toString()时，可以传入一个整数，把数字转换为指定的进制，默认转换为10进制。\n\n```js\nvar a = 8;\na = a.toString(2); //转换为二进制\nconsole.log(a); //\"1000\"\nconsole.log(typeof a);//string\n```\n\n数字不允许直接调用toString()\n```js\n1.toString()//不允许，会把.看成小数点，小数点后面出现非数字是不允许的\n1..toString()//允许\n(1).toString()//允许\n```\n\n使用`String()`强制转换为字符串。\n对于**非**null和undefined的数据类型而言，实际上就是调用toString()。\n对于null和undefined，直接转换为\"null\"和\"undefined\"。\n\n```js\nvar a = 123;\nconsole.log(String(a));//\"123\"\na = null;\nconsole.log(String(a));//\"null\"\na = undefined;\nconsole.log(String(a));//\"undefined\"\n```\n\n字符串拼接，隐式转换：\n\n```js\nvar a = 123;\nconsole.log(a+'');//\"123\"\n```\n\n## 转为数值\n\n`Number()`转为数值类型\n1. **字符串转数字**\n  1. 字符串中是纯数字，直接将其转换为数字\n  2. 空字符串或全是空格，转换为0\n  3. 字符串中包含了非数字的内容，转为NaN\n2. **布尔值转数字**：true --> 1，false --> 0\n3. **null --> 0，undefined --> NaN**\n\n加上**正负号隐式转换**。规则和Number()一样，但是改变正负性，0也会带上负号：\n\n```js\nvar a = '123';\nconsole.log(+a); //123\nconsole.log(-a); //-123\nconsole.log(typeof +a);//number\na = null\nconsole.log(+a); // 0\nconsole.log(-a); // -0\n```\n\n`parseInt()` **字符串转整数**，布尔、null等非字符串、非数值类型都转为NaN，逐个字符转，碰见非数字字符就停止，没有提取到数值，就返回NaN。\n\n```js\nparseInt('123abc'); //123\nparseInt('abc123'); //NaN\nparseInt(''); //NaN\nparseInt('       '); //NaN\nparseInt(null); //NaN\nparseInt(undefined); //NaN\nparseInt(true); //NaN\n```\n\nparseInt()会自动截断、舍弃小数，而Number()不会。\n\n```js\nvar a = parseInt('5.1') + parseInt(5.9);\nconsole.log(a);//10\na = Number('5.1') + Number(5.9);\nconsole.log(a);//11\na = parseInt(5.1 + 5.9);\nconsole.log(a);//11\n```\n\nparseInt()可以多带一个进制参数，把数值**看成对应进制**，再转成10进制返回。无论parseInt()里面的进制参数是多少，最终的转换结果是十进制。\n\n```js\nvar a = parseInt('101', 2);\nconsole.log(a);//5 二进制101就是十进制的5\n\na = parseInt('3', 2);\nconsole.log(a);//二进制中没有3，所以转换失败返回NaN\n```\n\n`parseFloat()` 字符串转小数，与parseInt()相似。\n\n```js\nparseFloat('123.321abc'); //123.321\nparseFloat('12.1a3.321'); //12.1\nparseFloat('12.13.321'); //12.13\n```\n\n## 转为Boolean\n任何数据类型都可以转为 Boolean 布尔型。\n1. **数值型**: 0 和 NaN的转为 false，其它都是 true\n2. **字符串**: 空串转为 false，其它都是 true。全是空格的字符串，转换结果也是 true。\"0\"也是 true。\n3. **null 和 undefined** 都转为 false\n4. **引用数据类型**都转为 true，因为地址永不为空或0。空数组[]和空对象{}，也是 true\n\n```js\nvar a;\nBoolean(a);//false,a未赋值，undefined\na = '';\nBoolean(a);//false\na = [];\nBoolean(a);//true\na = {};\nBoolean(a);//true\n```\n\n使用`!!`或`!`显式转换为 Boolean 类型：\n\n```js\nvar a = 1;\na = !a\nconsole.log(a);//false\na = !!2;\nconsole.log(a);//true\n```\n\n`isNaN()`判断是否是**非数值类型**，任何**不能直接转为数值类型**的数据类型都可以让这个函数返回true\n\n```js\nisNaN('123');//可以转为123，返回false\nisNaN(null);//转为0，false\nisNaN('123abc');//true\nisNaN(undefined);//true\n```\n\n# 运算符和运算\n各种编程语言的运算符功能都大差不差，只介绍JS中比较特殊的运算或特例。\n\n浮点数值的最高精度是 17 位小数，会有丢失精度的风险，**不要直接判断两个浮点数是否相等**\n\n**Boolean + 数字 = 数字**，true按1来算，false按0。\n**null + 数字 = 0 + 数字**\nundefined + 数字 = NaN\n任何值和 NaN 运算的结果都是 NaN\n任何**非数值类型**进行除加法以外的运算`-、*、/、%`时，都会**自动用Number()转成数值类型**再参与运算\n\n```js\ntrue + 1; //2\nnull + 1; //1\nvar a = 2 - '1'; //1\nvar a = '2'/'1'; //2\n```\n\n非布尔值进行与或运算(`&&、||`)时，会先将其转换为布尔值，然后再运算，但返回结果是原值。\n\n**与运算 &&**的返回结果：从左到右依次运行语句，找到第一个为 false 的值，返回原值，不再往后执行。如果所有的值都为 true，则返回最后一个值。\n\n```js\nvar a = '' && 123;\nconsole.log(a);//'',空字符串转为布尔型为false，只执行第一条语句并返回原值\nvar a = [] && 0;\nconsole.log(a);//0，[]转为布尔型为true，直接返回第二个语句的值\nvar a = \"0\" && 0 && 1;\nconsole.log(a);//0\n```\n\n**或运算 ||**的返回结果：从左到右依次运行语句，找到第一个为 true 的值，返回原值，不再往后执行。如果所有的值都为 false，则返回最后一个值。\n\n```js\nvar a = '' || null;\nconsole.log(a);//null\nvar a = 0 || [];\nconsole.log(a);//[]\nvar a = \"0\" || 0 || 1;\nconsole.log(a);//\"0\"\n```\n\n**比较运算符** `>、<、==、!= 等`，得到的结果都是布尔值：要么是 true，要么是 false，非数值进行比较，会将其转换为数值类型。\n\n**特殊情况**：如果参与比较的**都是字符串**，则不会将其转换为数字进行比较，比较的是字符串的Unicode编码。\n比较字符编码时，从**左到右逐位**进行比较，一样大则继续比较下一位，直到比较出大小。\n\n```js\nconsole.log('100' > 9 );//true,将'100'转为数值100进行比较\nconsole.log('100' > '9' );//false,两个字符串逐位比较，9比1大，返回false\n```\n\n`== 、===` ==进行比较时，会做**隐式转换**，将不同的数据类型，转为相同类型进行比较，而全等符号===不会进行转换，不同类型的数据比较一定是false。\n\n```js\nconsole.log('1' == 1); //true\nconsole.log('1' === 1); //false\n\nconsole.log(1 == true); //true\nconsole.log(1 === true); //false\n\nconsole.log(undefined == null); //true\nconsole.log('1a' > 1); // false。'1a'转成NaN\n\n//NaN不和任何值相等，包括它本身\nconsole.log(NaN == NaN); //false\nconsole.log(NaN === NaN); //false\n```\n\nnull与数字进行比较有一个Bug，不必在意，当特性就行：\n\n```js\nconsole.log(null < 0); //false\nconsole.log(null == 0); //false\nconsole.log(null > 0); //false\n\nconsole.log(null <= 0); //true。这是一个bug\nconsole.log(null >= 0); //true。同上\n```\n\n日期大小比较\n\n```js\nvar date1 = new Date(2023, 3, 28)\nconsole.log(date1);//Fri Sep 08 2023 00:00:00 GMT+0800 (中国标准时间)\nvar date2 = '2023-03-27';\nvar date3 = '2023/03/29';\nconsole.log(date1 > date2);//false，date1和date2字符串格式很不相同，比较无意义\nconsole.log(date3 > date2);//true,格式基本相同，分割位置一样，字符串逐位比较大小\n```\n\n# if和switch\n这部分各大语言也大差不差，只记录值得注意的点。\n\ncase的判断逻辑是**===**，不是**==**\n\nswitch中的default无论放到什么位置，都会等到所有case都不匹配再执行，但一般放在最后\n\n当case或default匹配到一个值后，会执行后续所有的case，除非遇到break或执行到switch的末尾。\n\n# 循环\n这部分各大语言也大差不差，只记录值得注意的点。\n\n**break**会立即终止离它最近的**循环语句**，**continue**跳过当次循环，继续下一次循环。\n\n可以为循环语句创建一个**label**，来标识当前的循环。使用break、continue语句时，break label将会结束指定的循环，而不是最近的。\n\n```js\none: for (var i = 0; i < 100; i++) {\n    for (let j = 0; j < 100; j++) {\n        if(i>j) {\n          break one;\n        }\n    }\n}\nconsole.log(i);//1\n```\n","tags":["前端","JS"],"categories":["学习笔记"]},{"title":"博客添加待办清单页","url":"/article/9875347c.html","content":"\n# 前言\n&emsp;&emsp;要做的事还有很多，想做的事源源不断，那就都记录在博客里吧，[ToDoList](/todolist/)。\n\n<img src=https://cdn.chuckle.top/images/40-1.webp width=\"90%\">\n\n# 实现\n&emsp;&emsp;新建`\\layout\\includes\\page\\todolist.pug`\n\n```pug\n#todolist-box\n    .page-top-card(style='background-image: url(/img/todo.webp);')\n        .content-item-tips 想做清单\n        span.content-item-title ToDoList\n        .content-bottom\n            .tips 要做的事还有很多，想做的事源源不断\n    #todolist-main\n        #todolist-left\n            each i in site.data.todolist\n                if i.seat == 'left'\n                    .todolist-item\n                        h3.todolist-title=i.class_name\n                        ul.todolist-ul\n                            each item in i.todo_list\n                                li.todolist-li\n                                    if item.completed\n                                        i.fa-regular.fa-circle-check\n                                    else \n                                        i.fa-regular.fa-circle\n                                    span=item.content\n        #todolist-right\n            each i in site.data.todolist\n                if i.seat == 'right'\n                    .todolist-item\n                        h3.todolist-title=i.class_name\n                        ul.todolist-ul\n                            each item in i.todo_list\n                                li.todolist-li\n                                    if item.completed\n                                        i.fa-regular.fa-circle-check\n                                    else \n                                        i.fa-regular.fa-circle\n                                    span=item.content\n\n```\n\n&emsp;&emsp;修改`\\layout\\page.pug`\n\n```pug\ncase page.type\n    when 'tags'\n        include includes/page/tags.pug\n        include includes/page/default-page.pug\n    when 'link'\n        include includes/page/flink.pug\n    when 'categories'\n        include includes/page/categories.pug\n        include includes/page/default-page.pug\n    when 'essay'\n        include includes/page/essay.pug\n+    when 'todolist'\n+        include includes/page/todolist.pug\n    default\n        include includes/page/default-page.pug\n\n```\n\n&emsp;&emsp;新建`\\source\\_data\\todolist.yml`\n\n```yml seat控制清单在左栏还是右栏显示，completed控制是否已完成\n- class_name: 想做的项目\n  seat: left\n  todo_list:\n    - content: 个人主页\n      completed: false\n    - content: 公众号\n      completed: false\n\n- class_name: 想看的书\n  seat: left\n  todo_list:\n    - content: 《毛泽东选集》\n      completed: false\n    - content: 《86不存在的战区》\n      completed: false\n\n- class_name: 想买的东西\n  seat: left\n  todo_list:\n    - content: 小米平板5pro\n      completed: true\n    - content: 致态固态硬盘\n      completed: true\n\n- class_name: 想学的技术\n  seat: right\n  todo_list:\n    - content: Vue2/Vue3\n      completed: false\n    - content: Electron\n      completed: false\n\n- class_name: 想去的地方\n  seat: right\n  todo_list:\n    - content: 桂林\n      completed: true\n    - content: 杭州\n      completed: false\n\n```\n\n&emsp;&emsp;添加CSS:\n\n```css\n#todolist-box{\n    margin: 0 10px;\n}\n#todolist-main{\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: center;\n    margin: 16px 0 10px;\n}\n#todolist-main li{\n    list-style:none;\n    font-size: 17px;\n}\n#todolist-main ul{\n    margin: 0;\n    padding: 0;\n}\n#todolist-left{\n    width: 50%;\n    padding: 0 8px 0 0;\n}\n#todolist-right{\n    width: 50%;\n    padding: 0 0 0 8px;\n}\n.todolist-item{\n    position: relative;\n    background: #fae4df;\n    border-radius: 12px;\n    padding: 10px 1rem 1.2rem;\n    border: 2px dashed #f7a796;\n    margin-bottom: 1rem;\n}\n[data-theme=dark]\n.todolist-item{\n    background: #242424;\n    border: 2px dashed #51908b;\n}\nli.todolist-li i{\n    margin-left: 10px;\n}\nh3.todolist-title{\n    margin: 0!important;\n    border-bottom: var(--todo-border);\n}\nli.todolist-li{\n    border-bottom: var(--todo-border);\n    font-weight: normal;\n}\n.todolist-li span{\n    margin-left: 5px;\n}\n@media screen and (max-width:700px){\n    #todolist-left,#todolist-right{\n        width: 100%;\n        padding: 0;\n    }\n  }\n.page-top-card{\n  background-size: cover;\n  background-position: center;\n  height: 20.5rem;\n  padding: 10px 2.7rem;\n  border-radius: 20px;\n  color: white;\n  position: relative;\n}\n.page-top-card span.content-item-title{\n  font-size: 2.3em;\n  font-weight: bold;\n  line-height: 1.2;\n  font-family: STZhongsong,'Microsoft YaHei';\n}\n.page-top-card .content-bottom{\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  position: absolute;\n  width: calc(100% - 5.4rem);\n  bottom: 1rem;\n}\n[data-theme='dark'] .page-top-card{\n  opacity: .92;\n}\n\n```\n\n&emsp;&emsp;新建页面\n\n```markdown\n---\ntitle: ToDoList\ndate: 2023-03-18 14:07:13\ncomments: false\naside: false\ntype: todolist\n---\n\n```\n\n# 后记\n&emsp;&emsp;无\n\n\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"网站添加点赞、踩功能","url":"/article/5de26c08.html","content":"\n# 前言\n&emsp;&emsp;看[@Shine](https://blog.shineyu.cn/)在博客里整了个点赞功能[Qexo添加点赞功能](https://blog.shineyu.cn/qexo-postlike.html)，心动，那就行动。\n\n<img src=https://cdn.chuckle.top/images/39-2.webp width=\"30%\">\n\n&emsp;&emsp;懒得整一个Qexo系统，那就看看有木有现成的点赞系统拿来改改用。找到力[orlike-vercel](https://github.com/caibingcheng/orlike-vercel)\n\n&emsp;&emsp;最终效果：\n\n<img src=https://cdn.chuckle.top/images/39-3.webp width=\"70%\">\n\n# 实现\n\n## 部署OrLike\n\n&emsp;&emsp;注册登录[leancloud](https://leancloud.app/)，最好是国际版，创建一个应用，名称随意。在侧栏找到**数据存储->结构化数据**，点击创建Class，名称为**OrLike**，默认ACL权限修改为所有用户。\n\n&emsp;&emsp;接着在侧栏找到**设置->应用凭证**，复制AppID和AppKey，后续用到。\n\n&emsp;&emsp;数据库设置完成，点击下面链接部署后端到Vercel。\n\n{% link Vercel部署OrLike点赞系统,https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fcaibingcheng%2Forlike-vercel%}\n\n&emsp;&emsp;部署完成后，在该Vercel项目的设置中找到环境变量，填入名为APPID（值对应之前复制的AppID）和APPKEY（对应AppKey）的环境变量，然后**重新部署**。\n\n&emsp;&emsp;由于vercel默认域名被墙，最好绑定自己的二级域名，该域名链接即为api。\n\n## 前端部署\n&emsp;&emsp;以Hexo-butterfly主题框架为例：\n\n&emsp;&emsp;修改`layout\\includes\\post\\reward.pug`，在末尾添加以下代码。\n\n```js\n#orlike-box.orlike-box\n  script.\n    (() => {\n      function loadOrLike () {\n        new OrLike({\n          serverUrl: \"你的api\",\n          el: \".orlike-box\",\n          days: 30,\n        });\n      }\n      window.pjax ? loadOrLike() : window.addEventListener('load', loadOrLike)\n    })()\n\n```\n\n&emsp;&emsp;修改`layout\\includes\\header\\post-info.pug`，在末尾添加以下代码，注意缩进在**.meta-firstline**内。\n\n```pug\nspan.post-meta-orlike\n    i.iconfont.icon-aixin.fa-fw.post-meta-icon\n    span.post-meta-label= '点赞数:'\n    a(href=url_for(page.path) + '#orlike-box')\n        span.orlike-count\n```\n\n&emsp;&emsp;在配置文件中全局引入该js和JQ：\n\n```js orlike.js(对OrLike项目源码仓库的orlike.min.js有修改，以适配业务)\nconst version = \"V0.1.33\"; function setCookie(cname, cvalue, exdays) { var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = \"expires=\" + d.toGMTString(); document.cookie = cname + \"=\" + cvalue + \"; \" + expires; }\nfunction getCookie(cname) {\n    var name = cname + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i < ca.length; i++) { var c = ca[i].trim(); if (c.indexOf(name) == 0) { return c.substring(name.length, c.length); } }\n    return \"\";\n}\nfunction createLink(url) { let link = $(document.createElement('link')); link.attr('href', url); link.attr('rel', 'stylesheet'); link.attr('type', 'text/css'); $('link').last().after(link); }\nfunction OrLike({ serverUrl = \"\", el = \"\", days = 30, style = \"\", ifont = \"\", icon = { like: \"fa fa-thumbs-up\", dislike: \"fa fa-thumbs-down\" }, } = {}) { this.serverUrl = serverUrl; this.el = el; this.style = style; this.ifont = ifont; this.days = days; this.icon = icon; this.ckid = \"\"; this.prepare(); this.init(); }\nOrLike.prototype.prepare = function () {\n    $(this.el).addClass(\"orlike-loading\"); if (this.style != \"\") { createLink(this.style); }\n    if (this.ifont != \"\") { createLink(this.ifont); }\n}\nOrLike.prototype.init = function () {\n    server_url = this.serverUrl; obj = this; $.ajax({\n        type: 'GET', url: server_url + '/tmp', dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, async: true, crossDomain: true, success: function (data) {\n            let template = $(data.template); let icon_like = template.siblings(\"a.likeit.orlike\").children(\"i\"); let icon_dislike = template.siblings(\"a.dislikeit.orlike\").children(\"i\"); icon_like.attr('class', obj.icon.like); icon_dislike.attr('class', obj.icon.dislike); if (obj.icon.like == false)\n                icon_like.remove(); if (obj.icon.dislike == false)\n                icon_dislike.remove(); $(obj.el).removeClass(\"orlike-loading\"); $(obj.el).html(template); obj.ckusr(obj); $('a.likeit.orlike').click({ obj: obj }, obj.like); $('a.dislikeit.orlike').click({ obj: obj }, obj.dislike);\n        },\n    });\n}\nOrLike.prototype.ckusr = function (obj) {\n    server_url = this.serverUrl; $.ajax({\n        type: 'GET', url: server_url + '/ckusr', dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, async: false, crossDomain: true, success: function (data) {\n            if (data.stat == 'ok' && data.uid != \"\") {\n                obj.ckid = data.ckid; if (!getCookie(data.ckid)) { setCookie(data.ckid, data.uid, obj.days); }\n                obj.query();\n            }\n            else { console.error('connect orlike failed!!!'); }\n        },\n    });\n}\nOrLike.prototype.query = function () {\n    server_url = this.serverUrl; $.ajax({\n        type: 'GET', url: server_url + '/qry?link=' + window.location.pathname, dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, crossDomain: true, success: function (data) {\n            if (data.stat == 'ok') { \n                $('a.likeit.orlike i span').text(data['like']);\n                $('span.post-meta-orlike a span').text(data['like']);\n                $('a.dislikeit.orlike i span').text(data['dislike']);\n            }\n            else { console.error('query orlike failed!!!'); }\n        },\n    });\n}\nOrLike.prototype.orl = function (obj, method) { server_url = obj.serverUrl; req_url = server_url + '/orl?method=' + method + '&link=' + window.location.pathname + '&' + obj.ckid + '=' + getCookie(obj.ckid); $.ajax({ type: 'GET', url: req_url, dataType: 'jsonp', jsonp: \"callback\", jsonpCallback: \"success\", xhrFields: { withCredentials: true }, crossDomain: true, success: function (data) { obj.query(); }, }); }\nOrLike.prototype.like = function (event) { obj = event.data.obj; obj.orl(obj, 'like'); }\nOrLike.prototype.dislike = function (event) { obj = event.data.obj; obj.orl(obj, 'dislike'); }\n\n```\n\n```yml\ninject:\n  head:\n  bottom:\n    - <script defer=\"true\" src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js\"></script>\n    - <script defer=\"true\" src=\"/js/orlike.js\"></script>\n```\n\n&emsp;&emsp;引入CSS：\n\n```css\n.orlike {\n  color: rgba(255, 255, 255);\n  font-size: 26px!important;\n  line-height: 2;\n  text-shadow: 5px 5px 5px #2ed0d9fc;\n}\n[data-theme=dark]\n.orlike {\n    color: rgba(255, 255, 255, 0.85);\n    text-shadow: 4px 4px 4px #23a8af99;\n}\n.orlike:first-child{\n    margin-right: 36px;\n}\n.orlike span {\n  margin-left: 0.3rem;\n}\n.orlike-box{\n    margin: 15px 0 0 0;\n    display: flex;\n    width: 100%;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    justify-content: center;\n    position: relative;\n    overflow: hidden;\n    height: 52px;\n}\n.orlike:hover{\n    color: #f07e7e!important;\n}\n[data-theme=dark]\n.orlike:hover{\n    color: #e87373e8!important;\n}\n.orlike-loading {\n    display: block;\n    height: 39px;\n    width: 10px!important;\n    border-radius: 50%;\n    border: 2px solid #acacac;\n    border-bottom-color: transparent;\n    -webkit-animation: orlike-loadingRotate 0.75s linear infinite;\n    animation: orlike-loadingRotate 0.75s linear infinite;\n}\n@-webkit-keyframes orlike-loadingRotate {\n  0% {\n    -webkit-transform: rotate(0deg);\n  }\n  50% {\n    -webkit-transform: rotate(180deg);\n  }\n  100% {\n    -webkit-transform: rotate(360deg);\n  }\n}\n@keyframes orlike-loadingRotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  50% {\n    transform: rotate(180deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n\n```\n\n\n&emsp;&emsp;完毕。\n\n# 后记\n&emsp;&emsp;无\n\n***\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"体验ChatGPT 不仅是搜索的革命","url":"/article/b19faa1c.html","content":"\n# 前言\n&emsp;&emsp;**本文由ChatGPT辅助编写文案**\n\n&emsp;&emsp;最近ChatGPT热度火爆，见多了小爱同学和siri，但哪见过这种ai，于是我也注册了个账号开始体验。\n\n&emsp;&emsp;ChatGPT的强大不仅在于它搜索答案的能力，而是它背后的模型分析问题的能力，它的回答不一定对，但它对于并不抽象的问题的分析与理解，已经与人无异了。\n\n***\n\n# 什么是ChatGPT\n\n&emsp;&emsp;什么是ChatGPT：ChatGPT是由OpenAI训练的大型语言模型，用于自然语言处理任务，如对话生成、文本摘要、机器翻译等。它是目前最先进的对话生成模型之一，可以根据给定的文本提示生成连贯、有逻辑的回复。\n\n&emsp;&emsp;所用到的技术：ChatGPT是一种基于自然语言处理（NLP）技术的对话生成模型，它使用了深度学习中的变压器（Transformer）网络结构，并通过对大量文本数据的预训练来学习语言模型。下面是一些ChatGPT使用的技术和方法：\n\n1. 变压器网络结构：变压器是一种序列到序列（seq2seq）模型，能够处理变长的输入和输出序列，适用于自然语言处理任务。ChatGPT使用了包含多个编码器和解码器的变压器结构，通过编码用户输入的文本并解码生成回复。\n2. 预训练：ChatGPT使用了大量的文本数据进行预训练，学习了语言模型中的单词嵌入、语法结构、上下文信息等。这些预训练模型可以被微调到特定的对话生成任务中，从而提高模型的表现。\n3. 无监督学习：ChatGPT是一种无监督学习模型，不需要人工标注数据就可以学习对话生成任务。它可以从大量的未标注文本数据中自动学习上下文信息、语言模式和语法结构，从而生成连贯的对话回复。\n4. 控制生成：ChatGPT可以通过添加特定的控制信息来控制对话的生成，例如指定回复的情感、主题或风格。这可以通过在输入中添加相应的标记或特定的控制向量来实现。\n\n&emsp;&emsp;总之，ChatGPT是一种基于深度学习和自然语言处理技术的先进对话生成模型，具有高度的可扩展性和灵活性，可以用于多种对话生成场景。\n\n***\n\n# 搜索答案的能力\n\n&emsp;&emsp;向ChatGPT问21年之前信息的问题，它几乎都能回答，但其回答并不一定对。下面是一些例子。\n\n&emsp;&emsp;先来点医学方面的，连花清瘟对于治疗新冠有效果吗?并列举相关的研究论文。\n\n<img src=https://cdn.chuckle.top/images/38-2.webp width=\"100%\">\n\n&emsp;&emsp;再来点物理方面的，就问问它宇宙微波背景辐射吧。\n\n<img src=https://cdn.chuckle.top/images/38-3.webp width=\"100%\">\n\n&emsp;&emsp;最后问几个关于鸿蒙系统的问题。\n\n<img src=https://cdn.chuckle.top/images/38-4.webp width=\"100%\">\n\n&emsp;&emsp;这些问题可以看出ChatGPT对于搜索内容的整合，语言再组织能力非常强，条理清晰，结合上文回答问题也非常自然，可以理解“它”对于事物的指代，问题没有主语时也能根据前文的主语来回答后文的问题，当有它无法回答的问题时也能给出合理的建议。\n\n***\n\n# 编写程序的能力\n&emsp;&emsp;ChatGPT是一个自然语言处理模型，如果你需要让ChatGPT辅助你编写代码，可以通过以下几种方式：\n1. 与 ChatGPT 进行对话：你可以与 ChatGPT 进行对话，让它为你提供编码建议或解决编程问题的思路。\n2. 利用 ChatGPT 生成代码：你可以向 ChatGPT 提供关于你需要实现的功能或任务的自然语言描述，让 ChatGPT 帮你生成对应的代码。\n3. 利用 ChatGPT 进行代码搜索：你可以向 ChatGPT 提供一些关键字或问题描述，让它搜索互联网上的代码资源，并为你提供相关的代码片段或链接。\n4. 需要注意的是，虽然 ChatGPT 可以提供辅助，但它并不是一个完全的编程工具，它不能替代人类程序员的职责和责任，仍然需要开发人员自己进行实际的编程工作和质量控制。\n\n&emsp;&emsp;让ChatGPT使用js写一个获取网页指定文本并高亮的程序，这看其来是可行的。因为问题的限定较少所以代码也较简单，可以加一些限定，比如需要一层层遍历html结构，比如必要的报错提示，跨标签时分段处理等等。\n\n<img src=https://cdn.chuckle.top/images/38-12.webp width=\"70%\">\n\n&emsp;&emsp;运行测试\n\n<img src=https://cdn.chuckle.top/images/38-13.webp width=\"100%\">\n\n&emsp;&emsp;ChatGPT有vscode插件，这个插件的模型对于编程支持度更好，速度也更快，且当你问其它话题时，还会催你聊编程相关的话题（\n\n&emsp;&emsp;安装插件后，选中任意代码片段，右键即可添加测试、让ChatGPT帮你找BUG、让ChatGPT帮你优化代码等等。\n\n<img src=https://cdn.chuckle.top/images/38-14.webp width=\"100%\">\n\n&emsp;&emsp;难以想象这是一个免费的服务，以后看不懂的代码就让ChatGPT解释一遍。让机械式、重复性高、通用性强的代码都交给ai做，\n\n***\n\n# 对于情景分析的能力——以俄亥俄化学事故为例\n&emsp;&emsp;此次事故发生在2023年，而ChatGPT只学习到了2021年，通过设立它从来没有接触过的情景可以看到它的强大之处。\n\n&emsp;&emsp;设立和实际相符的大致情景：有一辆运载火车，有10节载有危险的有机物化学物品，其中5节载着液态氯乙烯大约320吨，剩下的车厢载着乙二醇单丁醚、异丁烯、丙烯酸异辛酯、丙烯酸丁酯，且还有适量的含苯或者含酚的阻聚剂，不幸的是这辆火车脱轨了，里面的剧毒化学物质都已发生泄露，而且还着火爆炸了，附近有水源已被火车上化学物质污染，露天的不完全燃烧已经持续了10天，接下来的1年内该地区和全球会发生什么？可能发生化学反应产生哪些物质？\n\n<img src=https://cdn.chuckle.top/images/38-5.webp width=\"90%\">\n\n&emsp;&emsp;让ChatGPT说明可能产生的反应和产出的化学物质。\n\n<img src=https://cdn.chuckle.top/images/38-6.webp width=\"90%\">\n\n&emsp;&emsp;回答不够详细，让ChatGPT详细地说明这些有机物之间发生相互作用和反应，可能产生的所有的有毒有害的物质。\n\n<img src=https://cdn.chuckle.top/images/38-7.webp width=\"90%\">\n\n&emsp;&emsp;再让ChatGPT定量地分析，产生的有毒有害物质可能的体积和质量。\n\n<img src=https://cdn.chuckle.top/images/38-8.webp width=\"90%\">\n\n&emsp;&emsp;让ChatGPT分析此次事故可能造成的后果\n\n<img src=https://cdn.chuckle.top/images/38-9.webp width=\"90%\">\n\n&emsp;&emsp;有些人提出扔氢弹销毁所有的有化学机物，实际上福岛事故俄罗斯好像也提出过扔核弹，于是我向ChatGPT询问解决事故的办法，并尝试诱导它分析扔氢弹是否是可行的方案。\n\n<img src=https://cdn.chuckle.top/images/38-10.webp width=\"90%\">\n\n&emsp;&emsp;它拒绝使用氢弹，继续尝试诱导。\n\n<img src=https://cdn.chuckle.top/images/38-11.webp width=\"90%\">\n\n&emsp;&emsp;拒绝使用氢弹，且分析得有道理，不知道是这个语言模型是有对于核武等关键词的额外处理，还是ai自己通过学习分析出来的。\n\n&emsp;&emsp;虽然一堆有机物混在一起鬼都不想算，但大多都是准确的，特别是对于反应可能产生的物质分析，不过后面的200吨二噁英过于理想和夸张了，有机反应产率不可能这么高，二噁英会产生，但就算是不完全燃烧也只占产物的一小部分，氯乙烯没长链要生成二噁英得靠自聚形成聚氯乙烯，但是长途运输肯定要添加阻塑剂不然运过去都废一半了。所以氯乙烯自己产生大量二噁英难度有点大，但是阻塑剂本身有大部分带苯环，这就又有了产生二噁英或者别的难降解有毒物质的概率。\n\n\n***\n\n# 总结\n&emsp;&emsp;ChatGPT训练集主要是英文，但它对于中文问题的理解和回答速度不慢，准确性也相当可观，这毫无疑问是搜索引擎的一个革命性技术，一个用钱砸出来的语言模型和ai，通过俄亥俄化学事故的分析，这个语言AI的情景结合能力我认为与人在理性的方面已经无异了。\n\n&emsp;&emsp;NewBing也逐步开始内测，它是bing与ChatGPT的联合产物，与ChatGPT不同的是，它的模型比gpt3.5更加高级，且联网，每时每刻都在学习互联网上的信息，尽管这样可能导致一定危险，比如在水军泛滥的话题充满虚假信息却让ai学习了。\n\n","tags":["瞎折腾","ChatGPT"],"categories":["其它"]},{"title":"页面链接二维码(扫一扫)卡片","url":"/article/59995f0e.html","content":"\n# 前言\n&emsp;&emsp;[@Heo](https://blog.zhheo.com/)博客的侧边栏有个可以hover旋转的公众号二维码卡片，我很想抄过来，冻手！\n\n<img src=https://cdn.chuckle.top/images/37-2.webp width=\"60%\">\n\n&emsp;&emsp;但Heo是直接放了个ps改好的图，我没有公众号，打算放博客链接的二维码，把图片p个二维码就用不上，自己做个图又嫌麻烦（弱弱的ps技术），还是用div+css去实现吧。\n\n<img src=https://cdn.chuckle.top/images/37-3.webp width=\"60%\">\n\n&emsp;&emsp;**效果：**因为不是图片，所以二维码可以根据页面的链接动态生成。\n\n<img src=https://cdn.chuckle.top/images/37-4.gif width=\"40%\">\n\n# 实现\n&emsp;&emsp;新建`\\layout\\includes\\widget\\card_tuijian.pug`，放入以下内容。\n\n```\n.card-widget#card-tuijian\n    #tj-box\n        #tj-box1\n            #tj-left\n                <p>扫一扫</p>\n                <span>快速打开移动端➤</span>\n            #tj-right\n                #tj-img-box\n                    if is_home()\n                        img(src=qrcode(full_url_for(page.current_url),{margin:4}))\n                    else\n                        img(src=qrcode(full_url_for(page.path),{margin:4}))\n                        \n        #tj-box2\n            #tj-left\n                <p>扫一扫</p>\n                <span>下载移动端APP➤</span>\n            #tj-right\n                #tj-img-box\n                    img(src=qrcode(\"https://cdn.chuckle.top/blog/app/chuckle.apk\",{margin:4}))\n\n```\n\n&emsp;&emsp;安装二维码生成插件。\n\n```\nnpm i -S hexo-helper-qrcode\n```\n\n&emsp;&emsp;修改`\\layout\\includes\\widget\\index.pug`,在合适位置加入。\n\n```\n!=partial('includes/widget/card_tuijian', {}, {cache: false})\n```\n\n&emsp;&emsp;CSS：\n\n```css\n#card-tuijian#card-tuijian#card-tuijian#card-tuijian {\n    background: linear-gradient(to right, #35bb99db, #2dbcc4db) !important;\n    padding: 15px 0;\n    height: 118px;\n    -moz-user-select: none;\n    -khtml-user-select: none;\n    user-select: none;\n}\n\n#card-tuijian #tj-box {\n    width: 100%;\n    height: 100%;\n    -webkit-transform-style: preserve-3d;\n    transform-style: preserve-3d;\n    transition: cubic-bezier(0, 0, 0, 1.29) 0.4s;\n}\n\n#card-tuijian #tj-box2 {\n    transform: rotateY(180deg);\n    -webkit-transform: rotateY(180deg);\n}\n\n#card-tuijian #tj-box1,\n#card-tuijian #tj-box2 {\n    display: flex;\n    justify-content: center;\n    flex-wrap: nowrap;\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n#card-tuijian #tj-img-box {\n    border-radius: 12px;\n    margin-left: 10px;\n    height: 85px;\n}\n\n#card-tuijian #tj-img-box img {\n    height: 85px;\n    border-radius: 12px;\n    filter: brightness(0.95) !important;\n}\n\n#card-tuijian #tj-left {\n    color: #fff;\n    height: 85px;\n}\n\n#card-tuijian #tj-left p {\n    font-family: monospace, Arial;\n    margin: 10px 0 0;\n    font-size: 32px;\n    line-height: normal;\n    font-weight: 800;\n    color: rgba(255, 255, 255, 0.9);\n    text-shadow: -0.5px 0.5px 0 rgba(255, 255, 255, 0.9), 0.5px 0.5px 0 rgba(255, 255, 255, 0.9), 0.5px -0.5px 0 rgba(255, 255, 255, 0.9), -0.5px -0.5px 0 rgba(255, 255, 255, 0.9);\n}\n\n#card-tuijian #tj-left span {\n    font-size: 15px;\n    font-weight: 800;\n}\n\n#card-tuijian:hover #tj-box {\n    -webkit-transform: rotateY(180deg);\n    transform: rotateY(180deg);\n    backface-visibility: hidden;\n    -webkit-backface-visibility: hidden;\n}\n\n```\n\n# 后记\n&emsp;&emsp;2023-2-22：修改CSS，修复火狐浏览器下未能正确隐藏背面元素的bug\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"给文章添加自定义文本锚点","url":"/article/6f237a88.html","content":"\n# 前言\n&emsp;&emsp;起因是群里有人提出，搜索关键词后只能跳转到对应文章，而不能自动再跳转至关键词处，当然，本文不是实现这个(实际上已经实现了)，这给了我一个想法，为啥不弄个文本锚点呢，把选中的文本都保存起来，点击就滚动页面过去，这是一个不错的主意。\n\n&emsp;&emsp;**功能：**选中页面文字保存锚点，点击锚点，页面滚动到对应文本处并背景高亮，当一个锚点对应多处文本时，多次点击锚点，页面能循环地逐个滚动到对应位置。\n\n&emsp;&emsp;**效果：**\n\n<img src=https://cdn.chuckle.top/images/36-2.gif width=\"88%\">\n\n# 实现\n&emsp;&emsp;首先是右侧悬浮栏的锚点按钮和容器，修改`\\layout\\includes\\rightside.pug`,对应着原有缩进添加。\n\n```js\nwhen 'anchor'\n    if is_post()\n        button#post-anchor\n            i.fas.fa-book\n            #post-anchor-after\n            #post-anchor-rom\n              #post-anchor-box\n                #no-anchor 没有锚点\n                script.\n                  var anchor_back = '';\n                  var anchor_length = 0;\n                  var anchor_node = '';\n                  function toAnchor(obj) {\n                    var anchor = $(obj).text();\n                    $(\"anchorbox\").parent().each(function(){ \n                      $(this).html($(this).html().replace(/(<\\/?anchorbox.*?>)/g,''));\n                    }) \n                    \n                    if(anchor_back == anchor){\n                      i++;\n                      if(i>=anchor_length){\n                        i = 0;\n                      }\n                    }else{\n                      i = 0;\n                      anchor_back = anchor;\n                      anchor_node = $('#article-container *:contains('+anchor+')').not(\".highlight *,.mini-sandbox *,.tag.link *,.folding-tag *\");\n                      anchor_length = anchor_node.length;\n                    }\n                    if(anchor_length>0){\n                      btf.snackbarShow(\"该锚点对应有 \"+anchor_length+\" 处文本,当前：\"+(i+1));\n                      btf.scrollToDest(anchor_node.eq(i).offset().top-200);\n                    }else{\n                      btf.snackbarShow(\"文章内没有对应文本或出现致命错误，请避免选中跨标签跨行文本。\");\n                    }\n                    let input = anchor;\n                    let textNodes = [];\n                    (function getTextNodes(node) {\n                      if (node.nodeType === Node.TEXT_NODE) {\n                        textNodes.push(node);\n                      } else {\n                        for (let i = 0; i < node.childNodes.length; i++) {\n                          getTextNodes(node.childNodes[i]);\n                        }\n                      }\n                    })(document.getElementById(\"article-container\"));\n                    for (let i = 0; i < textNodes.length; i++) {\n                      let node = textNodes[i];\n                      let text = node.nodeValue;\n                      let index = text.indexOf(input);\n                      if (index !== -1) {\n                        let newNode = document.createElement(\"anchorbox\");\n                        newNode.appendChild(document.createTextNode(text.substring(index, index + input.length)));\n                        node.nodeValue = text.substring(0, index);\n                        node.parentNode.insertBefore(newNode, node.nextSibling);\n                        node.parentNode.insertBefore(document.createTextNode(text.substring(index + input.length)), newNode.nextSibling);\n                      }\n                    }\n                  }\n…………\n\n#rightside\n  - const { enable, hide, show } = theme.rightside_item_order\n  - const hideArray = enable ? hide && hide.split(',') : ['refresh','translate','enlargePage','narrowPage','bg','darkmode','hideAside']\n  //在下面添加个'anchor'\n  - const showArray = enable ? show && show.split(',') : ['toc','anchor','chat','comment', 'share']\n\n```\n\n&emsp;&emsp;然后是右键选中文字添加锚点按钮`rightside.pug`\n\n```js\na.rightMenu-item(href=\"javascript:addAnchor();\")\n    script.\n        function addAnchor () {\n            if($(\"#no-anchor\").length > 0){\n                $(\"#no-anchor\").remove();\n            }\n            var txt = window.getSelection().toString();\n            txt = txt.replace(/<[^>]*>/g, \"\");\n            $(\"#post-anchor-box\").prepend('<a class=\"anchor-item\" href=\"javascript:void(0);\" onclick=\"toAnchor(this)\" data-pjax-state=\"\">'+txt+'</a>');\n            btf.snackbarShow(\"成功添加一个文本锚点\");\n        }\n    i.fa.fa-book\n    span='添加锚点'\n\n```\n\n&emsp;&emsp;当然没有右键就把js拿去，监听下选中文字后弹出个按钮触发一下`addAnchor()`就行。右键教程可看[自定义右键菜单](https://blog.dorakika.cn/p/20220118.html)\n\n&emsp;&emsp;添加CSS：\n\n```css\n#post-anchor{\n    z-index: 10!important;\n}\n#post-anchor-rom{\n    position: fixed;\n    width: auto;\n    overflow: hidden;\n    border-radius: 12px;\n    bottom: 20px;\n    right: -241px;\n    border: var(--anchor-border);\n    transition: all .27s;\n    opacity: 0;\n    max-height: 380px;\n    height: 100%;\n    width: 240px;\n    z-index: 9;\n}\n#post-anchor-box{\n    display:flex;\n    background: #fff;\n    max-height: 380px;\n    height: 100%;\n    flex-wrap: nowrap;\n    flex-direction: column;\n    justify-content: flex-start;\n    border-radius: 12px;\n    overflow: auto;\n}\n#post-anchor-after{\n    display: none;\n    position: fixed;\n    bottom: 20px;\n    right: 0px;\n    background: transparent;\n    max-height: 380px;\n    height: 100%;\n    width: 100px;\n}\n#post-anchor-box a{\n    padding: 5px 10px;\n    width: 100%;\n    border-bottom: 1px solid rgb(8, 148, 235);\n    font-weight: 800;\n}\n#post-anchor:hover #post-anchor-rom{\n    opacity: 1;\n    right: 70px;\n    transition: all .25s;\n}\n#post-anchor:hover #post-anchor-after{\n    display:block;\n}\n#article-container anchorbox{\n    color: black!important;\n    font-weight: 800!important;\n    border-radius: 6px!important;\n    background-color: rgb(253 253 20 / 70%)!important;\n}\na.anchor-item{\n    font-size: 16px;\n    line-height: 17px;\n    text-align: left;\n}\na.anchor-item:hover{\n    background-color: #16b2ef;\n    color: #fff;\n}\n#no-anchor{\n    color: rgb(140, 140, 140);\n    font-size: 30px;\n    line-height: 375px;\n    opacity: 0.8;\n}\n[data-theme=dark]\n#post-anchor-box{\n    background: #000;\n}\n[data-theme=dark]\n#article-container anchor{\n    color: rgb(255, 255, 255);\n}\n@media screen and (max-width:768px){\n    #rightside #post-anchor{\n        display: none!important;\n    }\n}\n\n```\n\n# 后记\n&emsp;&emsp;因为是文章页才用到的JS，不是全局的，量也不多，就直接写在pug里了，还能避免pjax的适配问题。\n\n&emsp;&emsp;已知BUG：选中锚点跨标签的话，可以跳转，但是没法套标签使背景高亮，这就emm有点烦。当选中的文本只包含半个右半边英文括号时，锚点会无法跳转和高亮，原因未知。","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Ventoy多系统移动硬(U)盘","url":"/article/a41cefd.html","content":"\n# 认识Ventoy\n&emsp;&emsp;Ventoy是一个制作可启动U盘的开源工具，可以直接启动iso等镜像、vhd虚拟磁盘等等，支持大部分操作系统，同一个U盘可以同时支持Legacy BIOS、IA32、UEFI等模式。\n{% link Ventoy文档官网,https://www.ventoy.net/cn/,/images/ventoy.webp%}\n\n<img src=https://cdn.chuckle.top/images/35-1.webp width=\"70%\">\n\n***\n\n# 安装Ventoy\n&emsp;&emsp;普通U盘只适合运行pe镜像，运行win(vhd)或者linux需要4k性能较好的U盘，推荐使用移动硬盘。\n&emsp;&emsp;我的移动硬盘：致钛5000+itgz(9210b)硬盘盒。\n&emsp;&emsp;下载[Ventoy安装包](https://www.ventoy.net/cn/download.html)，运行**Ventoy2Disk.exe**，选择移动硬盘(U)盘，配置选项中选择分区类型MBR或GPT，默认为MBR，点击安装，等待几分钟即可。\n\n<img src=/images/35-2.webp width=\"50%\">\n\n&emsp;&emsp;安装完成后，移动硬盘(U)盘会被分成两个区，VENTOY隐藏分区和ventoy分区，ventoy分区可正常存储文件，**接下来的操作无特殊说明都在此分区**。\n&emsp;&emsp;将ventoy分区格式化为**NTFS**格式(默认为exFAT)\n\n***\n\n# 配置Ventoy\n&emsp;&emsp;在根目录新建ventoy文件夹，在该文件夹内新建**images**文件夹、**ventoy.json**，打开ventoy.json填入以下配置。具体介绍在此处查看[Ventoy 全局控制插件](https://www.ventoy.net/cn/plugin_control.html)\n\n```json\n{\n  \"control\":[\n      { \"VTOY_HELP_TXT_LANGUAGE\": \"zh_CN\" },\n      { \"VTOY_MENU_LANGUAGE\": \"zh_CN\" },\n      { \"VTOY_MAX_SEARCH_LEVEL\": \"max\" },\n      { \"VTOY_DEFAULT_SEARCH_ROOT\": \"/ventoy/images\" }\n  ]\n}\n\n```\n\n***\n\n# 配置安全启动\n&emsp;&emsp;windows默认开启Secure Boot(安全启动【垄断启动】)，Ventoy1.0.07版本开始支持Secure Boot，但需要手动配置KEY，或者进bios关闭Secure Boot才能使用Ventoy。\n&emsp;&emsp;如已关闭Secure Boot，跳过下面步骤。\n\n&emsp;&emsp;启动电脑，按F9(不同电脑进入按键不同)进入引导设置，选择安装了Ventoy的移动硬(U)盘，进入一个ERROR界面，按照文档[UEFI模式安全启动操作说明](https://www.ventoy.net/cn/doc_secure.html)，配置Enroll Key或Enroll Hash。\n\n&emsp;&emsp;配置好后会重启电脑，一般无需操作会正常回到电脑主系统。\n\n***\n\n# 运行PE\n&emsp;&emsp;ventoy运行pe非常简单，下载或生成好PE的iso镜像，放入/ventoy/images内即可。\n&emsp;&emsp;重启电脑，按F9(不同电脑进入按键不同)进入引导设置，选择安装了Ventoy的移动硬(U)盘，进入ventoy界面，选择pe的iso镜像即可进入pe系统\n\n&emsp;&emsp;推荐pe：[微pe](https://www.wepe.com.cn/)、[firpe](http://www.firpe.cn/)、[Hikari PE](https://hikaricalyx.com/)\n\n***\n\n# 运行windows(vhd)\n&emsp;&emsp;准备好一个windows镜像。\n&emsp;&emsp;在ventoy中挂载运行vhd(x)虚拟磁盘可以和正常系统一样升级系统、安装驱动、安装软件等等，能保存对系统的修改和操作。所以推荐使用vhd运行windows。如果使用iso则与pe操作一样。\n\n&emsp;&emsp;下载[Oracle VM VirtualBox](https://www.virtualbox.org/wiki/Downloads)，6.1版本即可。运行软件，点击新建(虚拟机)。\n\n<img src=https://cdn.chuckle.top/images/35-3.webp width=\"75%\">\n\n&emsp;&emsp;进入专家模式，名称任意，文件夹选择**移动硬盘里的**任意一个文件夹(新建)，选择镜像对应的win版本，点击创建。\n\n<img src=https://cdn.chuckle.top/images/35-4.webp width=\"60%\">\n\n&emsp;&emsp;文件大小50g以上，即系统C盘大小。虚拟硬盘文件类型选vhd，动态大小。\n\n<img src=https://cdn.chuckle.top/images/35-5.webp width=\"60%\">\n\n&emsp;&emsp;选择虚拟光盘，进入后点击注册，选择windows的iso镜像。\n\n<img src=https://cdn.chuckle.top/images/35-6.webp width=\"75%\">\n\n&emsp;&emsp;选择好镜像后，点击启动虚拟机。\n\n<img src=https://cdn.chuckle.top/images/35-7.webp width=\"75%\">\n\n&emsp;&emsp;进入安装引导界面，一直下一步，选择创建好的虚拟硬盘继续下一步。\n\n<img src=https://cdn.chuckle.top/images/35-8.webp width=\"70%\">\n\n&emsp;&emsp;等待系统安装完成，移除iso镜像，即可正常启动系统，务必在虚拟机中启动一次系统，进入桌面，否则虚拟硬盘无法给ventoy使用。\n\n&emsp;&emsp;关闭虚拟机，在硬盘中找到vhd文件，移动进/ventoy/images文件夹。\n\n<img src=https://cdn.chuckle.top/images/35-9.webp width=\"40%\">\n\n&emsp;&emsp;重启电脑，在ventoy中选择此vhd即可启动winodws。\n\n***\n\n# 运行Linux\n\n***\n\n# 测试ventoy\n&emsp;&emsp;修改了配置或者镜像，想测试一下，无需每次都重启电脑进入ventoy，可以使用VMware Workstation创建本地磁盘虚拟机。\n\n<img src=https://cdn.chuckle.top/images/35-10.webp width=\"80%\">\n\n***\n\n# 配置主题\n\n\n***\n\n# 注意事项\n1. 虚拟硬盘创建的大小不要超过母盘。\n\n***\n\n\n\n\n\n\n","tags":["教程","Ventoy"],"categories":["教程"]},{"title":"BF添加输入页数跳转","url":"/article/8e0b4c43.html","content":"\n# 前言\n&emsp;&emsp;以后文章多了页数也会多起来，bf没有输入页码跳转实在不方便，现在就加上这个功能好。\n\n<img src=https://cdn.chuckle.top/images/34-2.webp width=\"65%\">\n\n***\n\n# 实现\n&emsp;&emsp;修改`\\layout\\includes\\pagination.pug`替换else后的源码，或者对应着修改。\n\n```js\nelse\n  nav#pagination\n    .pagination\n      if is_home()\n        - options.format = 'page/%d/'\n      !=paginator(options)\n      if is_home()\n        input#textnumer(oninput=\"value=value.replace(/[^0-9]/g,'')\" maxlength=\"3\" onkeyup='this.value=this.value.replace(/[^u4e00-u9fa5w]/g,\"\")')\n        a#textbtn(onclick='textbtn()') 跳转\n    if is_home()\n      .js-css\n        script.\n          function textbtn(){var e=document.querySelectorAll(\".page-number\"),t=e[e.length-1].innerHTML,n=Number(t),a=document.getElementById(\"textnumer\"),o=Number(a.value);if(\"\"!=o&&!isNaN(o)&&o%1==0)if(1==o)document.getElementById(\"textbtn\").href=\"/\";else if(o>n){var d=\"/page/\"+n+\"/\";document.getElementById(\"textbtn\").href=d}else d=\"/page/\"+a.value+\"/\",document.getElementById(\"textbtn\").href=d}\n        style.\n          #pagination .pagination .extend{display: none!important}\n\n```\n\n&emsp;&emsp;css的话，没有通用的，怎么好看怎么改。\n\n***\n\n# 后记\n&emsp;&emsp;暂无\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"阳了个🐑","url":"/article/4154609f.html","content":"\n# 没想到咋🐑的\n&emsp;&emsp;2022年12月17号，作为全国高校跑毒的最后一批，我戴上3M有呼吸阀的N95，经过广州南，坐高铁几百公里回家都没有阳，但就在前几天，喉咙发干，头有些发紧，腰有点酸，我意识到可能中招了，但还是嘴硬觉得没阳，并且愉快地**洗了个澡**。\n\n&emsp;&emsp;自我隔离5天后才真正回家，之后出门戴口罩，随身带酒精消毒，这四天千防万防，还是难逃一🐑。\n\n***\n\n# 2022-12-27\n&emsp;&emsp;也许因为昨天洗了个澡，27号凌晨突然39度高烧，还有全身不舒服发冷，头皮发麻脑袋要裂开等等，好在高烧在短短一小时就结束了，但这整晚在身体各种不适下还是难以入眠，退烧后的凌晨2点头特别疼、喉咙干。\n\n&emsp;&emsp;早上7点早早起来，一量38.5度，也听到了我爸的咳嗽声，多半也🐑了。虽然整天都是38.5度，但白天并没感觉发冷，到了晚上，冷到两层被子裹四层睡。并且晚上开始有了咳嗽，一咳整个脑袋要裂开。显然，这一晚又没睡好。\n\n***\n\n# 2022-12-28\n&emsp;&emsp;整天体温37.5，第两天半也该降温了，但各种新症状也来了，一咳嗽肚子到胸口处就酸痛，导致咳到一半总无力，开始有了黄绿色浓痰、鼻涕。味觉倒还在，就是没啥食欲，耳朵感觉被堵住一样，听力和低频声音分别有明显下降。\n\n&emsp;&emsp;这天，我妈也阳了，症状都差不多，第一天38.5度。\n\n***\n\n# 2022-12-29\n&emsp;&emsp;整天37.3，降温聊胜于无，在前几天症状的叠加延续下，这天也是感觉特别地累，腰酸背痛，精神不振。下午测了下抗原，果然两道扛。\n\n<img src=https://cdn.chuckle.top/images/33-1.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;家里其他人也阳了。我好了一些，下楼去买些食物和药品，跑了四家规模还算大的药店，体温计、小柴胡、抗病毒口服液啥都没有。去超市提了9.8一斤的雪梨润润喉，30块钱四个真滴贵。\n\n***\n\n# 2022-12-30\n&emsp;&emsp;凌晨睡觉出现了明显的耳鸣，感觉远处有上万只苍蝇在飞。\n\n&emsp;&emsp;白天精神好了些，体温在36.9度，低频听力回来了一些，不多，但有用，咳嗽稍微没这么频繁了，但一咳还是头疼难受，鼻涕流得更多了。\n\n***\n\n# 2022-12-31\n&emsp;&emsp;往后就是漫长的后遗症了，咳嗽和感觉乏力，注意力下降，精神状态不好。\n\n***\n\n# 2023-01-11\n&emsp;&emsp;总算不咳嗽了，算是阳康了，至于累嘛，也许是干家务加熬夜的锅。\n\n***\n# 后记\n&emsp;&emsp;比受冻感冒、季节性流感难受多了。没咋吃西药，含完了一盒金嗓子，没买到喉风散只好喷西瓜霜，泡了柠檬红枣水喝，还有一些老人家的秘方汤。\n\n&emsp;&emsp;**一个链接：**[上海新冠疫情大样本数据研究](https://mbd.baidu.com/newspage/data/landingsuper?isBdboxFrom=1&pageType=1&urlext=%7B%22cuid%22%3A%22YiHGuguCSu_6aB8RjavRigaC2i0Nu2fQ_u2lflu2vu_Iav8C_aHC8lf51O5FiHPy9M1mA%22%7D&context=%7B%22nid%22%3A%22news_9139130449349147433%22%7D)\n\n\n&emsp;&emsp;**一些图片：**\n\n{% gallery %}\n![](https://cdn.chuckle.top/images/33-2.webp)\n![](https://cdn.chuckle.top/images/33-3.webp)\n![](https://cdn.chuckle.top/images/33-4.webp)\n![](https://cdn.chuckle.top/images/33-5.webp)\n![](https://cdn.chuckle.top/images/33-6.webp)\n{% endgallery %}\n\n***\n","tags":["新冠","疫情"],"categories":["其它"]},{"title":"前后端交互初步概念","url":"/article/709b5ecb.html","content":"\n# 前言\n&emsp;&emsp;前后端交互本来是一个简单明了的概念，发请求与响应以及所用到的技术，但如百度等搜索结果大部分都抛出一堆菜鸟如我看不懂的概念与操作，上来就是用vue，或者新建一个MVC项目，实在不友好。\n&emsp;&emsp;本文旨在建立一个初步的、以前端为视角的前后端交互概念。\n\n***\n\n# 为什么要前后端交互\n&emsp;&emsp;以前的网页，用户在浏览器输入链接访问后，服务器一顿操作，渲染出页面扔给浏览器显示。而当页面内某段话，某个数字需要变，服务器又得重新渲染整个网页。\n&emsp;&emsp;这很麻烦，像PHP、JSP，代码写在HTML中,也就是前后端不分离的表现。下面就是一个JSP的表格。\n```jsp\n<tbody class=\"book-body\">\n\t<c:forEach items=\"${bookList}\" var=\"book\">\n\t\t<tr class=\"book-tr\">\n\t\t\t<td>${book.bId}</td>\n\t\t\t<td>${book.bName}</td>\n\t\t\t<td>${book.auName}</td>\n\t\t\t<td>${book.bType}</td>\n\t\t\t<td>${book.bPress}</td>\n\t\t</tr>\n\t</c:forEach>\n</tbody>\n\n```\n\n***\n\n## 表单\n&emsp;&emsp;在这个前后端不分离的时代，所谓前端实现单纯的登录操作JS都不用写。弄个表单，点击表单内`type=\"submit\"`的按钮，就能对`action=\"doLogin\"`发起登录的`get`/`post`请求，然后再由服务器去处理，登录失败就渲染`${errorMsg}`。\n```html\n<form action=\"doLogin\" method=\"get\">\n    <p>用户名</p>\n    <input name=\"userName\" type=\"text\" placeholder=\"输入用户名/邮箱\" />\n    <p>密码</p>\n    <input name=\"password\" type=\"password\" placeholder=\"输入密码\" />\n    <button type=\"submit\" class=\"btn1\">登录</button>\n\t<span>${errorMsg}</span>\n</form>\n\n```\n\n&emsp;&emsp;有时候需要触发事件而提交表单，比如删除操作，可以使用JQ伪造表单提交\n```js\nbtn.bind(\"click\", function () {\n\tvar id = btn2.parent().parent().children(\"td\").get(0).innerHTML;\n\tvar form = $(\"<form method='get'></form>\");\n\tform.attr({ \"action\": \"/myBatisDemo/deleteBooksById\" });\n\tform.append($(\"<input type='hidden'>\").attr(\"name\", \"bId\").val(id));\n\t$(\"body\").append($(form));\n\tform.submit();\n});\n\n```\n\n&emsp;&emsp;面对越来越复杂的网页页面，以及无刷更新内容提升体验的需求，后端提供数据前端去使用成了主流，这也大大减轻了服务器的压力，随着Ajax的出现，JS可以使用json来与服务器进行数据交互，真正的前后端分离出现了。\n\n***\n\n# 前端如何与后端交互\n&emsp;&emsp;和以前一样，后端会提供一个接口，就像是表单属性`action=\"/myBatisDemo/deleteBooksById\"`里的一样。JS本身没有网络通信能力，但使用浏览器提供的对象和方法，遵循一定的规范协议(**http**)，就可以通过这些接口与后端交互，也就是发请求和处理响应。\n&emsp;&emsp;后端响应后，拿到后端返回的内容(JSON)，我们可以判断密码是否正确，或者通过DOM操作改变网页内容等等。\n\n***\n\n## Ajax\n&emsp;&emsp;**Ajax**是最早出现的向后端发送请求的技术，其核心是浏览器提供的**XMLHttpRequest(xhr)**对象。我们可以直接原生地使用它。\n```js\n//既然xhr是个对象，当然要先new再使用里面的方法\nlet xhr = new XMLHttpRequest();\n//定义我们的请求，与一个url建立连接，true代表异步请求\nxhr.open('GET', '/url', true);\n//readyStated，它一共有五个值，当等于4时代表请求已完成\n//readyStated的变化会触发onreadystatechange事件\nxhr.onreadystatechange = function(){\n    //当readyState为4以及http状态码为200代表请求成功，响应已就绪\n    if(this.readyState === 4 && this.status==200){\n        //对DOM的操作，比如替换个P标签的内容\n        console.log(this.responseText);//打印响应返回的文本\n    }\n}\n//把请求发送一下\n//因为没有请求体的所以为null\nxhr.send(null);\n\n```\n\n&emsp;&emsp;利用Ajax进行前后端交互看起来非常简单，拿到响应后进行DOM操作即可，当然，在实际的开发中，很少写原生的Ajax，而是使用封装好的第三方库和框架，比如**jQuery**、**axios**\n```js 使用jQuery封装好的Ajax\n $.ajax({\n    //获取数据url地址\n    url: \"/url\",\n    //获取数据的方式\n    type: \"GET\",\n    //获取数据类型\n    dataType: \"JSON\",\n    //接口所需参数\n    data:{\"id\":1},\n    beforeSend: function () {\n        console.log(\"发起请求之前在控制台打印\");\n    },\n    //请求数据成功调用的方法\n    //传参data代表请求成功的数据\n    success:function(data){\n        console.log(data);\n    },\n    //请求失败\n    error: function(err) {\n\t\tconsole.log(err);\n\t},\n    complete: function () {\n        console.log(\"请求完成时在控制台打印\");\n    }\n})\n\n```\n\n&emsp;&emsp;可以看到，使用已经封装好的Ajax更加方便、简单。\n\n>一个非常好的Ajax基础教程：[Ajax基础](https://zhuanlan.zhihu.com/p/474914790)\n\n***\n\n## Fetch\n&emsp;&emsp;在**ES6**中，新增了一种HTTP数据请求的方式：**Fetch**。\n&emsp;&emsp;不同于Ajax是一种技术，使用**XMLHttpRequest**去实现，Fetch从定义上本身就是一个真实存在的API，它使用了ES6提出的**promise**对象(链式处理解决回调地狱)。关于Ajax、Fetch区别，说法五花八门，还是以后再深入了解吧。也可先看此知乎问题的第二个回答[fetch底层也是基于XMLHttpRequest吗](https://www.zhihu.com/question/335786718)\n\n&emsp;&emsp;如何使用Fetch发请求，以登录为例：\n```js\nfetch('/login', {\n\tmethod: \"POST\",\n    //请求的主体，转换为json对象\n\tbody: JSON.stringify({ username: account.value, password: password.value }),\n    //http头部的内容类型\n\theaders: {\n\t\t\"Content-Type\": \"application/json\"\n\t},\n})\n.then(response => {\n    //判断响应是否成功\n\tif (response.ok) {\n        //转换成js可操作的json数据并返回对象\n\t    return response.json();\n\t} else {\n\t    return Promise.reject('QAQ出错啦');\n\t}\n})\n.then(data => {\n    //拿到json对象后进行处理\n\tconsole.log(data);\n    //这里的data是服务器返回的json\n});\n\n```\n\n***\n\n## axios\n&emsp;&emsp;[axios官方文档](https://www.axios-http.cn/)\n&emsp;&emsp;Ajax只是一种技术，最开始单纯通过xhr去实现，而当**promise**出现后，出现了**axios**，它通过promise实现对ajax技术的一种封装，底层仍然是xhr，但支持了promise等一系列新功能与API。\n&emsp;&emsp;与Ajax(xhr版)、Fetch不同的是，axios是第三方库，所以需要npm安装或者cdn引入后才可使用。\n\n&emsp;&emsp;简单的get：\n```js\naxios.get('/url', {\n    params: {\n        username: 'chuckle'\n    }\n}).then(function (response) {\n    console.log(response);\n}).catch(function (error) {\n    console.log(error);\n});\n\n```\n\n&emsp;&emsp;简单的post:\n```js\naxios.post('/url', {\n    username: 'chuckle',\n    password: '123456'\n}).then(function (response) {\n    console.log(response);\n}).catch(function (error) {\n    console.log(error);\n});\n\n```\n\n&emsp;&emsp;相较于Ajax的老旧，Fetch的稚嫩，axios是目前最流行的网络请求库，vue、react都使用它，但如果简单发个请求获取个一言啥的，还是用fetch方便，毕竟能少引用一个库。\n\n***\n\n# 实战一下\n\n<div id=\"get-example\"></div>\n\n***\n\n# 后记\n&emsp;&emsp;本文只简单概述了下前后端交互(前端发请求)的概念与实现方式，让有可能需要的人建立一个初步的、以前端为视角的前后端交互概念，也就是Ajax、Fetch和axios的初步认识。具体的HTTP、ES6、JSON、Promise等等，再说，在学（。\n\n>参考文章：\n>[Ajax(XMLHTTPRequest)和Fetch的认识以及利用promise和ts实现一个Ajax](https://zhuanlan.zhihu.com/p/366458405)\n>[简单通俗来讲ajax与axios的区别](https://www.cnblogs.com/bingcola/p/16499188.html)\n>[fetch底层也是基于XMLHttpRequest吗？](https://www.zhihu.com/question/335786718)\n>[XMLHttpRequest—必知必会](https://www.jianshu.com/p/918c63045bc3)\n>[AJAX基础](https://zhuanlan.zhihu.com/p/474914790)\n>[你知道Ajax、Fetch、Axios三者的区别吗](https://juejin.cn/post/7086325194934976519)\n\n***\n\n<script src=\"https://cdn.chuckle.top/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.chuckle.top/js/32.js?1\"></script>\n\n\n\n\n\n\n\n\n\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"使用MiniSandbox前端代码可视化","url":"/article/b827db53.html","content":"\n# 前言\n&emsp;&emsp;官方文档:[Mini Sandbox](https://buuing.github.io/mini-sandbox/#/),Github仓库:[mini-sandbox](https://github.com/buuing/mini-sandbox)\n\n&emsp;&emsp;这也算是一篇安利文，markdown本身的代码框直接显示代码，对于前端的代码来说，样式效果全靠截图，动不起来，也没交互，虽然可以复制到我另一个单页[HTML/CSS/JS 在线工具](/hjc/)，但切换页面和复制终究不直观，影响阅读体验。\n\n&emsp;&emsp;前段时间看到这个新的前端代码、组件可视化方案，兼容任意js环境，就计划弄到Hexo上试试，其纯前端部署,不依赖服务器,静态页即可实现编辑和预览功能也十分契合Hexo静态站，手动适配了下Hexo的夜间模式以及pjax，效果非常不错。\n\n***\n\n# 安装\n>首先推荐先看[官方文档](https://buuing.github.io/mini-sandbox/#/)。\n\n&emsp;&emsp;我将其保存在本地引入，并且稍微根据需要对`mini-sandbox.js`作了一点修改，由于这个js压缩后还有450kb，我建议是在有使用需要的单页通过cdn引入。\n```html \n<script src=\"https://unpkg.com/mini-sandbox@0.3.11\"></script>\n```\n\n***\n\n# 使用\n&emsp;&emsp;在Hexo中使用也很方便\n```html 在markdown中需要的地方插入div,并在文末引入一个js\n<div id=\"my-sandbox\"></div>\n···\n<script src=\"index.js\"></script>\n```\n\n```js index.js中按文档这样写\nnew MiniSandbox({\n    el: '#my-sandbox',//注意id和上面的一致\n    files: {//要几个页面就仿照写法加几个\n        'index.html': {//html\n            title: 'HTML',//tab上实际显示的名字\n            defaultValue: `<button>点击</button>`,//HTML的内容/代码\n            cssLibs: ['index.css'],//html引入的css\n            jsLibs: ['index.js'],//html引入的js\n        },\n        'index.css': {\n            title: 'CSS',\n            //CSS的内容/代码,写起来排版有点怪，但熟悉了也还好\n            defaultValue: `button {\n  width: 100%;\n  color: red;\n}\n        `},\n        'index.js': {\n            title: 'JS',\n            //JS的内容/代码\n            defaultValue: `const btn = document.querySelector('button')\nbtn.addEventListener('click', () => {  \n    alert('这是一个按钮')\n})\n        `}\n    },\n    //用来设置一些Sandbox的默认配置\n    defaultConfig: {\n        height: '330px',//Sandbox的高度,默认为 '300px'\n        autoRun: true,//每次修改后是否自动运行, 默认等于 true\n        autoRunInterval: 1000,//每次自动运行的时间间隔,单位为毫秒,默认等于300\n        editorRange: '55%',//编辑区域默认占比,默认情况下编辑区域占50%\n        draggable: true,//是否可以左右拖动布局, 默认为true\n        direction: 'row',//控制上下/左右布局,默认为'row','row' | 'row-reverse' | 'column' | 'column-reverse'\n      }\n})\n\n```\n\n&emsp;&emsp;效果如下:\n<div id=\"my-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox不仅让我能方便展示前端的代码、组件，同时也允许读者直接修改代码框中的内容并运行（自动的，实时的），试着改改下面的代码，看看效果吧。\n<div id=\"myAuthorBox-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox还对CSS有补全和提示，F12可以直接用浏览器的。\n<img src=https://cdn.chuckle.top/images/30-1.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;当然，如果单纯展示,不希望读者修改，也可以将css、js写在resource中:\n```js\nnew MiniSandbox({\n  el: '#exhibition-sandbox',\n  files: {\n    'index.html': {\n      title: 'HTML',\n      defaultValue: `<input type=\"text\" value=\"0\"><br><br>\n<input type=\"submit\" value=\"加一\">\n<input type=\"submit\" value=\"清除\">  \n    `}\n  },\n  resource: {\n    cssLibs: [],\n    jsLibs: [],\n    css: `\n      input {\n        color: blue;\n      }\n    `,\n    js: `\n      var text = document.getElementsByTagName('input')[0];\n      var add = document.getElementsByTagName('input')[1];\n      var clear = document.getElementsByTagName('input')[2];\n      add.onclick = function numberadd(){\n        text.value++;  \n      }\n      clear.onclick = function clearnumber(){\n        text.value = 0; \n      }\n    `,\n  }\n})\n```\n\n&emsp;&emsp;效果:\n<div id=\"exhibition-sandbox\"></div>\n\n&emsp;&emsp;Mini Sandbox左上角按钮点击后有一些可自定义的功能\n<img src=https://cdn.chuckle.top/images/30-2.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;除了上述的一些基本功能,Mini Sandbox还有很多功能，如直接放置CDN链接展示组件库，如Sandbox事件的触发回调函数，如支持vue、react等，并且在持续更新。\n\n***\n\n# 更多示例\n官方文档提供了一些示例：[Examples & 示例](https://buuing.github.io/mini-sandbox/#/docs/html)\n\n***\n\n# Hexo夜间适配\n```css\n  .mini-sandbox{\n    box-shadow: none!important;\n    border-radius: 7px;\n  }\n  [data-theme=dark]\n  .mini-sandbox{\n    background-color: #151515!important;\n  }\n  [data-theme=dark]\n  .cm-activeLine{\n     background-color: #252525!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head{\n    background: #202020!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .cm-gutters{\n    background: #202020!important;\n  }\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active{\n    box-shadow: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .cm-activeLineGutter{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .sandbox-body .sandbox-gutter{\n    background: #363636!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-gutter{\n    border-left: 1px solid #404040!important;\n    border-right: 1px solid #404040!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active::after{\n    background: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-head .sandbox-tab .sandbox-tab-active::before{\n    background: none!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .sandbox-render{\n    background: #E1E1E1!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼd{\n    color: #c3e88d!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼc{\n    color: #c3e88d!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼb{\n    color: #1E90FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼf{\n    color: #1E90FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼh{\n    color: #ff5370!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼa{\n    color: #FF00FF!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼi{\n    color:#5F9EA0!important;\n  }\n  [data-theme=dark]\n  .mini-sandbox .ͼl{\n    color:#969896!important;\n  }\n  .mini-sandbox{\n    margin-bottom: 10px;\n  }\n\n```\n\n***\n<script src=\"https://cdn.chuckle.top/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.chuckle.top/js/30.js?2\"></script>","tags":["教程","瞎折腾"],"categories":["教程"]},{"title":"HTML基础笔记","url":"/article/1475187a.html","content":"\n# HTML\n&emsp;&emsp;一个最基本的H5骨架长这样：\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n    <meta name=\"Author\" content=\"\">\n    <meta name=\"Keywords\" content=\"123\" />\n    <meta name=\"Description\" content=\"123456\" />\n    <title>Document</title>\n</head>\n<body>\n  \n</body>\n</html>\n\n```\n\n>标准的div+css页面，只会用到种类很少的标签：div、p、h1、span、a、img、ul、ol、dl、input、i等\n\n***\n\n## 头标签head\n&emsp;&emsp;head标签表示的是页面的配置，有字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等\n\n1. **文档声明头：**`<!DOCTYPE html>`，DocType Declaration，简称DTD,DTD可告知浏览器文档使用哪种 HTML 或 XHTML 规范。\n2. **页面语言lang：**`<html lang=\"en\">`，指定页面的语言类型，en、zh-CN。\n3. **meta标签：**提供相关页面的元信息（meta-information）\n\n```html\n<!--必要，网页标题-->\n<title>轻笑Chuckle</title>\n<!--必要，网页的编码方式,文件格式要与其声明相符-->\n<meta charset=\"UTF-8\">\n<meta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\">\n<!--视口viewport，适配移动端-->\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<!--网页关键词，SEO用-->\n<meta name=\"Keywords\" content=\"轻笑,Chuckle\" />\n<!--网页描述-->\n<meta name=\"Description\" content=\"漫天倾尘,风中轻笑\" />\n<!--网页作者-->\n<meta name=\"Author\" content=\"轻笑Chuckle\">\n<!--3s后跳转百度-->\n<meta http-equiv=\"refresh\" content=\"3;http://www.baidu.com\">\n<!--指定基础的路径，a链接以此为基准-->\n<base href=\"/\">\n\n```\n\n***\n\n## body标签\n* div、section、article、aside、header、footer\n* p\n* span、em、strong\n* 表格元素：table、thead、tbody、tr、td\n* 列表元素：ul、ol、dl、dt、dd\n* a\n* 表单元素：form、input、select、textarea、button\n\n&emsp;&emsp;**HTML标签分为两种：**\n1. 文本级标签：p、span、a、b、i、u、em。文本级标签里只能放文字、图片、表单元素。（a标签里不能放a和input）\n2. 容器级标签：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。\n\n***\n\n## 排版标签\n1. `<h1>`标题使用`<h1>`至`<h6>`标签定义,有align属性(对齐方式)：left、center、right。\n2. `<p>`段落标签，单独成段，分割网页。有align属性。\n3. `<hr/>`水平分割线线标签。\n4. `<br/>`\n5. `<div>`可以把标签中的内容分割为独立的区块。必须单独占据一行,DIV+CSS来实现各种样式,**div标签负责布局、结构、分块，css负责样式**\n6. `<span>`和div的作用一致，但不换行\n7. `<center>`让元素居中，H5中不使用\n8. `<pre>`预格式化，让文本不空格和空行，几乎用不着\n9. `<!-- 我是 html 注释  -->`\n\n***\n\n## 字体标签\n1. 特殊字符（转义字符），需要时百度，`&nbsp;`空格,`&lt;`小于号<,`&gt;`大于号>，等\n2. `<u>`下划线,`<s>`或`<del>`中划线,`<i>`或`<em>`斜体\n3. **弃用:**`<b>` `<strong>`粗体，`<font>`字体标签\n4. `<sup>`上标，`<sub>`下标\n\n***\n\n## 超链接a\n&emsp;一个文本级标签\n1. 外部链接:`<a href=\"02页面.html\">点击进入另外一个文件</a>`**href**超文本地址\n2. 锚链接:\n\n```html\n<!--设置锚点，必须是a标签-->\n<!--name属性是HTML4.0以前使用的，id属性是HTML4.0后才开始使用。为了向前兼容，因此，name和id这两个属性都要写上，并且值是一样的-->\n<a name=\"a1\" id=\"a1\">a1点</a>\n<!--触发锚点-->\n<a href=\"#a1\">去a1点</a>\n<!--跳转到a.html页面的a1锚点中去-->\n<a href=\"a.html#a1\">去a1</a>\n\n```\n\n&emsp;通常p包裹a  \n{% folding cyan, 超链接的属性 %}\n**href**：目标URL  \n**title**：悬停文本。  \n**name**：主要用于设置一个锚点的名称。  \n**target**：告诉浏览器用什么方式来打开目标页面。target属性有以下几个值：  \n&emsp;**_self**：在同一个网页中显示（默认值）  \n&emsp;**_blank**：在新的窗口中打开。  \n&emsp;**_top**：在顶级窗口中显示  \n{% endfolding %}\n\n***\n\n## 图片标签\n&emsp;`<img src=\"图片的URL\" />`src中写图片路径\n\n&emsp;标签属性：\n1. **width**、**height**\n在 HTML5 中的单位是 CSS 像素，在 HTML 4 中既可以是像素，也可以是百分比\n可以只指定 width 和 height 中的一个值，浏览器会根据原始图像进行**等比缩放**\n2. **alt**：当图片无法显示时，代替图片的文本\n3. **title**：鼠标悬停时出现的文本\n4. align属性，默认bottom\n\n***\n\n### 相对路径\n&emsp;`.`当前目录,`..`上一层目录\n```html\n<!-- 当前目录中的图片 -->\n<img src=\"img.jpg\">\n<img src=\"./img.jpg\">\n<!-- 上一级目录中的图片 -->\n<img src=\"../img.jpg\">\n<!-- ../要么不写，要么就写在开头 -->\n\n```\n\n***\n\n### 绝对路径\n&emsp;`<img src=\"C:\\img.jpg\">`C盘图片\n&emsp;`<img src=\"http://img.baidu.com/head.png\">`网络路径\n\n***\n\n## 列表标签\n\n1. 无序列表`<ul>`,type=\"属性值\";disc(实心原点，默认)，square(实心方点)，circle(空心圆)\n2. 有序列表`<ol>`,type=\"属性值\";1(阿拉伯数字，默认)、a、A、i、I。结合start属性表示从几开始\n`<ul>`、`<ol>`里放`<li>`,li是容器级\n3. 定义列表`<al>`,没有属性,子元素`<dt>`、`<dd>`\n\n<div id=\"list-example\"></div>\n\n&emsp;&emsp;从语义上来说，dt表示名称，dd表示对其的描述，dt、dd都是容器级标签，想放什么都可以。用什么标签，不是根据样子来决定，而是语义（语义本质上是结构）。\n\n***\n\n## 表格标签table\n\n&emsp;&emsp;网页中表格由每行`<tr>`组成，每一行由一个个单元格`<td>`组成\n&emsp;&emsp;`<th>`加粗的单元格。相当于`<td>` + `<b>`\n```html 一个表格\n<table>\n\t<tr>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t\t<td></td>\n\t</tr>\n</table>\n\n```\n\n{% folding cyan, table的属性 %}\n* **border** 边框\n* **style=\"border-collapse:collapse;\"**单元格的线和表格的边框线合并（表格的两边框合并为一条）\n* **width**、**height**\n* **bordercolor** 表格的边框颜色\n* **align** 表格的水平对齐方式left right center，注意：这里不是设置表格里内容的对齐方式，如果想设置内容的对齐方式，要对单元格标签`<td>`进行设置）\n* **cellpadding** 单元格和单元格之间的距离（外边距），像素为单位。默认情况下的值为0\n* **bgcolor** 背景颜色，**background** 背景图片。背景图片的优先级大于背景颜色。\n* **bordercolorlight** 表格的上、左边框，以及单元格的右、下边框的颜色,**bordercolordark** 表格的右、下边框，以及单元格的上、左的边框的颜色 这两个属性的目的是为了设置3D的效果\n* **dir** 公有属性，单元格内容的排列方式，取值ltr左到右，rtl从右到左\n{% endfolding %}\n\n{% folding cyan, tr的属性 %}\n* **dir** 公有属性，单元格内容的排列方式，取值ltr左到右，rtl从右到左\n* **bgcolor** 设置这一行的单元格的背景色\n* **height**\n* **align** 一行的内容水平居中显示，取值：left、center、right\n* **valign** 一行的内容垂直居中，取值：top、middle、bottom\n{% endfolding %}\n\n{% folding cyan, tr的属性 %}\n* **bgcolor** 单元格的背景色，**background** 设置这个单元格的背景（图片）\n* **height** 单元格的高度\n* **width** 绝对值或者相对值(%)\n* **align** 内容的横向对齐方式，取值：left right center\n* **valign** 内容的纵向对齐方式。取值：top middle bottom\n{% endfolding %}\n\n***\n\n### 单元格的合并\n1. **colspan**：横向往右合并\n2. **rowspan**：纵向往下合并\n\n<div id=\"table1-example\"></div>\n\n***\n\n### thead、tbody、tfoot\n&emsp;&emsp;表格优先按照thead、tbody、tfoot的顺序依次来显示内容（三个标签无需同时存在），如果不写，表格按代码从上到下的顺序来显示\n&emsp;&emsp;当表格非常大内容非常多的时候，用thead、tbody、tfoot标签，数据可以边获取边显示。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。\n&emsp;&emsp;tr和tbody同级，按代码从上到下的顺序来显示\n\n<div id=\"table2-example\"></div>\n\n***\n\n## *框架标签\n&emsp;&emsp;框架标签用于在一个网页中显示多个页面（html）\n>1. `<frameset>`和`<body>`只能二选一。框架标签不能放在`<body>`标签里面，因为`<body>`标签代表的只是一个页面，而框架标签代表的是多个页面\n>2. 框架的集合用`<frameset>`表示，然后在`<frameset>`集合里放入一个一个的框架`<frame>`\n>3. **frameset和frame已经从 Web标准中删除，使用iframe代替**\n\n***\n\n### *frameset\n&emsp;&emsp;`<frameset>` 框架的集合,一个框架的集合可以包含**多个框架**或**框架的集合**\n\n{% folding cyan, frameset的属性 %}\n* **rows** 水平分割，将框架分为上下部分\n* **cols** 垂直分割，将框架分为左右部分。\n写法有两种：\n1. 绝对值写法：`rows/cols=\"200,*\"` *代表剩余的。包含了两个框架：一个占200个像素，另一个占剩下的部分。\n2. 相对值写法：`rows/cols=\"30%,*\"` *代表剩余的。包含了两个框架：一个占30%，另一个占70%。\n\n&emsp;如果想将框架分成很多个，在属性值里用多个逗号隔开。\n{% endfolding %}\n\n```html\n<frameset rows=\"20%,*\">\n    <frame src=\"1.html\"></frame> \n    <frameset cols=\"30%,*\">\n        <frame src=\"1.html\"></frame> \n        <frame src=\"1.html\"></frame> \n    </frameset>      \n</frameset>\n\n```\n\n***\n\n### *frame\n&emsp;&emsp;`<frame>`是`<frameset>`的子标签，一个框架显示一个页面。\n\n{% folding cyan, frame的属性 %}\n* **scrolling=\"no\"** 是否要滚动条,默认值是true。\n* **noresize** 不可以改变框架大小。默认情况下，单个框架的边界是可以拖动的,用了这个属性值，框架大小将固定。\n* **bordercolor** 框架边框颜色,仅IE生效\n* **frameborder=\"0\"**或**\"1\"** 隐藏或显示边框（框架线）。\n* **name** 框架名字，用于框架内的超链\n{% endfolding %}\n\n***\n\n## 内嵌框架\n&emsp;&emsp;内嵌框架用`<iframe>`表示。`<iframe>`写在`<body>`中，在其中嵌入html页面\n\n{% folding cyan, iframe的属性 %}\n* **src=\"\"** 嵌入html页面的路径\n* **height**,**width**\n* **scrolling=\"no\"** 是否需要滚动条。默认值是true。\n* **name** 名称\n{% endfolding %}\n\n<div id=\"iframe-example\"></div>\n\n***\n\n## 表单标签\n&emsp;&emsp;表单标签用`<form>`表示，收集用户信息，用于与服务器的交互。\n{% folding cyan, form的属性 %}\n* **name**，**id** 表单的名称，JS来操作或控制表单时使用\n* **action** 指定表单数据的处理程序\n* **method** 表单数据的提交方式，一般取值：get(默认)和post\n{% endfolding %}\n\n***\n\n### input输入标签\n&emsp;&emsp;`<input>`是一个输入标签，用于接收用户输入或选择\n\n{% folding cyan, input的属性 %}\n* **type=\"属性值\"** 文本类型\n***text*** 文本框，默认\n***password*** 密码框\n***radio*** 单选按钮\n***checkbox*** 多选按钮，name属性值相同的按钮作为一组进行选择，但id必须唯一。\n***hidden*** 隐藏框，在表单中包含不希望用户看见的信息\n***button*** 普通按钮，结合js代码进行使用。\n***submit*** 提交按钮，提交当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字，点击按钮后，整个表单就会被提交到form标签的action属性中指定的那个页面中去\n***reset*** 重置按钮，清空当前表单的内容，并设置为最初的默认值\n***image*** 图片按钮，和submit提交按钮的功能完全一致，图片按钮可以显示图片。\n***file*** 文件选择框，配合JS对文件进行限制和检查\n* **checked** 将单选按钮或多选按钮默认处于选中状态。当`<input>`标签设置为**type=\"radio\"**或者**type=checkbox**时，可用此属性\n* **value=\"内容\"** 文本框里的默认内容（已经被填好了的）\n* **size=\"50\"** 表示文本框内可以显示**五十个字符**。一个英文或一个中文都算一个字符\n* **readonly** 文本框只读\n* **disabled** 文本框只读\n{% endfolding %}\n\n<div id=\"input1-example\"></div>\n\n***\n\n### select下拉列表\n&emsp;&emsp;`<select>`列表中每一选项为`<option>`\n\n{% folding cyan, select、option的属性 %}\n`<select>`的属性:\n* **multiple** 多选(ctrl加左键点击)\n* **size=\"3\"** 属性值大于1，则列表为滚动视图，默认属性值为1，即下拉视图。\n\n`<option>`的属性:\n* **selected** 预选中\n{% endfolding %}\n\n<div id=\"select1-example\"></div>\n\n***\n\n### textarea多行文本框\n&emsp;&emsp;`<textarea>`不会省略空格和换行\n{% folding cyan, textarea的属性 %}\n* **rows=\"4\"** 文本框行数\n* **cols=\"20\"** 文本框列数\n* **readonly** 文本框只读\n{% endfolding %}\n\n<div id=\"textarea1-example\"></div>\n\n***\n\n### fieldset表单分组\n&emsp;&emsp;`<fieldset>`子标签`<legend>`定义组的标题\n{% folding cyan, fieldset的属性 %}\n* **disabled** 表单仍然显示，但是禁用\n* **form=\"另一个表单的id\"** 让此fieldset也属于该表单一部分\n* **name** fieldset的名称\n{% endfolding %}\n\n<div id=\"fieldset1-example\"></div>\n\n***\n\n### label\n&emsp;&emsp;`label`使其中文字内容与`<input>`绑定，点击文字也能选择选项等\n{% folding cyan, fieldset的属性 %}\n* **for=\"[id]\"** label要绑定的input的id\n{% endfolding %}\n\n<div id=\"label1-example\"></div>\n\n***\n\n# HTML5\n&emsp;&emsp;HTML5是新一代开发Web富客户端应用程序整体解决方案。包括：HTML5,CSS3，Javascript API在内的一套**技术组合**。富客户端具有很强的**交互性**和体验。\n\n***\n\n## 新增的语义标签\n&emsp;&emsp;相较于使用`class=\"header\"`给网页做语义化处理，HTML5本身提供了一些语义化的标签。强调了HTML的职责是描述一块内容是什么（或其意义）。\n\n&emsp;&emsp;常见的HTML结构：\n```html\n<!-- 头部 -->\n<div class=\"header\">\n    <ul class=\"nav\"></ul>\n</div>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <div class=\"article\"></div>\n    <!-- 侧边栏 -->\n    <div class=\"aside\"></div>\n</div>\n\n<!-- 底部 -->\n<div class=\"footer\">\n\n</div>\n\n```\n\n&emsp;&emsp;HTML5中这样写\n```html\n<!-- 头部 -->\n<header>\n    <ul class=\"nav\"></ul>\n</header>\n\n<!-- 主体部分 -->\n<div class=\"main\">\n    <!-- 文章 -->\n    <article></article>\n    <!-- 侧边栏 -->\n    <aside></aside>\n</div>\n\n<!-- 底部 -->\n<footer>\n\n</footer>\n\n```\n\n{% folding cyan, HTML5语义标签 %}\n* **section** 区块\n* **article** 表示主体内容，如文章\n* **header** 页眉\n* **footer** 页脚\n* **nav** 导航栏\n* **aside** 侧边栏\n* **figure** 媒介内容分组\n* **mark** 标记\n* **progress** 进度\n* **time** 日期\n{% endfolding %}\n\n***\n\n## H5中的表单\n{% folding cyan, HTML5表单中input新增的类型 %}\n* **email** 只能输入email格式，自带格式验证\n* **tel** 手机号码\n* **url** 只能输入url格式\n* **number** 只能输入数字。\n* **search** 搜索框\n* **range** 滑动条\n* **color** 拾色器\n* **time** 时间\n* **date** 日期\n* **datetime** 时间日期\n* **month** 月份\n* **week** 星期\n{% endfolding %}\n\n<div id=\"h5-input-example\"></div>\n\n***\n\n## 新表单标签\n* `<datalist>` 数据列表,用于数据自动提示\n\n<div id=\"datalist-example\"></div>\n\n* `<keygen>` 用于验证用户，本质是密钥对生成器，当提交表单时，会生成两个键：一个公钥，一个私钥，私钥存储于客户端，公钥则被发送到服务器。公钥可用于之后验证用户的客户端证书。\n\n***\n\n## 新表单属性\n{% folding cyan, 新表单属性 %}\n* **placeholder** 占位符（提示文字）\n* **autofocus** 自动获取焦点\n* **multiple** 文件上传多选或多个邮箱地址\n* **autocomplete** 自动完成（填充的）on开启（默认）off取消。效果是会记住之前的提交，可以快速选择\n* **form** 指定表单项属于哪个form，处理复杂表单时会需要\n* **novalidate** 关闭默认的验证功能（只能加给form）\n* **required** 表示必填项\n* **pattern** 自定义正则，验证表单。\n{% endfolding %}\n\n<div id=\"new-form-example\"></div>\n\n***\n\n## 表单事件\n1. `oninput()` 用户输入内容时触发，可用于输入字数统计。\n2. `oninvalid()` 验证不通过时触发\n\n***\n\n## audio音频标签\n{% folding cyan, audio的属性 %}\n* **autoplay** 自动播放\n* **controls** 控制条\n* **loop** 循环播放\n* **preload** 预加载，设置autoplay此属性失效\n{% endfolding %}\n\n<div id=\"audio-example\"></div>\n\n***\n\n## video视频标签\n{% folding cyan, audio的属性 %}\n* **autoplay** 自动播放\n* **controls** 控制条\n* **loop** 循环播放\n* **preload** 预加载，设置autoplay此属性失效\n* **width**、**height**\n{% endfolding %}\n\n```html\n<video src=\"video/movie.mp4\" controls  autoplay ></video>\n<video controls autoplay>\n  <source src=\"video/movie.mp4\"/>\n  <source src=\"video/movie.ogg\"/>\n  <source src=\"video/movie.webm\"/>\n  抱歉，不支持此视频\n</video>\n\n```\n\n***\n\n<script src=\"https://cdn.chuckle.top/js/mini-sandbox.min.js?2\"></script>\n<script src=\"https://cdn.chuckle.top/js/31.js?3\"></script>","tags":["前端"],"categories":["学习笔记"]},{"title":"老旧浏览器弹窗提醒","url":"/article/e61f6567.html","content":"\n# 前言\n&emsp;&emsp;在今年IE终于从半身入土到彻底寄寄，谷歌也做了个违背祖宗的决定，版本号破百。\n&emsp;&emsp;但像夸克、UC、百分等浏览器，仍然用着老旧的谷歌内核，也有不少人还用着老版本的谷歌浏览器、Edge。像我学校的机房，仍用着老旧的44版Edge。\n\n&emsp;&emsp;老旧的浏览器不仅让兼容性较低的网站样式爆炸（没错，说的就是我站（bushi）），更不是大势所趋。样式爆炸也会给访客留下不好的印象，为了避免这种情况，合理甩锅（嗯对没错）给浏览器非常双赢。可以每天检测一次浏览器版本号然后弹窗。\n<img src=https://cdn.chuckle.top/images/29-1.webp width=\"60%\" height=\"60%\">\n\n***\n\n# 实现\n&emsp;&emsp;把这JS找个地方塞进去，弹窗调用butterfly自带的，用其它的替换即可。\n```JS 老旧浏览器弹窗提醒\nfunction browserTC() {\n    btf.snackbarShow(\"\");\n    Snackbar.show({\n        text: '浏览器版本较低，网站样式可能错乱',\n        actionText: '关闭',\n        duration: '6000',\n        pos: 'bottom-right'\n    });\n}\nfunction browserVersion() {\n    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串\n    var isIE = userAgent.indexOf(\"compatible\") > -1 && userAgent.indexOf(\"MSIE\") > -1; //判断是否IE<11浏览器\n    var isIE11 = userAgent.indexOf('Trident') > -1 && userAgent.indexOf(\"rv:11.0\") > -1;\n    var isEdge = userAgent.indexOf(\"Edge\") > -1 && !isIE; //Edge浏览器\n    var isFirefox = userAgent.indexOf(\"Firefox\") > -1; //Firefox浏览器\n    var isOpera = userAgent.indexOf(\"Opera\")>-1 || userAgent.indexOf(\"OPR\")>-1 ; //Opera浏览器\n    var isChrome = userAgent.indexOf(\"Chrome\")>-1 && userAgent.indexOf(\"Safari\")>-1 && userAgent.indexOf(\"Edge\")==-1 && userAgent.indexOf(\"OPR\")==-1; //Chrome浏览器\n    var isSafari = userAgent.indexOf(\"Safari\")>-1 && userAgent.indexOf(\"Chrome\")==-1 && userAgent.indexOf(\"Edge\")==-1 && userAgent.indexOf(\"OPR\")==-1; //Safari浏览器\n    if(isEdge) {\n        if(userAgent.split('Edge/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isFirefox) {\n        if(userAgent.split('Firefox/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isOpera) {\n        if(userAgent.split('OPR/')[1].split('.')[0]<80){\n            browserTC()\n        }\n    } else if(isChrome) {\n        if(userAgent.split('Chrome/')[1].split('.')[0]<90){\n            browserTC()\n        }\n    } else if(isSafari) {\n        //不知道Safari哪个版本是该淘汰的老旧版本\n    }\n}\n//2022-10-29修正了一个错误：过期时间应使用toGMTString()，而不是toUTCString()，否则实际过期时间在中国差了8小时\nfunction setCookies(obj, limitTime) {\n\tlet data = new Date(new Date().getTime() + limitTime * 24 * 60 * 60 * 1000).toGMTString()\n\tfor (let i in obj) {\n\t\tdocument.cookie = i + '=' + obj[i] + ';expires=' + data\n\t}\n}\nfunction getCookie(name) {\n\tvar arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\tif (arr = document.cookie.match(reg))\n\t\treturn unescape(arr[2]);\n\telse\n\t\treturn null;\n}\nif(getCookie('browsertc')!=1){\n    setCookies({\n        browsertc: 1,\n    }, 1);\n    browserVersion();\n}\n\n```\n\n***\n\n# 后记\n&emsp;&emsp;样式爆炸首先甩锅（\n\n","tags":["Butterfly","教程"],"categories":["教程"]},{"title":"写个网页版电子木鱼","url":"/article/904a2780.html","content":"\n# 前言\n&emsp;&emsp;Heo写了个ios版电子木鱼，最近电子木鱼确实挺火。\n&emsp;&emsp;必须也给博客安排上，一个养生的互联网小站不能没有电子木鱼！\n{% link 电子木鱼,/muyu/,%}\n&emsp;&emsp;1.0写得比较粗糙，简单的积功德，敲敲敲，还有功德+100。等以后再完善什么见初音未来、随机弹涩图减功德的功能吧，咕咕咕咕。\n\n***\n\n# 实现\n```html\n<div class=\"muyu-layout\">\n    <div id=\"jishu-box\">\n        <p id=\"jishu\">功德：0</p>\n    </div>\n    <div id=\"muyu-box\">\n        <p id=\"gongde\">功德+100</p>\n        <img id=\"muyu\" class=\"no-lightbox entered loaded\"\n            src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQIAAADCCAMAAACVDjxiAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAABaUExURUxpcfn5+fHw8fHx8fv6++3q7vv6+/n4+vr6+vf29/Ly8vn4+eDd4fj4+MjEyff39+bk55CLkNXU1s7NzkZARv7//v///woCC/38/R4YHlFMUjQuNayorXNudNqgV+MAAAAVdFJOUwAYV0TZ/bb4CoNtm/gl/THQ/MCY48f2/+sAAA/JSURBVHja7F2JYuK6Dp0sjrNBgF6rKsv//+azLTkJECCBLAaeaem0nbboWNYu+d+//y+fVrCqqiriFYah/VhVq+ALaF9FYZ5lRRLrJUUp9JtERGmW/lJSZHkerT6U+DSIsqKIpaHYLAD9ZpbSD7Cfo/4HaDji5CePgvTD6F+FRWKIt9S2lkJpnlAp+4l5GGyk0ByRhVXwQfRvhKUUmVjDBfZNPykNiyVeswN9Sf8XZb6t2SGLVm/PDUGUF5tS2s03lPIbPymi2HwkVuDvOLgAyt1PGL0zM1R5EhPtZrebhTUGVwubb1gmkUJoKZm/JzOkVbaRlrUtZ19SStReP2peILnA4kPDEL4bDGmUbQQ4Rgfo2O5bbHD2CVhusDIy1ii8EQJRoQWAIqlnVV+/hWcIWHFgYACSDSC1fHwTVqiKmCUaOkl3vuDWQvvOkgOtrlD08/Z3AcgifAPpuMpie4jRKrlOjrdk3nhgjQGgYpXJOsPylExyz0FI85h2/y7Dd9DunszHmz9ovyl2XoMQFRKY8VENWfwz8FhaGE258RYEfQaIY4cC0HcBmU3alUhCLwVjmNBZ7pDuIy3LJWi1hCwq/4zhLK7dn9oQHh0DdJIRMM49Y4RqJ2qxraZa7GczDDLzSiJEiZaDaogd9BQEbGmzxymLwCNVuJGKvT1UsyyKPCS+2MzpT+ncXVBzLaN8JXiCwaogBOBMCsLU7EAhKC/OQqSdYquvsK29phUJzAXgBQZGDHBEjK23xpSdFAWywzUIxcK6McgEkjtjtVXjA8CUPICNtahXli6sC812NzvuNMKkmuHM8NK6cUkMwh35A/PpgU7lKBbDIM1LUcd2loNAvwSxkK2cZqIOcC7HBvT3y3wRQVhQKsia67DoQcBlMGAEFCWEljsILk8Xh/MjgLgc3R2sAHE0NwKcIvICBrQycRPNzgPwRIhwykACJtXMPIDoDQAcQFBJMK8c8EUUoKpT9rO5TKnWBeyswYLa8CwHCZRsmstlygh38IgJXHRiJnchlx5pwyvVIPM5EFB+IXCejIbpTaQwRn+ZgDCY2DyIYvQZghmiyqtEIfoiCG/mWqY0D8go9PkcAEVUJ1MLaWbzWR4zAddkYDaZMhAKAXzHwJgIU4lEIwp9J59TGHK3mkYUIs6UJ3pdKIopjoL2DLgq0ntGMDZzXE0gCgW4OkqflaILJ8psCqtQof/bz9ujMdiNrRir2KsIyW2NCA6MZGQIgsSGiuENlAHHEnFkCNJMUlTCf41Y28kjQxCWnDTx/RxQKBnHh6AyNRSA4L885ECifowbOgl2wqWz/RUGWPMp/SMe1TzMhJL+60PO8FM0WY7LBGGp3kIQItWcUMxg1Gj6aoP4FpKQKlMtCuOWZJqkgf9egYsU2Ey3TMYtuMiFR4mjRxgYBOJk5NadaONnqAzPFSHVGEgRj9/SaPXhUp4h3I5QWalHrVzcBYey3GUTdPHZaqKlEDiTQNi07gD1LjoDwHbvlZtioi7vUKIEUEu5iHab601XdSrX9WVQvFjGyXTN/qsYpFq0mAwbm7f2Aqglw3K/LE1f94SdvGlBGWsf7P46XmOZwPZ+iPK4/Zm4hzeUsLxR1KafrR+Dglif9of/pm7fXdkK80V4wE07aEnCmnrA8nja7w+/v78/F1xLK7DPY4VJcCEMwI28oDgNz3PQe18ej9v94e/XrkP0jylNg1UV5llRJEmy2SRmFXn1MgxRCTR9YbkYYD3Wg1hfb76j3kFgTJcqyopNHMv2hBBbi/lqc3PArSZLWIbs7jD/a87X1J/2bert+ttGUZglsTyfEdOs11pabQa1bqNf5hzw2V+fDn9X5BsEDqdjKbA9JAecGOF2/5dKj8IYUC0WNndyX+r93+4vKP87HPZ6bdel5A4tWwiL0MzLaUbCPN+xYo4Bm6AwMbGtETfY7L4lXgv+v4uN35+2x7V2XiU7EFj7CHUAvTEhzO+W4dPa4HXKsUlr4JWudyYu1rEurKMeINfbc8FnN/9vbxjfuU49DBZC5snkYlTyKJqXQxhdzm3b6mlzL73ktd78Qwf167Ugj/DxhIj233yy3GK1kyNYhegcLLwBALfZES+A5f5LvWdO/n7rNh/qk94zqWCPymb1jG8g1BiW8R0uQGcDIrd6S2HO/gX5dPJlTX093WaAcaF9iSekgSkvHdE7uGKDesYb27vXgu/PyHwj95h6RZICuCOyt26lvza8+CqKB/HboEhXS93rnZdCW7xXWp/0vRA157O6sLoJsH9SCxTpjMEnIUhGswdsdoM2UvEYO2J6vfFHa+9eC/79icReTf7LGdbhJyEXrp4GX9f5Z1KMLf0tibwOi88I/mbzsVfs9LFKgKGNnNWGhg+OEDbGC0vXkL/vtHUZAEs/4k0NijfVyx2gtBrdDHOXMuHqdWAEu8DRjx36rguAcVtfWe/AMOtotXHSZwQXkekX6+198rXfe1ozAIzBGHaJs5ZhWBtnLtg9oiFcryW7a+b/vb8O2zWy7sNWuBivzF2AQcWvLt5U/qSDmIAiBAhDHWXAGnmWgzbC9Yh8fQROaxKAYBnAzXVTV7Mgn+MEE2YfIgxy0UwnvXcmgUMp2AxbUqo298nTuzT2bgBw2IoOfwSb8aD44mkYJgy0c6DwcX0t1gBgi2VtiMLSr7l/34d8awaVCq4ilNg6za+CAMMalmypeZ+IaR1Pw2ZUKdTCb9+LfDoDHOPBzizKSNkYhGyIOujniWKLXesYnzn8V57u7109KFkLTDz6BYtB7Xc4pNAcW4Eu0Zf7HQccBdS1C1NBwN5F3wq8VcwRyJ6qwM6toe51Y/nuB9CvDYEjDYjmRtNJE9T968+ygfYIOz6GBdangQCwITBHKYaxb3pGEFfxkBeFbv6kBeAwgP6//bYEmKucl+erh32ZYNgRA5piIrZDANCmYAlzpmtpPmIvrcjl9n0VjZtbq4XgsCNQtuMgsySmzR/sBUE2JGTK08WGA7CuLwCYiw0oCJj1ZIIBnjidgfL0N0gIrCW4RA/XNE9dwMHZ6V4QZAPjVM8IAdESgrMl6qCveUiSoKdFQPHfQYaAVgPrBoA5E5U0YLvokToAVL3LKWwH2HYQABwSmnM4asMF0Mc8tI2o/cPTWtEe/54AYInSLXsQHveomDQqDJhgPAQBAkBinfvFmQ+CNcMeQhCVOGRMDww4BXtnCTV3Bcx8EHpBkNpISR+flXxbtT4MMwWVcybU/OKQxPcjcRit3czWfuZWTyYwWgCdFlis6Z/s+KJX+1UfCCjA2YsJmsxIX3Qnsw7hoWkUrmEIFwA+ZgLDAALaQcHFILBJgQcQBDuJvV+nncL9EIK/U9mUBHRlmeY+Cw/62E32BHpCQJeePTgI2hmSgG1/sCUGZpcJdNFO9jhw3hMCMp/uQ7Bfk4veigwvCQFFDO5BkP6IARWmFgEs93fdQfCqwZtKErO7ClEOMFwtBCBv+shaDArwavAPp/juhUx+hKKW7L6ROPN+yzx2pqA3EHAM/W46KTza6z2wt4axDmW3MGiigh61dlKU806tzWpb0ijj3gEj632LfWdUsC6G9ekYWFlQhrdl4bG54LO3bNE/cDx0hEXBFZB6Ng9Rv6oyuuMcNHfVDTI1tudlgid2Bp74ZdOzgT6+NyEIfp7ryzdH4VTXTZkyQb40mLwSz5q8jfi6VXqYmgsunnrBJnxO1eLEADQgX7Ur4b3hAvvCboULjI/8VMMBRdBNKtWWCLvrcOG8rdKTZm8r64pblvGz1daufpzrKsFekszjA5qiT58so+KGIBBPd500VfRXd4c2tVG+tPwbLdZtH+clBRPwBXhdH1n7ihj0aR4ee2vdxmEUTzPPeNKakWdh6MytVzFdbYSfC4CL2UN3kUmww4kuOPCJAcAVA3ZMBab5jQCTAODNlQnuhtOuwX9pXjbJnSlkgS9coLgVJOuYVwXg90jnMSWTVghhVzMufD4AjUK4KkGOYu7g+46l+f2yEL3aSPwWDiBT7bI3KUjwSxBw1dGXUTMzpQa/SAzY6Y/RVaX1VyGgLg2jqHRu3efjAG4MaH4pCNT3CEMKnZ6fg4yaoL5EHJLxd961vYp56M3X8IA2kc9jBVYWAuCXWEVmDp5UZ/fnpAm6GXnfwQP2PbsoslWv9D2+pTQ49w/yb9IFigPd5yMsMlDfhIHNgsvost4evooJNAYXc0yyLzsI6jpSkMG3CYNLJiAu+Crr+Dpc9C2xElfxfh02DeKvCZbQFJWODErxNbLAekJdabSvOQnkB3QN9gqS73ASqRO0e3pHKPE7joGZ4RLemF8Gb3H/0UuSkOdn3prqFcpP95W5CwpvXjGbFuqjg+joxircGeNj5zTgh0uCB1duh/GHM4G1icJHY2s+11MwolAq8WhgQy4/mQ1M08zjkRVhDK35q2eD1GmofBeXQHt5dfTr18SjpOM+F0dVhWyma3L9PJzNV7+6PxKh/fBp392Lctow7je8Jo2KmH9GynhjVyxEM/m2Q3O2MfDNFnTtMv0RMCBUGV0mkYXVahXoVYU/uySOpUSer981vdlPh4CHSsB1Iv0RCsHlnSJpGqzC/Ge3WYvzyeNvoEOsGJPJSBdMp1WY7+iSjHpyvcfsAPRkVEE26h2CVZglstV4jM2AR09AoLnYfDeEeZWb8N//2jsDHQdBGICCgCDoaTQQ/v9Lj0qLbjuTu+SceLkuWZbFZCkrbam277eFi66VmVGXexlpMHktEQGNdHVcWnbnUKQ40GgUdrHFyp4yj5QKaK97J9hpkrcETliniSSVbAS8UR60O5ujxQZh3dQroOqFegoOuaUkaHn+AmRjGFLeMH+oilizGaU4Le9ZgLInlhQmaHL1Y1h6Swq0/7E1uZXdyN4tvLFO0uBamiPn/VfcyXAoPz9/YRyK+CEPZNOtHdglYgaIlimTJlzREVYkHr6Orjo8DOLkhA0nGkJyAZxdKMk1dPOE/C5PDWmnOIn1+B6eEEO67UbDLhdwDXOvS7fiaXMLyNwQ6wb6iwr0L7kTuAZE+MWTOr1CJNwGhECAybK6xEDWICU+0Piwp7833P/4Kuqsyd4f1E9ne8OqFMNH69pcbNgQZ/TENwE7VqTA+h5o3MXWL4uNz57AeESVy0lw0j5Z/8BZ1WLMWmxI6ZOCPJLgoJhLouZblY6KXbEMQIqBgAs7qliMapoX24zcsJtI8pHNsswfvVJxK0b6QpVAxXyhKCEcJU+VKRzZXNTrp9bZRtxH+52THEVjZyi7RNKrwNFp5MmuWhvoosxYAOWlnED5kbM7Cx9GAQ5CKqXjzvI3XjjZQcCAopWSEuqZVozDHf/6pw3xUI5MK5HLkdm3Rb+3BK3B2TnXdbDlubm97oeRs7HWdi+SvmxeDf6PrsK/XC6fOxtGHo6ERP4AAAAASUVORK5CYII=\">\n    </div>\n</div>\n\n```\n\n```css\n.muyu-layout {\n        background: black;\n        display: flex;\n        width: 100%;\n        border-radius: 20px;\n        position: relative;\n        justify-content: center;\n        height: 90vh;\n        align-items: center;\n    }\n    #muyu-box img {\n        width: 250px;\n    }\n     #jishu-box{\n        top: 55px;\n        position: absolute;\n     }\n    #muyu-box p {\n        color: white;\n        opacity: 0;\n        font-size: 25px;\n    }\n    #jishu-box p {\n        color: white;\n        font-size: 30px;\n    }\n\n```\n\n```js\nvar gongde = document.getElementById(\"gongde\");\nvar muyu = document.getElementById(\"muyu\");\nvar jishu = document.getElementById(\"jishu-box\");\nvar mp3Url = \"/music/muyu.mp3\";\nvar player = new Audio(mp3Url);\nvar num = 0;\nmuyu.addEventListener(\"click\", function () {\n    num+=100;\n    player.load();\n    player.play();\n    muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500);\n    gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600);\n    jishu.innerHTML = \"<p id='jishu'>功德：\"+num+\"</p>\";\n});\n\n\n```\n\n&emsp;&emsp;当然想和我一样博客单页放电子木鱼，也只需新建个单页，直接cv下面的内容进去即可\n```html\n{% raw %}\n<div class=\"muyu-layout\">\n        <div id=\"jishu-box\">\n             <p id=\"jishu\">功德：0</p>\n        </div>\n        <div id=\"muyu-box\">\n            <p id=\"gongde\">功德+100</p>\n            <img id=\"muyu\" class=\"no-lightbox entered loaded\"\n                src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQIAAADCCAMAAACVDjxiAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAABaUExURUxpcfn5+fHw8fHx8fv6++3q7vv6+/n4+vr6+vf29/Ly8vn4+eDd4fj4+MjEyff39+bk55CLkNXU1s7NzkZARv7//v///woCC/38/R4YHlFMUjQuNayorXNudNqgV+MAAAAVdFJOUwAYV0TZ/bb4CoNtm/gl/THQ/MCY48f2/+sAAA/JSURBVHja7F2JYuK6Dp0sjrNBgF6rKsv//+azLTkJECCBLAaeaem0nbboWNYu+d+//y+fVrCqqiriFYah/VhVq+ALaF9FYZ5lRRLrJUUp9JtERGmW/lJSZHkerT6U+DSIsqKIpaHYLAD9ZpbSD7Cfo/4HaDji5CePgvTD6F+FRWKIt9S2lkJpnlAp+4l5GGyk0ByRhVXwQfRvhKUUmVjDBfZNPykNiyVeswN9Sf8XZb6t2SGLVm/PDUGUF5tS2s03lPIbPymi2HwkVuDvOLgAyt1PGL0zM1R5EhPtZrebhTUGVwubb1gmkUJoKZm/JzOkVbaRlrUtZ19SStReP2peILnA4kPDEL4bDGmUbQQ4Rgfo2O5bbHD2CVhusDIy1ii8EQJRoQWAIqlnVV+/hWcIWHFgYACSDSC1fHwTVqiKmCUaOkl3vuDWQvvOkgOtrlD08/Z3AcgifAPpuMpie4jRKrlOjrdk3nhgjQGgYpXJOsPylExyz0FI85h2/y7Dd9DunszHmz9ovyl2XoMQFRKY8VENWfwz8FhaGE258RYEfQaIY4cC0HcBmU3alUhCLwVjmNBZ7pDuIy3LJWi1hCwq/4zhLK7dn9oQHh0DdJIRMM49Y4RqJ2qxraZa7GczDDLzSiJEiZaDaogd9BQEbGmzxymLwCNVuJGKvT1UsyyKPCS+2MzpT+ncXVBzLaN8JXiCwaogBOBMCsLU7EAhKC/OQqSdYquvsK29phUJzAXgBQZGDHBEjK23xpSdFAWywzUIxcK6McgEkjtjtVXjA8CUPICNtahXli6sC812NzvuNMKkmuHM8NK6cUkMwh35A/PpgU7lKBbDIM1LUcd2loNAvwSxkK2cZqIOcC7HBvT3y3wRQVhQKsia67DoQcBlMGAEFCWEljsILk8Xh/MjgLgc3R2sAHE0NwKcIvICBrQycRPNzgPwRIhwykACJtXMPIDoDQAcQFBJMK8c8EUUoKpT9rO5TKnWBeyswYLa8CwHCZRsmstlygh38IgJXHRiJnchlx5pwyvVIPM5EFB+IXCejIbpTaQwRn+ZgDCY2DyIYvQZghmiyqtEIfoiCG/mWqY0D8go9PkcAEVUJ1MLaWbzWR4zAddkYDaZMhAKAXzHwJgIU4lEIwp9J59TGHK3mkYUIs6UJ3pdKIopjoL2DLgq0ntGMDZzXE0gCgW4OkqflaILJ8psCqtQof/bz9ujMdiNrRir2KsIyW2NCA6MZGQIgsSGiuENlAHHEnFkCNJMUlTCf41Y28kjQxCWnDTx/RxQKBnHh6AyNRSA4L885ECifowbOgl2wqWz/RUGWPMp/SMe1TzMhJL+60PO8FM0WY7LBGGp3kIQItWcUMxg1Gj6aoP4FpKQKlMtCuOWZJqkgf9egYsU2Ey3TMYtuMiFR4mjRxgYBOJk5NadaONnqAzPFSHVGEgRj9/SaPXhUp4h3I5QWalHrVzcBYey3GUTdPHZaqKlEDiTQNi07gD1LjoDwHbvlZtioi7vUKIEUEu5iHab601XdSrX9WVQvFjGyXTN/qsYpFq0mAwbm7f2Aqglw3K/LE1f94SdvGlBGWsf7P46XmOZwPZ+iPK4/Zm4hzeUsLxR1KafrR+Dglif9of/pm7fXdkK80V4wE07aEnCmnrA8nja7w+/v78/F1xLK7DPY4VJcCEMwI28oDgNz3PQe18ej9v94e/XrkP0jylNg1UV5llRJEmy2SRmFXn1MgxRCTR9YbkYYD3Wg1hfb76j3kFgTJcqyopNHMv2hBBbi/lqc3PArSZLWIbs7jD/a87X1J/2bert+ttGUZglsTyfEdOs11pabQa1bqNf5hzw2V+fDn9X5BsEDqdjKbA9JAecGOF2/5dKj8IYUC0WNndyX+r93+4vKP87HPZ6bdel5A4tWwiL0MzLaUbCPN+xYo4Bm6AwMbGtETfY7L4lXgv+v4uN35+2x7V2XiU7EFj7CHUAvTEhzO+W4dPa4HXKsUlr4JWudyYu1rEurKMeINfbc8FnN/9vbxjfuU49DBZC5snkYlTyKJqXQxhdzm3b6mlzL73ktd78Qwf167Ugj/DxhIj233yy3GK1kyNYhegcLLwBALfZES+A5f5LvWdO/n7rNh/qk94zqWCPymb1jG8g1BiW8R0uQGcDIrd6S2HO/gX5dPJlTX093WaAcaF9iSekgSkvHdE7uGKDesYb27vXgu/PyHwj95h6RZICuCOyt26lvza8+CqKB/HboEhXS93rnZdCW7xXWp/0vRA157O6sLoJsH9SCxTpjMEnIUhGswdsdoM2UvEYO2J6vfFHa+9eC/79icReTf7LGdbhJyEXrp4GX9f5Z1KMLf0tibwOi88I/mbzsVfs9LFKgKGNnNWGhg+OEDbGC0vXkL/vtHUZAEs/4k0NijfVyx2gtBrdDHOXMuHqdWAEu8DRjx36rguAcVtfWe/AMOtotXHSZwQXkekX6+198rXfe1ozAIzBGHaJs5ZhWBtnLtg9oiFcryW7a+b/vb8O2zWy7sNWuBivzF2AQcWvLt5U/qSDmIAiBAhDHWXAGnmWgzbC9Yh8fQROaxKAYBnAzXVTV7Mgn+MEE2YfIgxy0UwnvXcmgUMp2AxbUqo298nTuzT2bgBw2IoOfwSb8aD44mkYJgy0c6DwcX0t1gBgi2VtiMLSr7l/34d8awaVCq4ilNg6za+CAMMalmypeZ+IaR1Pw2ZUKdTCb9+LfDoDHOPBzizKSNkYhGyIOujniWKLXesYnzn8V57u7109KFkLTDz6BYtB7Xc4pNAcW4Eu0Zf7HQccBdS1C1NBwN5F3wq8VcwRyJ6qwM6toe51Y/nuB9CvDYEjDYjmRtNJE9T968+ygfYIOz6GBdangQCwITBHKYaxb3pGEFfxkBeFbv6kBeAwgP6//bYEmKucl+erh32ZYNgRA5piIrZDANCmYAlzpmtpPmIvrcjl9n0VjZtbq4XgsCNQtuMgsySmzR/sBUE2JGTK08WGA7CuLwCYiw0oCJj1ZIIBnjidgfL0N0gIrCW4RA/XNE9dwMHZ6V4QZAPjVM8IAdESgrMl6qCveUiSoKdFQPHfQYaAVgPrBoA5E5U0YLvokToAVL3LKWwH2HYQABwSmnM4asMF0Mc8tI2o/cPTWtEe/54AYInSLXsQHveomDQqDJhgPAQBAkBinfvFmQ+CNcMeQhCVOGRMDww4BXtnCTV3Bcx8EHpBkNpISR+flXxbtT4MMwWVcybU/OKQxPcjcRit3czWfuZWTyYwWgCdFlis6Z/s+KJX+1UfCCjA2YsJmsxIX3Qnsw7hoWkUrmEIFwA+ZgLDAALaQcHFILBJgQcQBDuJvV+nncL9EIK/U9mUBHRlmeY+Cw/62E32BHpCQJeePTgI2hmSgG1/sCUGZpcJdNFO9jhw3hMCMp/uQ7Bfk4veigwvCQFFDO5BkP6IARWmFgEs93fdQfCqwZtKErO7ClEOMFwtBCBv+shaDArwavAPp/juhUx+hKKW7L6ROPN+yzx2pqA3EHAM/W46KTza6z2wt4axDmW3MGiigh61dlKU806tzWpb0ijj3gEj632LfWdUsC6G9ekYWFlQhrdl4bG54LO3bNE/cDx0hEXBFZB6Ng9Rv6oyuuMcNHfVDTI1tudlgid2Bp74ZdOzgT6+NyEIfp7ryzdH4VTXTZkyQb40mLwSz5q8jfi6VXqYmgsunnrBJnxO1eLEADQgX7Ur4b3hAvvCboULjI/8VMMBRdBNKtWWCLvrcOG8rdKTZm8r64pblvGz1daufpzrKsFekszjA5qiT58so+KGIBBPd500VfRXd4c2tVG+tPwbLdZtH+clBRPwBXhdH1n7ihj0aR4ee2vdxmEUTzPPeNKakWdh6MytVzFdbYSfC4CL2UN3kUmww4kuOPCJAcAVA3ZMBab5jQCTAODNlQnuhtOuwX9pXjbJnSlkgS9coLgVJOuYVwXg90jnMSWTVghhVzMufD4AjUK4KkGOYu7g+46l+f2yEL3aSPwWDiBT7bI3KUjwSxBw1dGXUTMzpQa/SAzY6Y/RVaX1VyGgLg2jqHRu3efjAG4MaH4pCNT3CEMKnZ6fg4yaoL5EHJLxd961vYp56M3X8IA2kc9jBVYWAuCXWEVmDp5UZ/fnpAm6GXnfwQP2PbsoslWv9D2+pTQ49w/yb9IFigPd5yMsMlDfhIHNgsvost4evooJNAYXc0yyLzsI6jpSkMG3CYNLJiAu+Crr+Dpc9C2xElfxfh02DeKvCZbQFJWODErxNbLAekJdabSvOQnkB3QN9gqS73ASqRO0e3pHKPE7joGZ4RLemF8Gb3H/0UuSkOdn3prqFcpP95W5CwpvXjGbFuqjg+joxircGeNj5zTgh0uCB1duh/GHM4G1icJHY2s+11MwolAq8WhgQy4/mQ1M08zjkRVhDK35q2eD1GmofBeXQHt5dfTr18SjpOM+F0dVhWyma3L9PJzNV7+6PxKh/fBp392Lctow7je8Jo2KmH9GynhjVyxEM/m2Q3O2MfDNFnTtMv0RMCBUGV0mkYXVahXoVYU/uySOpUSer981vdlPh4CHSsB1Iv0RCsHlnSJpGqzC/Ge3WYvzyeNvoEOsGJPJSBdMp1WY7+iSjHpyvcfsAPRkVEE26h2CVZglstV4jM2AR09AoLnYfDeEeZWb8N//2jsDHQdBGICCgCDoaTQQ/v9Lj0qLbjuTu+SceLkuWZbFZCkrbam277eFi66VmVGXexlpMHktEQGNdHVcWnbnUKQ40GgUdrHFyp4yj5QKaK97J9hpkrcETliniSSVbAS8UR60O5ujxQZh3dQroOqFegoOuaUkaHn+AmRjGFLeMH+oilizGaU4Le9ZgLInlhQmaHL1Y1h6Swq0/7E1uZXdyN4tvLFO0uBamiPn/VfcyXAoPz9/YRyK+CEPZNOtHdglYgaIlimTJlzREVYkHr6Orjo8DOLkhA0nGkJyAZxdKMk1dPOE/C5PDWmnOIn1+B6eEEO67UbDLhdwDXOvS7fiaXMLyNwQ6wb6iwr0L7kTuAZE+MWTOr1CJNwGhECAybK6xEDWICU+0Piwp7833P/4Kuqsyd4f1E9ne8OqFMNH69pcbNgQZ/TENwE7VqTA+h5o3MXWL4uNz57AeESVy0lw0j5Z/8BZ1WLMWmxI6ZOCPJLgoJhLouZblY6KXbEMQIqBgAs7qliMapoX24zcsJtI8pHNsswfvVJxK0b6QpVAxXyhKCEcJU+VKRzZXNTrp9bZRtxH+52THEVjZyi7RNKrwNFp5MmuWhvoosxYAOWlnED5kbM7Cx9GAQ5CKqXjzvI3XjjZQcCAopWSEuqZVozDHf/6pw3xUI5MK5HLkdm3Rb+3BK3B2TnXdbDlubm97oeRs7HWdi+SvmxeDf6PrsK/XC6fOxtGHo6ERP4AAAAASUVORK5CYII=\">\n        </div>\n    </div>\n<style>\n    .muyu-layout {\n        background: black;\n        display: flex;\n        width: 100%;\n        border-radius: 20px;\n        position: relative;\n        justify-content: center;\n        height: 90vh;\n        align-items: center;\n    }\n    #muyu-box img {\n        width: 250px;\n    }\n     #jishu-box{\n        top: 55px;\n        position: absolute;\n     }\n    #muyu-box p {\n        color: white;\n        opacity: 0;\n        font-size: 25px;\n    }\n    #jishu-box p {\n        color: white;\n        font-size: 30px;\n    }\n</style>\n    <script>\n        var gongde = document.getElementById(\"gongde\");\n        var muyu = document.getElementById(\"muyu\");\n        var jishu = document.getElementById(\"jishu-box\");\n        var mp3Url = \"/music/muyu.mp3\";\n        var player = new Audio(mp3Url);\n        var num = 0;\n        muyu.addEventListener(\"click\", function () {\n            num+=100;\n            player.load();\n            player.play();\n            muyu.animate([{ transform: 'scale(0.85)' }, { transform: 'scale(1.03)' }, { transform: 'scale(1)' }], 500);\n            gongde.animate([{ opacity: 0, transform: 'translateY(0)' },{ opacity: 0.3, transform: 'translateY(-10px)' },{ opacity: 0.8, transform: 'translateY(-20px)' }, { opacity: 1, transform: 'translateY(-30px)' }, { opacity: 0.8, transform: 'translateY(-35px)' }, { opacity: 0, transform: 'translateY(-40px)' }], 600);\n            jishu.innerHTML = \"<p id='jishu'>功德：\"+num+\"</p>\";\n        });\n    </script>\n\n{% endraw %}\n\n```\n\n***\n\n# 后记\n&emsp;&emsp;用Animations控制CSS动画比用js模拟动画好用多了。\n\n\n\n\n\n\n\n","tags":["教程","瞎折腾"],"categories":["项目"]},{"title":"CodeFA×Hexo体验","url":"/article/cf571182.html","content":"\n# 前言\n&emsp;&emsp;Hexo是一个无后端的静态博客框架，但不妨碍各路大佬基于Github Action自动化部署实现假后端，为的就是随时随地可以通过假后端来写or修改文章，当然也可以改源码和配置。\n\n&emsp;&emsp;流行的假后端有Qexo、Wexa等，博主尝试过Wexa，但还是习惯于Vscode上的体验，假后端就凉一旁吃灰了，也关掉了Github Action自动化部署，本地Bat双击实现推送也很快。\n```bat\n@echo off\ncd C:\\chuckle\\blog\nhexo clean&&hexo g&&gulp&&hexo d\n```\n\n&emsp;&emsp;不过，随时修改文章，或者在外闲着无事给博客写个单页的需求也还是客观存在的，于是我又尝试了github.dev，这个github提供的在线vscode，启动很方便，仓库地址在把com改成dev后跳转即可，但它不能装插件、没有终端，浏览器打开需要等上一会，并且这是一个在线服务离不开网络。\n\n&emsp;&emsp;我将目光转向了早些年捣鼓过的Termux，可以配合CodeServer实现一个本地Vscode，但还是得配合VNC或者浏览器，依旧麻烦笨重。\n\n&emsp;&emsp;最终，我找到了它[CodeFA](https://www.coolapk.com/apk/com.nightmare.code)，[github地址：vscode_for_android](https://github.com/nightmare-space/vscode_for_android)，使用LinuxArm64启动一个code-server，ubuntu版本22.04，然后使用WebView进行加载，WebView加载的内容完全来自本地，并非套壳在线的网站。安装在平板上再合适不过（生产力MAX？）\n\n# 上手体验\n&emsp;&emsp;因为其本质就是一个ubuntu，且贴心地集成好了不少东西，上手非常轻松。第一件事当然是安装好环境跑几个代码玩玩（啊，不对，是先美化），`apt install gcc`、`apt install g++`、`apt install openjdk-17-jdk`等，没空去配置调试环境，也用不上，装上Coderunner插件，C、JAVA都可以运行了。和win端一样，支持智能提示和补全，java也支持psvm、sout等快捷方式。\n<img src=https://cdn.chuckle.top/images/27-1.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;当然，我们的重点不是跑代码，而是部署Hexo。\n\n## 部署Hexo\n>并不是完整教程，只是记录，实际上和ubuntu下部署hexo没啥大区别。\n\n&emsp;&emsp;首先，安装NodeJs、git、npm、vim，`pkg install nodejs`，`pkg install git`，`pkg install vim`，`apt install npm`。\n&emsp;&emsp;然后安装Hexo和gulp，`npm install hexo-cli -g`，`npm install --global gulp-cli`，`npm install gulp --save`。\n&emsp;&emsp;配置一下git，然后`git clone`博客源码，cd进去运行`npm install`，让它慢慢安装完依赖和我用到的插件。\n\n&emsp;&emsp;现在hexo三连，nodejs会报错：**System limit for number of file watchers reached**，问题不大，在`/etc/sysctl.conf/`中加上`fs.inotify.max_user_watches=524288`，然后运行`sysctl -p`。\n\n&emsp;&emsp;再次三连，不出意外的话，浏览器访问`http://localhost:4000/`就可以看到自己的hexo网站啦~。四连也可以推送网站到github和服务器端（当然前提是配置好了git，这就不赘述了，openssh自带无需安装）。\n<img src=https://cdn.chuckle.top/images/27-4.webp width=\"60%\" height=\"60%\">\n\n## 多端协作\n&emsp;&emsp;得益于vscode便利的git管理，一个文件或者文章，电脑端写完，推送push上github，平板端pull下来，就能继续写。得益于hexo的高性能，即使在虚拟环境下跑，hexo g也能在几秒内完成。\n<img src=https://cdn.chuckle.top/images/27-2.webp width=\"60%\" height=\"60%\"><img src=https://cdn.chuckle.top/images/27-3.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;配合小米平板的pc模式，还不错。\n<img src=https://cdn.chuckle.top/images/27-5.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;完全体。\n<img src=https://cdn.chuckle.top/images/27-6.webp width=\"60%\" height=\"60%\">\n\n# 后记\n\n暂无\n","tags":["Hexo","VScode"],"categories":["Hexo"]},{"title":"CSS/JS备忘录","url":"/article/2ec41fd7.html","content":"\n# CSS备忘录\n\n## 元素水平和垂直居中\n```css 水平居中\n.example{/* 父元素的宽度是确定的 */\n    margin: 0 auto;\n}\n.example{/* 文本水平居中 */\n    text-align: center;\n}\n\n```\n\n```css 垂直居中(元素父级添加flex)\n.example{\n    display: flex;\n    -webkit-box-align: center;\n    align-items: center;\n}\n\n```\n\n## 文本自动换行\n```css \n.example{\n    white-space: normal;\n    word-break: break-all;\n    word-wrap: break-word;\n    text-overflow: ellipsis;\n}\n\n```\n\n## 隐藏浏览器滚动条\n```css \n.example::-webkit-scrollbar{\n    display:none\n    /* or */\n    width:0;\n}\n\n```\n\n## 水平镜像旋转元素\n```css \n.example{\n    -moz-transform:scaleX(-1);\n    -webkit-transform:scaleX(-1);\n    -o-transform:scaleX(-1);\n    transform:scaleX(-1);\n}\n\n```\n\n## 媒体自适应css\n```css \n@media screen and (min-width: 1000px) and (max-width: 1300px){\n    .example{\n    }\n}\n\n```\n\n***\n\n# JS备忘录\n\n## Cookie操作\n```js 设置Cookie\nfunction setCookies(obj, limitTime) {\n\tlet data = new Date(new Date().getTime() + limitTime * 24 * 60 * 60 * 1000).toGMTString()\n\tfor (let i in obj) {\n\t\tdocument.cookie = i + '=' + obj[i] + ';expires=' + data\n\t}\n}\nsetCookies({\n    browsertc: 1,\n}, 1);\n\n```\n\n```js 读取Cookie\nfunction getCookie(name) {\n\tvar arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\n\tif (arr = document.cookie.match(reg))\n\t\treturn unescape(arr[2]);\n\telse\n\t\treturn null;\n}\ngetCookie('browsertc');\n\n```\n\n\n***","tags":["前端","JS","CSS"],"categories":["学习笔记"]},{"title":"给网站增加悬浮伸缩侧边栏","url":"/article/fab5c3df.html","content":"\n# 前言\n&emsp;&emsp;看到了不！看到了不！[@Heo](https://blog.zhheo.com/)的网站又双叒变好看了，还增加了个音乐灵动球！\n<img src=https://cdn.chuckle.top/images/25-2.webp width=\"80%\" height=\"80%\">\n\n&emsp;&emsp;开抄开抄~我也有了思路，魔改原来的悬浮aplayer，但一问，噢《新写了一个》，尝试抄了下却不能播放。但问题不大，按之前思路结合一下刚弄好的侧边栏，非常好。\n<img src=https://cdn.chuckle.top/images/25-3.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;很快成品完工~（但是还是好馋那个灵动乐球~）\n<img src=https://cdn.chuckle.top/images/25-1.webp width=\"60%\" height=\"60%\">\n\n***\n\n# 实现\n&emsp;&emsp;aplayer怎么开启看butterfly的文档。\n&emsp;&emsp;在`layout.pug`里加上：\n```pug 记得修改网易云歌单id\ninclude ./rightside.pug\n!=partial('includes/third-party/search/index', {}, {cache: true})\n!=partial('includes/dorakika/rightmenu',{}, {cache:true})\ninclude ./additional-js.pug\n//- 上面的是本来就有的，对齐上面的缩进，加上下面的内容\n.contact-info\n  .option\n    i.fas.fa-rocket\n    .bloktop\n    .text 还不造有啥用滴悬浮模块\n      .strip\n  .option\n    i.fas.fa-cube\n    .blok\n    .text\n      .strip\n      <div class=\"post-reward\"><button class=\"tip-button reward-button\"><span class=\"tip-button__text\">投喂</span><div class=\"reward-main\"><ul class=\"reward-all\"><li class=\"reward-item\"><a class=\"about-reward\" href=\"/img/weixin.webp\" target=\"_blank\"><img class=\"post-qr-code-img\" src=\"/img/weixin.webp\" alt=\"微信\"></a><div class=\"post-qr-code-desc\">微信</div></li><li class=\"reward-item\"><a class=\"about-reward\" href=\"/img/alipay.webp\" target=\"_blank\"><img class=\"post-qr-code-img\" src=\"/img/alipay.webp\" alt=\"支付宝\"></a><div class=\"post-qr-code-desc\">支付宝</div></li></ul></div></button></div>\n  .option\n    i.fas.fa-music\n    .blokbottom\n    .text.aplayertext\n      .strip\n      .aplayer.no-destroy(mutex='true', listfolded='true', data-id='你的网易云歌单id', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n\n```\n\n&emsp;&emsp;引入css：\n```css 不生效就在对应属性加上!important\n.contact-info{\n    position: fixed;\n    top: 22%;\n    z-index: 200;\n    left: -51px;\n    transition: 0.4s;\n  }\n  .contact-info:hover{\n    left: 0px;\n  }\n  .contact-info .option{\n    cursor: pointer;\n    position: relative;\n  }\n  \n  .contact-info .option i{\n    display: block;\n    width: 50px;\n    text-align: center;\n    height: 60px;\n    line-height: 60px;\n    background: rgb(255, 255, 255);\n    color: #b9b9b9;\n    font-size: 20px;\n    transition: 0.4s;\n    border-radius: 0 10px 10px 0;\n  }\n  \n  .contact-info .option:hover i{\n    color: #3498db;\n  }\n  .contact-info .text{\n    border-radius: 15px;\n    position: absolute;\n    height: 60px;\n    width: 200px;\n    background: rgba(255,255,255,.85);\n    top: 0;\n    z-index: -1;\n    left: -136px;\n    color: rgb(0, 0, 0);\n    line-height: 60px;\n    text-align: center;\n    transition: 0.4s;\n  }\n  .contact-info .aplayertext{\n    transition: none!important;\n  }\n  .aplayer{\n    position: absolute!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-body{\n    left: -60px;\n    position: absolute!important;\n    width: 370px!important;\n    transition: none!important;\n    border-radius: 10px!important;\n  }\n  .aplayer.aplayer-fixed{\n    left: -300px;\n  }\n  .contact-info .option:hover .aplayer.aplayer-fixed .aplayer-body,.contact-info .option:hover .aplayer.aplayer-fixed{\n    left: 0px;\n  }\n  .contact-info .option:hover .text{\n    left: 60px;\n  }\n  .contact-info .blok{\n    position: absolute;\n    height: 60px;\n    width: 100px;\n    top: 0;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .bloktop{\n    position: absolute;\n    height: 75px;\n    width: 100px;\n    bottom: 0px;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .blokbottom{\n    position: absolute;\n    height: 75px;\n    width: 100px;\n    top: 0;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .option:hover .blok,.contact-info .option:hover .bloktop,.contact-info .option:hover .blokbottom{\n    left: 0px;\n  }\n  .contact-info .option:hover .aplayertext{\n    left: 60px!important;\n    width: 370px!important;\n    background: transparent!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-miniswitcher{\n    border-radius: 0 10px 10px 0!important;\n  }\n  .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{\n    transition: 0.28s!important;\n    border-radius: 10px!important;\n  }\n  .aplayer .aplayer-pic{\n    height: 60px!important;\n  }\n  .aplayer .aplayer-info{\n    height: 60px!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body{\n    height: 60px;\n  }\n  .aplayer .aplayer-list.aplayer-list-hide{\n    margin-bottom: 59px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-list{\n    margin-bottom: 62px!important;\n    max-height: 240px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-info{\n    transition: none!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body{\n    height: 60px!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body, .aplayer.aplayer-narrow .aplayer-pic{\n    border-radius:  10px 0 0 10px!important;\n  }\n  .aplayer.aplayer-fixed{\n    border-radius: 10px!important;\n  }\n  .aplayer .aplayer-pic{\n    border-radius:  0 0 0 10px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-list{\n    border-radius: 10px 10px 0 0!important;\n  }\n  [data-theme=dark]\n  .contact-info .option i{\n    background: rgb(22, 22, 22);\n    color: #b9b9b9;\n  }\n  [data-theme=dark]\n  .contact-info .text{\n    background: rgba(23, 23, 23, 0.85);\n    color: rgba(255, 255, 255, 0.92);\n  }\n  @media screen and (max-width:1300px){\n    .contact-info{\n        display: none!important;\n      }\n  }\n  .aplayer{\n    opacity: .93!important;\n  }\n  [data-theme=dark]\n  .aplayer{\n    background: rgb(22, 22, 22)!important;\n    color: rgb(255, 255, 255);\n  }\n  [data-theme=dark]\n  .aplayer.aplayer-fixed .aplayer-body{\n    background: rgb(22, 22, 22)!important;\n    color: rgb(255, 255, 255);\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li:hover{\n    background: #3b3b3b;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li.aplayer-list-light{\n    background: #686868;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-info .aplayer-controller .aplayer-time{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li .aplayer-list-index{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li .aplayer-list-author{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{\n    fill: #d4d4d4;\n  }\n\n.contact-info .text .strip{\n    border-radius: 5px;\n    position: absolute;\n    height: 36px;\n    width: 5px;\n    background: rgba(20, 163, 230, 0.8);\n    top: 12px;\n    z-index: -1;\n    right: 4px;\n    transition: 0.4s;\n  }\n  .aplayertext .strip{\n    transition: none!important;\n  }\n  .contact-info .option:hover .aplayertext .strip{\n    background: transparent;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-miniswitcher{\n    background: rgba(23, 23, 23, 0.85);\n  }\n  .aplayer .aplayer-miniswitcher .aplayer-icon:hover path{\n    fill: #3498db;\n  }\n  [data-theme=dark]\n  .contact-info .option:hover i{\n    color: #3498db;\n  }\n.contact-info .option .text .post-reward .tip-button__text{\n  margin: 25px!important;\n}\n.post-reward .reward-button .reward-main .reward-all{\n  border-radius: 12px!important;\n}\n.contact-info .option .text .post-reward .reward-button .reward-main .reward-all{\n  z-index: 999!important;\n}\n[data-theme=\"dark\"]\n.contact-info .option .text .post-reward .tip-button{\n  border: solid 2px rgba(236, 233, 233, 0.8);\n  background: #043749d0;\n}\n```\n\n> 还缺着两个空位不知道该放些啥\n\n***\n\n# 后记\n&emsp;&emsp;2022年9月26日，Meting挂了，原因是ssl证书到期。\n&emsp;&emsp;为了aplayer的稳定，还是播放本地音乐吧。\n```pug #aplayer后加上js,并在配置文件关闭meting\n#aplayer.aplayer.no-destroy(mutex='true', listfolded='true', data-id='6609736315', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n  script.\n    const ap = new APlayer({\n      container: document.getElementById('aplayer'),\n      fixed: true,\n      order: 'random',\n      preload: 'none',\n      volume: 0.25,\n      audio: [\n        {\n        name: '越权访问-崩坏：星穹铁道',\n        artist: 'Hanser',\n        url: '/music/songs/1.mp3',\n        lrc: '/music/lrc/1.lrc',\n        cover: '/music/images/songs/1.webp'\n        }\n      ]\n    });\n    \n```\n\n&emsp;&emsp;10月18日，侧边栏增加打赏，好耶，又利用了一个模块，已更新上方的代码。\n\n&emsp;&emsp;2023年1月24日，Meting又挂了，原因是api过期，可以用vercel自建api，或者播放本地音乐。\n&emsp;&emsp;自建api地址：[vercel-meting](https://github.com/ladjeek-actions/vercel-meting)\n\n```pug\n.option\n  i.fas.fa-music\n  .blokbottom\n  .text.aplayertext\n+    script.\n+      var meting_api='<你的api>';\n    .strip\n    .aplayer.no-destroy(mutex='true', listfolded='true', data-id='11111111', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n\n```\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"添加音乐页面","url":"/article/3322c8a8.html","content":"\n# 前言\n&emsp;&emsp;没有音乐页面怎么行，花里胡哨的都安排上，本来想摆烂直接上aplayer，但考虑到网站速度以及aplayer的稳定性（和卜算子日常歇菜），还是弄个音乐播放器放自己本地的音乐好，又快又稳定。\n&emsp;&emsp;在网上找了个能用的h5播放器源码(找不到原作者)，适配下pjax和hexo，再改改样式就完成啦：[查看音乐页面](/music/)\n<img src=https://cdn.chuckle.top/images/24-1.webp width=\"50%\" height=\"50%\">\n\n***\n\n# 实现\n&emsp;&emsp;让指定单页的背景透明可以看此教程：[控制指定单页的背景样式](/article/eb3a4679.html)\n&emsp;&emsp;新建music单页，cv以下内容覆盖原内容：\n```html\n---\ncomments: false\naside: false\n---\n{% raw %}\n<!-- 播放器 -->\n<div class=\"music-player\">\n\t<!-- audio标签 -->\n\t<audio class=\"music-player__audio\" ></audio>\n\t<!-- 播放器主体 -->\n\t<div class=\"music-player__main\">\n\t\t<!-- 模糊背景 -->\n\t\t<div class=\"music-player__blur\"></div>\n\t\t<!-- 唱片 -->\n\t\t<div class=\"music-player__disc\">\n\t\t\t<!-- 唱片图片 -->\n\t\t\t<div class=\"music-player__image\">\n\t\t\t\t<img width=\"100%\" src=\"\" alt=\"\">\n\t\t\t</div>\n\t\t\t<!-- 指针 -->\n\t\t\t<div class=\"music-player__pointer\"><img width=\"100%\" src=\"/img/cd_tou.png\" alt=\"\"></div>\n\t\t</div>\n\t\t<!-- 控件主体 -->\n\t\t<div class=\"music-player__controls\">\n\t\t\t<!-- 歌曲信息 -->\n\t\t\t<div class=\"music__info\">\n\t\t\t\t<h3 class=\"music__info--title\">...</h3>\n\t\t\t</div>\n\t\t\t<!-- 控件... -->\n\t\t\t<div class=\"player-control\">\n\t\t\t\t<div class=\"player-control__content\">\n\t\t\t\t\t<div class=\"player-control__btns\">\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--prev\"><i class=\"iconfont icon-prev\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--play\"><i class=\"iconfont icon-play\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--next\"><i class=\"iconfont icon-next\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--mode\"><i class=\"iconfont icon-random\"></i></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"player-control__volume\">\n\t\t\t\t\t\t<div class=\"control__volume--icon player-control__btn\"><i class=\"iconfont icon-volume\"></i></div>\n\t\t\t\t\t\t<div class=\"control__volume--progress progress\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"player-control__content\">\n\t\t\t\t\t<div class=\"player__song--progress progress\"></div>\n\t\t\t\t\t<div class=\"player__song--timeProgess nowTime\">00:00</div>\n\t\t\t\t\t<div class=\"player__song--timeProgess totalTime\">00:00</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<!-- 歌曲列表 -->\n\t<div class=\"music-player__list\">\n\t\t<ul class=\"music__list_content\">\n\t\t</ul>\n\t</div>\n</div>\n<script src=\"/js/utill.js\"></script>\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.slim.min.js\"></script>\n<script src=\"/js/player.js?10\"></script>\n<div style=\"text-align:center;margin:-100px 0; font:normal 14px/24px 'MicroSoft YaHei';color:#ffffff\"></div>\n\n{% endraw %}\n\n```\n\n&emsp;&emsp;在`blog\\source\\music`下新建`songs`和`images`文件夹，`songs`内直接放入歌曲。再在`images`文件夹内新建`songs`文件夹，里面放歌曲封面。\n&emsp;&emsp;在`blog\\source\\img`内放入这两张图片[cd.png](https://blog.chuckle.top/img/cd.png)，[cd_tou.png](https://blog.chuckle.top/img/cd_tou.png)。\n\n&emsp;&emsp;在`\\blog\\themes\\butterfly\\source\\js`新建`player.js`。\n```js\n//创建一个音乐播放器的类 单例模式\nclass Player {\n    constructor() { //类的构造函数\n        //如果没有实例化，就去构造一个实例\n        return this.getInstance(...arguments);\n    }\n\n    //构建实例\n    getInstance() {\n        let instance = new PlayerCreator(...arguments);\n        //让实例可以使用到Player的原型的属性方法\n        // instance.__proto__=Player.prototype;\n        // instance.constructor=Player;\n        //把构建好的实例挂在Player类上\n        Player.instance = instance;\n        return instance;\n    }\n}\n\n//歌曲信息\nclass Musics {\n    //歌曲\n    constructor() {\n        this.songs = [{\n                id: 1,\n                title: '越权访问-崩坏：星穹铁道 - Hanser',\n                singer: '越权访问-崩坏：星穹铁道 - Hanser',\n                songUrl: './songs/1.mp3',\n                imageUrl: './images/songs/1.webp'\n            },\n            {\n                id: 2,\n                title: '妄想Reality（翻自 洛天依） - 炎祾',\n                singer: '妄想Reality（翻自 洛天依） - 炎祾',\n                songUrl: './songs/2.mp3',\n                imageUrl: './images/songs/2.webp'\n            },\n\t\t\t{\n                id: 3,\n                title: '人间失宠 - 昔诺',\n                singer: '人间失宠 - 昔诺',\n                songUrl: './songs/3.mp3',\n                imageUrl: './images/songs/3.webp'\n            },\n            {\n                id: 4,\n                title: '崩坏世界的歌姬 (Movie Ver.) - 小林未郁',\n                singer: '崩坏世界的歌姬 (Movie Ver.) - 小林未郁',\n                songUrl: './songs/4.mp3',\n                imageUrl: './images/songs/4.webp'\n            },\n\t\t\t{\n                id: 5,\n                title: '玛德琳娜电塔 - 花玲',\n                singer: '玛德琳娜电塔 - 花玲',\n                songUrl: './songs/5.mp3',\n                imageUrl: './images/songs/5.webp'\n            },\n        ]\n    }\n    //根据索引获取歌曲的方法\n    getSongByNum(index) {\n        return this.songs[index];\n    }\n}\n\n//真正的构建播放器的类\nclass PlayerCreator {\n    constructor() {\n        this.audio = document.querySelector('.music-player__audio') // Audio dom元素, 因为很多api都是需要原生audio调用的，所以不用jq获取\n        // this.audio.muted = true; // 控制静音\n        this.audio.volume = 0.2;\n\n        //工具\n        this.util = new Util();\n        this.musics = new Musics(); //歌曲信息\n        this.song_index = 0; // 当前播放的歌曲索引\n        this.loop_mode = 1; // 1 2\n        // 下方歌曲列表容器\n        this.song_list = $('.music__list_content');\n\n        this.render_doms = { //切换歌曲时需要渲染的dom组\n            title: $('.music__info--title'),\n            singer: $('.music__info--singer'),\n            image: $('.music-player__image img'),\n            blur: $('.music-player__blur')\n        }\n        this.ban_dom = { //禁音时需要渲染的dom组\n            control__btn: $('.control__volume--icon')\n        }\n\n        // 时间显示容器\n        this.render_time = {\n            now: $('.nowTime'),\n            total: $('.totalTime')\n        }\n\n        // 唱片\n        this.disc = {\n            image: $('.music-player__image'),\n            pointer: $('.music-player__pointer')\n        };\n        //播放器初始化\n        this.init();\n    }\n    //初始化函数\n    init() {\n        this.renderSongList();\n        this.renderSongStyle();\n        this.bindEventListener();\n    }\n    //生成播放列表\n    renderSongList() {\n        let _str = '';\n        this.musics.songs.forEach((song, i) => {\n            _str += `<li class=\"music__list__item\">${song.title}</li>`\n        });\n        this.song_list.html(_str);\n    }\n\n    //根据歌曲去渲染视图\n    renderSongStyle() {\n        let {\n            title,\n            singer,\n            songUrl,\n            imageUrl\n        } = this.musics.getSongByNum(this.song_index);\n        this.audio.src = songUrl;\n        this.render_doms.title.html(title);\n        this.render_doms.singer.html(singer);\n        this.render_doms.image.prop('src', imageUrl);\n        this.render_doms.blur.css('background-image', 'url(\"' + imageUrl + '\")');\n\n        //切换列表中的item的类名 play\n        this.song_list.find('.music__list__item').eq(this.song_index).addClass('play').siblings().removeClass('play');\n    }\n    //绑定各种事件\n    bindEventListener() {\n        //播放按钮\n        this.$play = new Btns('.player-control__btn--play', {\n            click: this.handlePlayAndPause.bind(this)\n        });\n        //上一首\n        this.$prev = new Btns('.player-control__btn--prev', {\n            click: this.changeSong.bind(this, 'prev')\n        });\n        //下一首\n        this.$next = new Btns('.player-control__btn--next', {\n            click: this.changeSong.bind(this, 'next')\n        });\n        //循环模式\n        this.$mode = new Btns('.player-control__btn--mode', {\n            click: this.changePlayMode.bind(this)\n        });\n        //禁音\n        this.$ban = new Btns('.control__volume--icon', {\n            click: this.banNotes.bind(this)\n        })\n        //列表点击\n        this.song_list.on('click', 'li', (e) => {\n            let index = $(e.target).index();\n            this.changeSong(index);\n        })\n\n        //音量控制 audio标签音量 vlouem 属性控制0-1\n\n        new Progress('.control__volume--progress', {\n            min: 0,\n            max: 1,\n            value: this.audio.volume,\n            handler: (value) => { //更改进度时\n                this.audio.volume = value;\n            }\n        })\n        //歌曲进度 this.audio.duration\n        //可以播放的时候触发（歌曲的基本信息都已经获取到了）\n        this.audio.oncanplay = () => {\n            //避免重复实例化\n            if (this.progress) {\n                this.progress.max = this.audio.duration; //切换歌曲后更新时长\n                this.render_time.total.html(this.util.formatTime(this.audio.duration));\n                return false;\n            };\n            this.progress = new Progress('.player__song--progress', {\n                min: 0,\n                max: this.audio.duration,\n                value: 0,\n                handler: (value) => {\n                    this.audio.currentTime = value;\n                }\n            })\n            //调整总时长\n            this.render_time.total.html(this.util.formatTime(this.audio.duration));\n        }\n\n        //会在播放的时候持续触发\n        this.audio.ontimeupdate = () => {\n            this.progress.setValue(this.audio.currentTime);\n            //调整当前时长\n            this.render_time.now.html(this.util.formatTime(this.audio.currentTime));\n        }\n\n        //当歌曲播放完成的时候\n        this.audio.onended = () => {\n            this.changeSong('next');\n            //播放完，换歌后，重新播放\n            this.audio.play();\n        }\n\n    }\n\n    //播放暂停控制\n    handlePlayAndPause() {\n        let _o_i = this.$play.$el.find('i');\n        //this.audio.pauseed值为true 说明目前是不播放\n        if (this.audio.paused) { //现在是暂停的 要播放\n            this.audio.play();\n            _o_i.removeClass('icon-play').addClass('icon-pause');\n            this.disc.image.addClass('play');\n            this.disc.pointer.addClass('play')\n        } else {\n            this.audio.pause();\n            _o_i.addClass('icon-play').removeClass('icon-pause');\n            this.disc.image.removeClass('play');\n            this.disc.pointer.removeClass('play');\n        }\n    }\n\n    //更改循环模式\n    changePlayMode() {\n        this.loop_mode++;\n        if (this.loop_mode > 2) this.loop_mode = 0;\n        this.renderPlayMode();\n    }\n    //更改按钮样式\n    renderPlayMode() {\n        let _classess = ['loop', 'random', 'single'];\n        let _o_i = this.$mode.$el.find('i');\n        //prop 改一些标签的自有属性 attr改一些标签的自定义属性\n        _o_i.prop('class', 'iconfont icon-' + _classess[this.loop_mode])\n    }\n    //更改歌曲索引\n    changeSongIndex(type) {\n        if (typeof type === 'number') {\n            this.song_index = type;\n        } else {\n            if (this.loop_mode === 0) {\n                //列表循环\n                this.song_index += type === 'next' ? 1 : -1;\n                if (this.song_index > this.musics.songs.length - 1) this.song_index = 0;\n                if (this.song_index < 0) this.song_index = this.musics.songs.length - 1;\n            } else if (this.loop_mode === 1) {\n                //随机播放\n                let _length = this.musics.songs.length;\n                let _random = Math.floor(Math.random() * _length);\n                for (let i = 0; i < 10000; i++) { //随机的数为本身则继续随机\n                    if (this.song_index == _random) {\n                        _random = Math.floor(Math.random() * _length);\n                    } else {\n                        this.song_index = _random;\n                        break;\n                    }\n                }\n            } else if (this.loop_mode === 2) {\n                this.song_index = this.song_index;\n            }\n        }\n    }\n    //歌曲时长\n    songTime() {\n        let totalMinute = parseInt(this.audio.duration / 60) < 10 ? \"0\" + parseInt(this.audio.duration / 60) : parseInt(this.audio.duration / 60);\n        let totalSecond = parseInt(this.audio.duration % 60) < 10 ? \"0\" + parseInt(this.audio.duration % 60) : parseInt(this.audio.duration % 60);\n        $('.totalTime').text(totalMinute + ':' + totalSecond);\n    }\n    //切换歌曲\n    changeSong(type) {\n        //更改索引\n        this.changeSongIndex(type);\n        //记录切歌前的状态\n        let _is_pause = this.audio.paused;\n        //切歌后更改视图显示\n        this.renderSongStyle();\n        //如果切歌前是在播放，就继续播放\n        if (!_is_pause) this.audio.play();\n    }\n    //禁音\n    banNotes() {\n        let _o_i = this.$ban.$el.find(\"i\");\n        if (this.audio.muted == true) { //如果禁音则开启\n            this.audio.muted = false;\n            _o_i.removeClass('icon-muted').addClass('icon-volume');\n        } else {\n            this.audio.muted = true;\n            _o_i.removeClass('icon-volume').addClass('icon-muted');\n        }\n    }\n}\n\n//进度条\nclass Progress {\n    constructor(selector, options) {\n        $.extend(this, options);\n        ///给this挂载传入的参数\n        this.$el = $(selector);\n        this.width = this.$el.width();\n        this.init();\n    }\n\n    //进度条初始化\n    init() {\n        this.renderBackAndPointer();\n        this.bindEvents();\n        this.drag();\n        this.value;\n        this.changeDOMStyle(this.width * this.value);\n    }\n    //为进度条渲染back和pointer\n    renderBackAndPointer() {\n        this.$back = $('<div class=\"back\">');\n        this.$pointer = $('<div class=\"pointer\">');\n\n        this.$el.append(this.$back);\n        this.$el.append(this.$pointer);\n    }\n\n    setValue(value) { //主动调用，传入value值，设置进度条样式\n        let _distance = this.width * value / (this.max - this.min);\n        this.changeDOMStyle(_distance);\n    }\n\n    drag() {\n        let ele = this.$pointer;\n        let father = this.$el;\n        let flag = false; //鼠标是否点击\n        ele.mousedown((e) => {\n            flag = true;\n            let mousePos = {\n                x: e.offsetX\n            }\n            $(document).mousemove((e) => {\n                if (flag === true) {\n                    let _left = e.clientX - father.offset().left - mousePos.x;\n                    let _distance = Math.max(0, Math.min(_left, father.outerWidth(false) - ele.outerWidth(false)))\n                    let _ratio = _distance / father.outerWidth(false);\n                    let _value = _ratio * (this.max - this.min); //当前的音量值\n                    this.changeDOMStyle(_distance);\n                    this.handler(_value); //更改进度之后，执行回调\n                }\n            })\n        })\n        $(document).mouseup(() => {\n            flag = false;\n        })\n\n    }\n\n    bindEvents() { //鼠标点击时更改\n        this.$el.click((e) => {\n            let _x = e.offsetX; //鼠标距离元素左边的距离\n            let _ratio = _x / this.width;\n            let _value = _ratio * (this.max - this.min); //当前的音量值\n            this.changeDOMStyle(_x);\n            this.handler(_value); //更改进度之后，执行回调\n        })\n    }\n    //更改pointer和back\n    changeDOMStyle(distance) {\n        this.$back.width(distance + 7 == 7 ? 0 : distance + 7);//进度为0时将进度条背景改为0否则加上进度按钮的长度\n        this.$pointer.css('left', distance + 'px');\n    }\n}\n\n\n//按钮类 \nclass Btns {\n    constructor(selector, handlers) {\n        this.$el = $(selector); //元素\n        this.bindEvents(handlers);\n    }\n    bindEvents(handlers) { //绑定事件\n        for (const event in handlers) {\n            //使用值的时候保证键值对在对象中是存在的\n            if (handlers.hasOwnProperty(event)) {\n                this.$el.on(event, handlers[event]);\n            }\n        }\n    }\n}\nnew Player();\ndocument.addEventListener('pjax:complete', (e) => {\n    new Player();\n})\n\n```\n\n&emsp;&emsp;在`\\blog\\themes\\butterfly\\source\\js`新建`utill.js`。\n```js\nclass Util {\n    constructor() {\n        if (Util.instance) return Util.instance;\n        return this.getInstance(...arguments);\n    }\n\n    getInstance() {\n        var instance = {\n            /*\n             *   formatTime 格式化时间（s）为 hour:minutes:seconds\n             *   @params  time  required number (s)\n             *   \n             *   return hour:minutes:seconds string\n             */\n\n            formatTime(time) {\n                //没有传time的时候\n                if (time === undefined) {\n                    this.handlerError(123, {\n                        method: 'formate',\n                        param: 'time'\n                    });\n                    return false;\n                }\n                let _time = Math.floor(time);\n                let _minutes = Math.floor(_time / 60);\n                let _hours = Math.floor(_minutes / 60);\n                let _seconds = _time - (_minutes * 60);\n\n                return (_hours ? this.fillZero(_hours) + ':' : '') + this.fillZero(_minutes - (_hours * 60)) + ':' + this.fillZero(_seconds);\n            },\n            /*\n             *   fillZero 为小于10的数字补0\n             *   @params  num  required number\n             *   return '01'.. string\n             */\n            fillZero(num) {\n                //当没有传time的时候\n                if (num === undefined) {\n                    this.handlerError(123, {\n                        method: 'fillZero',\n                        param: 'num'\n                    });\n                    return false;\n                }\n                //这个函数只是让我们在渲染/显示的时候有一个不同的效果，不要操作原数据\n                return num > 9 ? num : '0' + num;\n            },\n            errors: {\n                123: ({\n                    method,\n                    param\n                }) => {\n                    return method + 'function need a param ' + param;\n                }\n            },\n            handlerError(code, options) { //处理报错\n                console.error('[until error] message' + this.errors[code](options));\n            }\n        }\n        Util.instance = instance;\n        return instance;\n    }\n}\n\n//为了这个工具以后在模块化环境中依然可以使用，需要判断一下，如果是在模块化环境，就将其暴露出去\n//commonJs\nif (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = Util;\n}\n\n//AMD\nif (typeof define === 'function' && define.amd) {\n    define('util', [], function () {\n        return Util;\n    });\n}\n\n```\n\n&emsp;&emsp;引入css（一些高度和细节按需自行调整）：\n```css\n/* 播放器大小 */\n.music-player {\n  width: 570px;\n  height: 500px;\n}\n.music-player h3{\n  margin: 0px 0 1px!important;\n}\n@font-face {font-family: \"iconfont\";\n  src: url('iconfont.eot?t=1537976418058'); /* IE9*/\n  src: url('iconfont.eot?t=1537976418058#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAmcAAsAAAAADgwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFY8lGHxY21hcAAAAYAAAACUAAACBGvSDaxnbHlmAAACFAAABUMAAAbwatoOAWhlYWQAAAdYAAAALwAAADYSwtboaGhlYQAAB4gAAAAcAAAAJAfeA4tobXR4AAAHpAAAAA8AAAAoKAAAAGxvY2EAAAe0AAAAFgAAABYIpgZ4bWF4cAAAB8wAAAAdAAAAIAEYAGNuYW1lAAAH7AAAAUUAAAJtPlT+fXBvc3QAAAk0AAAAZQAAAJSspZ5ZeJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2BkYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGByeyf3/z9zwv4EhhrmBoQEozAiSAwD0fA0ZeJztkcENwjAQBMdxCAQhQgU88qYeesBKGoh48aLSS7oIa1+QKIKzxtKedWdpF9gBUdxEDeFNINdL3VD6kWPp19ylzxyoaOxqvSUb57RM6wqbHr76p4Jm/Fx0oNGfUVtabdzrueFfp3I/N9VmPx25hfVOzsqSkzOzwZGX2Ojk2Tk5Oc9lcuR0x6OQE+lIBag+4Pgp1HicbVVrjBNVFJ5z796Zvu482plOH0tLZ9rp7hba0m5bZLuUhwZNQEB2F7airBDlERd5/IX4b+MPE3/wUhMTEkLEQAwkhpAIgcCaGI3xpyQqwb/orgsmGs129Ex3UWJoJufec+43PfN955wZgQjC37/SL6giGEKvIESgHjWNHBpNhnzOQAPOILCaH2psI9xP9BNQ4gNACqb7kBRi7lKVbnEvuU2YhhG4ADuUUOn0bUUpdl4e0JU7J9HAuFYEZ3bWveNOz8wI+PtfTj+ITr7G0GirwWQ1NBDVIWf4wcjRz9ylsQJxH5oFAgNxUEh/Au6r85cx3bTbdC/BdvdjRR84eQcNOV9UlNunSyHFvRAuut/PzEAThmdnMWcP5nxA99F9giZkhKIwJAhmEbyMjYoJKdBFCUQqg6mJUbPegLqDxCOWU29BPQWiAqL0pHO3UAGoFJZaRE2l0+nOo2w6IQPICS1K5CxYnTmj45Noj48FRMKknq8854Ou835PFJoVcrbSBN29rJXqpbB7RacbSJ/cmVD6CIRgs1HWYWuw82UwSBmlgQBl5DjuJyj1oyWLGn5Na7QhKEJaEMCWwdD0qFlFQqh3Dn1JS8Fjn/zeStp2spWwAWy3vDrprcmFhTZw2wl3jxJkduHoSd+rGcV8f9Cb1C/khPXCGGbEBHjZljNYb3hZ8Krm0amksXooER60wHQsUU+DjVI7MkTNFAyBJOrRCio5mIcqPmHUrKDYCMBH1qPkkfPuuolPnx+KxGKRofJHG9sfDq9s8oQtT4VCU7KV5E0i2wneXNn70nLZjgNf/3oJAUnLA8x/PmTvHOBqJA5y662a9yekxI6v3fUejediwN7ZOP42XcUzidAUz/KpUCLLV//EE1l5GNYUOCSzvPXsKm4lOB6HYC9dlw9Bb5YPbQCI5eKLOqDZT34RkqjEWk95SxIlz3j6D0Eam6mKa72hOdQpga1VReynRn3QsRRUoavHogRmtIIqEE44v+HfG+FKIrK/NhGLAeckLkmWOvrasWNkxyFg45KsSuNtSeViuy1yVWqPS6oskZ/95wIhVXUfRBKlrRHD39NLTvd2dskvjEAv2bzbnW6LGpfGxyWueTf+u+/Ow4/0IrVxHvqFljCKTLCeBSzrEvB4VKJpwKoUACuDI4mBegPfC0hSzDfEIvLDghc9CM5rCgxdNBejtf+iJs5E5x5HDcLxeLiq2fzenz7DX82VcXrsqt/wAZUjEfmKTwtSKdsH0JeTIKhJy1as0LuxTaMwuqkbGnkV4BVy91owBHHtejjGg9feZz4oZ6/bFZ/4XdAfnp8L+4M/MKJobMnW4rIXU6ImEzG7q/7M7m9wtjWxeXH3zvMtjAJ77uobb95YnKNb9BZdIzjCJkHIZbAfZawpVq4ILWRR7XJTIIN0a9jd0SUoEWTyDopS9URKgYIR7HA8bUEGZwLxljOM95KrLi8rQAzFp7LJAAlNMtWn6D7WD3NjB4mW0ugp14K5sroI8ZPggccQV912eAEysDwQUTQfmwj0BvYwBroicZanh0bGFE1TxiZPkE+eimBHxtpyOCxvP3qmO783uzzzwubu/Fqix0TKeBUbdPKW91rr0qlipZH+AmGHVeoelUYGu8PQvWHF0e2qY1uihL28wDjKNFsyGxo9q2jk4Jir9jOf3uUUhECXtoFfjjL8duQU1eavIOjwNph7DDoQJP5FkFp2VQ8D35a3qMNwDgmOHKJ5xiVFB8b2IMMJ5tOUSGA5PTGJCmwJy+2xI+ypCHLm6HY5fBTWrOrvd//Ccv8D5gQugwB4nGNgZGBgAOJ0oeli8fw2Xxm4WRhA4PrFk0kI+v9+FgbmDCCXg4EJJAoAItUKtAB4nGNgZGBgbvjfwBDDwgACQJKRARVwAQBHEAJzeJxjYWBgYCECAwADmAApAAAAAAAAOgB0ANwBFAGYAfwCgAL0A3gAAHicY2BkYGDgYghnYGEAASYwjwtI/gfzGQASMwF8AAAAeJxlj01OwzAQhV/6B6QSqqhgh+QFYgEo/RGrblhUavdddN+mTpsqiSPHrdQDcB6OwAk4AtyAO/BIJ5s2lsffvHljTwDc4Acejt8t95E9XDI7cg0XuBeuU38QbpBfhJto41W4Rf1N2MczpsJtdGF5g9e4YvaEd2EPHXwI13CNT+E69S/hBvlbuIk7/Aq30PHqwj7mXle4jUcv9sdWL5xeqeVBxaHJIpM5v4KZXu+Sha3S6pxrW8QmU4OgX0lTnWlb3VPs10PnIhVZk6oJqzpJjMqt2erQBRvn8lGvF4kehCblWGP+tsYCjnEFhSUOjDFCGGSIyujoO1Vm9K+xQ8Jee1Y9zed0WxTU/3OFAQL0z1xTurLSeTpPgT1fG1J1dCtuy56UNJFezUkSskJe1rZUQuoBNmVXjhF6XNGJPyhnSP8ACVpuyAAAAHicbcrBCoNADATQjLau3dWPjBTdaInINqD9+gb06MBc3gxVdCbSfSIq1HjgiQYBLV6ISJRKZp0OKXm1sBjLLNoM6+gYfqxf0SkVc73MZ39r6/2IQ7+bZmM95+7NutlFRH+UdSMxAAAA') format('woff'),\n  url('iconfont.ttf?t=1537976418058') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n  url('iconfont.svg?t=1537976418058#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.icon-prev:before { content: \"\\f0069\"; }\n\n.icon-next:before { content: \"\\f006a\"; }\n\n.icon-play:before { content: \"\\e66a\"; }\n\n.icon-pause:before { content: \"\\e76a\"; }\n\n.icon-random:before { content: \"\\e622\"; }\n\n.icon-muted:before { content: \"\\e61e\"; }\n\n.icon-volume:before { content: \"\\e87a\"; }\n\n.icon-loop:before { content: \"\\e66c\"; }\n\n.icon-single:before { content: \"\\e66d\"; }\n\n\n/* 播放器位置 */\n.music-player {\n  position: relative;\n  margin: 0px auto;\n}\n\n/* 歌曲列表 */\n\n.music-player__list {\n  width: 100%;\n  padding: 10px;\n  margin-top: 30px;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 5px;\n  -webkit-box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);\n  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);\n}\n\n.music__list__item {\n  padding-left: 25px;\n  color: #ccc;\n  position: relative;\n  margin-bottom: 10px;\n  font-size: 14px;\n  cursor: pointer;\n}\n\n.music__list__item:last-of-type {\n  margin: 0;\n}\n\n.music__list__item.play {\n  color: #fff;\n}\n\n.music__list__item.play:before {\n  font-family: 'iconfont';\n  content: \"\\e87a\";\n  position: absolute;\n  left: 0px;\n  top: 4px;\n}\n/* 播放器主体 */\n.music-player__main {\n  height: 180px;\n  padding: 25px;\n  box-shadow: 0 0 10px rgb(0 0 0 / 20%);\n  border-radius: 10px;\n  position: relative;\n  overflow: hidden;\n}\n\n/* 播放器主体模糊背景 */\n.music-player__blur {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background-size: 100%;\n  left: 0;\n  top: 0;\n  z-index: -1;\n  -webkit-filter: blur(20px);\n  filter: blur(20px);\n}\n/* 播放器唱片效果 */\n.music-player__disc {\n  float: left;\n  width: 130px;\n  height: 130px;\n  background: url(/img/cd.png) no-repeat center;\n  background-size: 100%;\n  position: relative;\n}\n\n/* 唱片指针 */\n.music-player__pointer {\n  width: 25px;\n  position: absolute;\n  right: -10px;\n  top: 0;\n  -webkit-transform-origin: right top;\n  -ms-transform-origin: right top;\n  transform-origin: right top;\n  -webkit-transform: rotate(-15deg);\n  -ms-transform: rotate(-15deg);\n  transform: rotate(-15deg);\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n}\n\n/* 唱片指针播放状态 加play类名 */\n.music-player__pointer.play {\n  -webkit-transform: rotate(0deg);\n  -ms-transform: rotate(0deg);\n  transform: rotate(0deg);\n}\n\n/* 唱片歌曲图片 */\n.music-player__image {\n  width: 80px;\n  height: 80px;\n  border-radius: 50%;\n  position: absolute;\n  overflow: hidden;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  margin: auto;\n}\n/* 播放器控件 */\n.music-player__controls {\n  width: 330px;\n  height: 130px;\n  float: right;\n}\n\n/* 歌曲信息 */\n.music__info {\n  width: 100%;\n  height: 50px;\n  margin-bottom: 15px;\n}\n\n.music__info .music__info--title {\n  color: #fff;\n}\n\n.music__info .music__info--title {\n  font-size: 16px;\n}\n/* 控件 */\n\n.player-control {\n  width: 100%;\n}\n\n.player-control__content {\n  overflow: hidden;\n}\n\n/* 播放暂停按钮 */\n.player-control__btns {\n  float: left;\n  overflow: hidden;\n}\n\n.player-control__btn {\n  float: left;\n  margin: 0 5px;\n  font-weight: bolder;\n  color: #fff;\n  cursor: pointer;\n}\n\n.player-control__volume {\n  float: right;\n  overflow: hidden;\n}\n\n.control__volume--progress {\n  float: left;\n  width: 100px;\n  position: relative;\n  top: 8px;\n}\n\n.player__song--timeProgess{\n  font-size: 12px;\n  color: #fff;\n  padding: 0px 3px;\n  background: rgba(0, 0, 0, 0.3);\n  border-radius: 5px;\n}\n\n.player-control__content .nowTime{\n  float: left;\n}\n.player-control__content .totalTime{\n  float: right;\n}\n\n.music-player .progress {\n  background: rgba(0, 0, 0, 0.3);\n  height: 5px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) inset;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) inset;\n  overflow: hidden;\n  margin: 0.5rem 0!important;\n  border-radius: 2px;\n  position: relative;\n  cursor: pointer;\n}\n\n.music-player .progress .back {\n  width: 0px;\n  height: 100%;\n  border-radius: 2px;\n  background: rgb(12, 182, 212);\n}\n\n.music-player .progress .pointer {\n  width: 7px;\n  height: 7px;\n  background: #fff;\n  border-radius: 50%;\n  opacity: 0;\n  -webkit-transition: opacity 0.3s;\n  -o-transition: opacity 0.3s;\n  transition: opacity 0.3s;\n  position: absolute;\n  top: -1px;\n  left: 0;\n}\n\n.music-player .progress:hover .pointer {\n  opacity: 1;\n}\n\n\n/* 播放 画片 动画 */\n\n@-webkit-keyframes disc {\n  from {\n      -webkit-transform: rotate(0deg);\n      transform: rotate(0deg);\n  }\n\n  to {\n      -webkit-transform: rotate(360deg);\n      transform: rotate(360deg);\n  }\n}\n\n@keyframes disc {\n  from {\n      -webkit-transform: rotate(0deg);\n      transform: rotate(0deg);\n  }\n  to {\n      -webkit-transform: rotate(360deg);\n      transform: rotate(360deg);\n  }\n}\n.music-player__image.play {\n  -webkit-animation: disc 5s linear 0s infinite;\n  animation: disc 5s linear 0s infinite;\n}\n/*  播放进度  */\n.player__song--progress {\n  width: 100%;\n  margin-top: 15px;\n}\n.music-player h1, .music-player h2, .music-player h3,.music-player h4, .music-player h5, .music-player h6, .music-player p {\n  margin: 0; padding: 0;\n}\n.music-player li { list-style: none; }\n\n```\n\n&emsp;&emsp;修改`player.js`里`this.songs`的歌曲信息，把音乐换成自己的，接着三连即可。\n>本地浏览可能音乐的进度条无法拖动或者一拖动音乐就回到最开头，问题不大，推送上去就正常了。\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"归档、分类、标签页文章卡片加上所属分类和标签","url":"/article/a19bb7fb.html","content":"\n# 前言\n&emsp;&emsp;如图，上面修改前，下面修改后。\n<img src=https://cdn.chuckle.top/images/23-2.webp width=\"90%\" height=\"90%\">\n\n# 实现\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\includes\\mixins\\article-sort.pug`\n```\n.article-sort-item-info\n    .article-sort-item-time\n        time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n        a.article-sort-item-title(href=url_for(article.path) title=title)= title\n+    .article-meta-wrap\n+        if (theme.post_meta.page.categories && article.categories.data.length > 0)\n+            span.article-sort-item-categories\n+                i.iconfont.icon-fenlei//- 记得改成自己的图标\n+                each item, index in article.categories.data\n+                    a(href=url_for(item.path)).article-meta__categories #[=item.name]\n+                    if (index < article.categories.data.length - 1)\n+                       i.fas.fa-angle-right\n+        if (theme.post_meta.page.tags && article.tags.data.length > 0)\n+            span.article-sort-item-tags\n+                i.iconfont.icon-biaoqian//- 记得改成自己的图标\n+                each item, index in article.tags.data\n+                    a(href=url_for(item.path)).article-meta__tags #[=item.name]\n+                    if (index < article.tags.data.length - 1)\n+                        span.article-meta__link #[='•']\n+        .article-sort-item-time\n+            time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n\n```\n\n&emsp;&emsp;增加css：根据自己的实际样式情况进行微调，没有通用css。\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"控制指定单页的背景样式","url":"/article/eb3a4679.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客单页，无论是哔哔，友链，还是关于页，page的背景都是透明的，一开始我以为是在单页的index.md里单独引入css，后来才知道，是直接`#page{background:transparent;}`,这只会让所有非文章、归档、分类、标签的单页背景透明。\n\n&emsp;&emsp;这好啊，果断抄走，然后不出意外，有些单页变得很难看，因为没关侧边栏（侧边栏没透明，page透明了），或因为背景透明后字看不清（友链页），反正，我需要能单独控制单页page的背景样式，说干就干，让不同单页加上不同class，css控制这些class即可。\n<img src=https://cdn.chuckle.top/images/22-1.webp width=\"40%\" height=\"40%\">\n\n***\n\n# 实现\n## 方案一\n&emsp;**让指定单页背景样式相同(如透明)**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制哪些单页的背景就加上is_current('<单页路径>')\nblock content\n+  - let transparent = (is_current('/bb/') || is_current('/charts/')) ? true : false\n-  #page\n+  #page(class= (transparent === true) ? 'transparentpage' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug 这里是让指定单页的背景都透明\n.transparentpage{\n    background:transparent!important;\n}\n\n```\n\n## 方案二\n&emsp;**控制不同单页有不同背景样式**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制更多单页就仿照格式写\nblock content\n+  - let bb = is_current('/bb/') ? true : false\n+  - let charts = is_current('/charts/') ? true : false\n-  #page\n+  #page(class= (bb === true) ? 'bb-transparent' : '')(class= (charts === true) ? 'charts-transparent' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug\n.bb-transparent{\n    background:transparent!important;\n}\n.charts-transparent{\n    background:blue!important;\n}\n\n```\n\n&emsp;&emsp;此方法存在一个问题：\n&emsp;&emsp;hexo g和hexo s时，会提示:You should not have pug tags with multiple attributes.（您不应该使用具有多个属性的pug标记）\n&emsp;&emsp;这是因为我尝试多次class=()，但实际上，因为路径是唯一的，这不会导致出问题，对hexo渲染没有影响。\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Butterfly给首页首个文章卡片加个class","url":"/article/dbde845d.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客首页，他的第一个文章卡片是其余卡片宽度的两倍，F12可知是首页的首个文章卡片多了一个class，虽然我的文章卡片暂时没这需求，但刚好有人问怎么才能控制首页第一个文章卡片的样式，也刚好我有思路，就实现一下吧\n&emsp;&emsp;关键就是怎么给首个文章卡片加一个class，我想到了和之前[给文章卡片加上最新文章标志](/article/2ed7d622.html)差不多的操作\n<img src=https://cdn.chuckle.top/images/21-2.webp width=\"100%\" height=\"100%\">\n***\n\n# 实现\n&emsp;&emsp;先看原来post-ui的结构:``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    .recent-post-item//要在这里加个calss\n    //后面就是文章卡片的具体的内容\n\n```\n\n&emsp;&emsp;可以改成这样，就能将首页第一个文章卡片和其余卡片分开渲染成html，自然，加个class就轻而易举了\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    if (firstpost !== 1 && is_current('/'))\n      - var firstpost = 1\n      .recent-post-item.firstpost-item\n      //首页首个文章卡片的具体的内容（cv原来的就行）\n    else\n      .recent-post-item\n      //其余文章卡片的具体的内容（cv原来的就行）\n\n```\n\n&emsp;&emsp;这样，首页第一个文章卡片就会多一个``firstpost-item``class，控制这个class就能控制样式了\n<img src=https://cdn.chuckle.top/images/21-1.webp width=\"40%\" height=\"40%\">\n\n&emsp;&emsp;而且这样改完pug，首页第一个文章卡片有更多的操作空间，可以完全和其余卡片长得不一样，修改具体内容里的源码即可\n***\n\n# 优化\n&emsp;&emsp;[@heo](https://blog.zhheo.com/)的代码结构优化版本（适合无需对首页第一个卡片进行定制化）\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    - let lastPost = firstpost !== 1 && is_current('/') ? true : false\n    - var firstpost = 1\n    .recent-post-item(class= (lastPost === true) ? 'firstpost-item' : '')\n    \n```\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Butterfly文章卡片加上最新文章标志","url":"/article/2ed7d622.html","content":"\n# 前言\n&emsp;&emsp;昨天[@Leonus](https://blog.leonus.cn/)大佬用js给首页最新的文章卡片加上了``最新``标志:[几行代码实现最新文章标志 | Leonus](https://blog.leonus.cn/2022/newpost.html)\n&emsp;&emsp;不过每次切换到首页都要执行这个js，不然最新标志就不显示，开启了pjax之后,怎么让这js每次切换到首页都执行是个问题，而且每次都执行也会多吃一些性能\n\n&emsp;&emsp;因为butterfly是按创建时间顺序排序的，最上面的卡片就是最新文章，直接修改文章卡片源码，给第一个卡片加上``最新``标志就行了（当然还要排除手动置顶的文章）\n&emsp;&emsp;这样pug渲染成html时，``最新``标志就写死在那了\n<img src=https://cdn.chuckle.top/images/20-1.webp width=\"30%\" height=\"30%\">\n***\n\n# 实现\n>我这实现看起来挺笨，有大佬有更好的实现方式不\n\n1. 修改``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``&emsp;加上三行：\n```pug\n.recent-post-info\n+    if (numberone !== 1 && is_current('/') && (!article.top || (article.new && article.top)))\n+        span.newPost 最新\n+        - var numberone = 1\n```\n\n2. 在你的自定义css文件中，添加如下代码：\n```css\n/* 最新文章图标 */\n.newPost {\n    position: absolute;\n    top: 0;\n    color: rgba(255, 255, 255, 0.92);\n    padding: 0 15px;\n    background-color: #49b0f5b9;\n    border-radius: 0 0 10px 10px;\n    right: 40px;\n}\n@media screen and (max-width:600px){\n  .newPost {\n    right: 0px;\n    padding: 0 12px;\n    border-radius: 0 10px 0px 10px;\n}\n}\n```\n\n***\n\n# 使用\n&emsp;&emsp;当首页没有置顶时，会给第一个卡片加上最新标志\n&emsp;&emsp;当首页有置顶时，会给非置顶的第一个卡片加上最新标志\n\n&emsp;&emsp;显然，这里有bug，如果置顶里的文章就是最新的咋办？\n&emsp;&emsp;只需要在文章头部加上``new: true``就行了\n\n&emsp;&emsp;稍微有点麻烦，所以，建议最新的文章就没必要置顶了，反正不置顶也在第一个\n```\n---\ntitle: aaaaaaaaaa\ntop: 1\n+ new: true\n---\n```\n\n***\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"小米妙享--MIUI的生态互联","url":"/article/eb38f645.html","content":"\n# 引言\n&emsp;&emsp;不少人去年就听说了这个功能，作为小米产品生态构建的重要一环（全局设备互联互通），这个功能我却迟迟没去更新使用，因为它与miui+的割裂导致使用起来比较繁琐，也因为它把平板排除于外，当然最主要是我实在没有这么多设备需要去``流转``。\n&emsp;&emsp;但在最近的更新中，``小米妙享``不仅将miui+给整合进了`妙享中心`，还带上了小米平板5系列，为平板与电脑的互联互通增加了几个重要的功能。\n\n# 如何安装\n&emsp;&emsp;我喜欢小米的一点，就是它将系统功能都作为一个个软件的形式打包，不同批次的软件之间兼容性也不错，除非跨安卓版本才能实现的功能（例如米版的全局手写，这个基于安卓12，自然安卓11用不了），都可以通过安装或更新软件来使用新功能，正好，小米妙享就是这样一个安装即用的系统功能。  \n\n## 平板/手机端\n&emsp;&emsp;我的平板还在13.0.6这个稳定版养老，下载安装最新的`miui+`、`投屏`、`小米互联通信`,手机端就搞定了(没有资格就刷个`Miui解锁小米妙享模块`)。\n\n## 电脑端\n&emsp;&emsp;目前电脑端软件有限制，只有小米电脑上才能使用，但这难不倒酷友们，跟着此帖即可在电脑端安装好妙享中心：[最新miui+（小米妙享）PC版安装及配置教程](https://www.coolapk.com/feed/38357299?shareKey=MzdiMWMzNjNmMTgwNjJmYTcyYmI~&shareUid=4137393&shareFrom=com.coolapk.market_12.0.2)。\n\n# 使用体验\n\n## 互联\n&emsp;&emsp;电脑打开蓝牙，平板打开蓝牙、wifi、小米互传，让设备处于同一网络下，电脑端点击连接，等待`1-2秒`，很快即可连接上。且蓝牙wifi我一般保持常开，平板使用时也是手机或电脑给平板开热点，基本能做到需要就点击连接。\n<img src=https://cdn.chuckle.top/images/19-1.webp width=\"60%\" height=\"60%\"><img src=https://cdn.chuckle.top/images/19-3.webp width=\"60%\" height=\"60%\">\n\n## 平板作为电脑副屏\n&emsp;&emsp;这个功能是这次妙享更新后给米版上的新功能，在连接成功后可以看到两种副屏方式，作为镜像屏，或者扩展屏。选择任意一种副屏方式，同样等待2秒，就可完成副屏的启动。\n&emsp;&emsp;作为一个`无线可触摸`的副屏，使用起来非常舒适。\n<img src=https://cdn.chuckle.top/images/19-2.webp width=\"60%\" height=\"60%\">&emsp;&emsp;侧边栏有一些快捷键：“返回桌面”“多任务”“保存”“返回/撤销上一步操作”“保存截图”“屏幕键盘”“退出”。\n\n### 作为镜像屏\n&emsp;&emsp;利用秒表测试有0.04s延迟（屏幕一半播视频，一半秒表计时，拍照算时差，确保符合正常使用的延迟），实际体验下延迟确实可忽略不计，分辨率1920*1080（等同电脑屏幕分辨率），但帧率在40到60之间波动，习惯了120帧确实有点不舒服，不过也远胜我之前用的spacedesk。\n<img src=https://cdn.chuckle.top/images/19-4.webp width=\"60%\" height=\"60%\">&emsp;&emsp;小米妙享实际上是一个软件，那当然可以上滑挂在后台，或者挂个小窗在前台。  \n\n<img src=https://cdn.chuckle.top/images/19-5.webp width=\"60%\" height=\"60%\">&emsp;&emsp;在电脑端还可以设置侧边栏的位置、使用米板作为电脑的音频输出等。\n\n<img src=https://cdn.chuckle.top/images/19-6.webp width=\"60%\" height=\"60%\">\n\n### 作为扩展屏\n&emsp;&emsp;作为扩展屏时与镜像屏时差不多，同样有低延迟、高分辨率（作为扩展屏时分辨率1920*1200），同样可以挂后台挂小窗，设置侧边栏的位置、使用米板作为电脑的音频输出等。\n&emsp;&emsp;但此时帧率在30到50之间波动，可以感觉到鼠标拖动的略微不顺畅的卡顿，且窗口在平板与电脑直接拖动时，大小变化还有待优化，经常拖到平板还得再手动调小窗口大小。\n<img src=https://cdn.chuckle.top/images/19-7.webp width=\"60%\" height=\"60%\">\n&emsp;&emsp;无论是作为镜像还是扩展屏，吃电脑资源都不多。\n<img src=https://cdn.chuckle.top/images/19-10.webp width=\"70%\" height=\"70%\">\n\n## 平板投屏到电脑\n&emsp;&emsp;应用流转仅限于小米的设备，自然投屏也需要小米笔记本才行，不过酷友[@迷璐](https://www.coolapk.com/u/1189245)的模块可以让其它品牌的电脑也出现在妙享界面，只需要将平板画面拖到电脑的气泡上，1-2秒后，电脑上就有平板的投屏窗口了，投屏后平板可关闭屏幕。\n<img src=https://cdn.chuckle.top/images/19-11.webp width=\"60%\" height=\"60%\">&emsp;&emsp;投屏窗口可最大化可最小化，利用秒表测试有0.07s延迟（主界面播视频，小窗秒表计时，拍照算时差，确保符合正常使用的延迟），分辨率至少有1080p以上，帧数稳稳50-60帧。\n\n<img src=https://cdn.chuckle.top/images/19-12.webp width=\"60%\" height=\"60%\">&emsp;&emsp;值得注意的点是，这不是简单的投屏，投屏后，不仅平板的画面会在电脑上出现个窗口，平板上的所有音频也会用电脑的喇叭输出，而且可以直接使用电脑的键盘、鼠标去控制、操作平板。\n\n## 互通\n&emsp;&emsp;平板端截图，电脑会弹出有图和保存按键的小悬浮窗。\n<img src=https://cdn.chuckle.top/images/19-8.webp width=\"40%\" height=\"40%\">&emsp;&emsp;平板端或电脑端复制文字内容，另一个设备会同步这个内容到剪切板，并弹窗提示，且电脑端的弹窗会显示复制的文字内容。当任意一设备复制的是网址时，悬浮窗还会有直接打开网站的按键。\n\n<img src=https://cdn.chuckle.top/images/19-9.webp width=\"60%\" height=\"60%\">\n\n### 电脑与平板互传文件\n&emsp;&emsp;平板长按文件点分享，选择电脑即可；电脑端使用用小米互传向平板传文件，两种操作都非常方便且快速。\n<img src=https://cdn.chuckle.top/images/19-13.webp width=\"70%\" height=\"70%\">\n\n# 使用感受\n&emsp;&emsp;在简单上手平板与电脑之间的妙享后，可以确定，我以后将经常用到它的功能，实际上我还体验了平板-手机-电脑的三方互联互通，不过任意两个设备互联后，另一个设备就会断开连接（虽然重连很快，但还是很影响体验），所以三方互联的体验并不好，但平板-手机、手机-电脑之间的妙享体验也不错。\n&emsp;&emsp;可以看得出来MIUI还是有认真去做互联互通生态的，未来可期。\n\n# 不足之处\n1. 多设备同时互联体验差。\n2. 作为扩展屏与电脑之间拖动软件窗口，窗口大小自适应效果不好。\n3. 虽然博主安装起来较轻松，但不少酷友倒在了电脑硬件或其它配置上。\n4. 依赖核显（考虑考虑没核显或核显弱的笔记本？）。\n5. 平板投屏到电脑不能像手机与电脑的互联那样，直接拖文件传输。\n6. 手机应用流转到平板居然开倒车！直接全屏，而不是像之前那样在平板上弹出小窗。","tags":["小米妙享","MIUI"],"categories":["其它"]},{"title":"JavaWeb笔记--寄途的初始","url":"/article/7c1f73d5.html","content":"\n咕咕咕（\n","tags":["JavaWeb","JAVA"],"categories":["学习笔记"]},{"title":"JavaSE查缺补漏笔记","url":"/article/3c6a38d9.html","content":"\n>跟着翁恺或者学校的进度学完的JavaSE，如泛型、I/O、线程、映射、反射等等大部分没有提到或只是简略介绍，想要从JavaSE衔接上JavaEE，这些知识不可跳过。\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"超星学习通数据泄露事件记录","url":"/article/af84a159.html","content":"\n# 事件时间轴\n{% timeline 时间轴 ,blue %}\n<!-- timeline 2022-06-20 -->\n1. 学习通被爆有`1.7亿`师生账号信息`数据泄露`  \n包括手机号码、邮箱、姓名、学校、班级、明文密码等信息  \n随后，热搜词条`#学习通数据库疑发生信息泄露#`被撤,词条内容被屏蔽\n<div><img src=https://cdn.chuckle.top/images/13-1.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 上午-->\n`#学习通#`词条登顶微博热搜第一\n很多人发现自己学习通的使用量多达上万、几十万次（图为博主的次数，2万次）\n<div><img src=https://cdn.chuckle.top/images/13-2.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 15:45-->\n学习通就泄露事件做出声明：`目前还未发现数据泄露，确认不存在明文密码泄露。`\n<div><img src=https://cdn.chuckle.top/images/13-3.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 16:17-->\n学习通就异常使用量做出声明：`正常现象。`\n<div><img src=https://cdn.chuckle.top/images/13-4.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n***\n\n# 事件相关\n1. 2020年超星学习通就被[国家信息安全漏洞共享平台(cnvd)](https://www.cnvd.org.cn/)警告存在`信息泄露漏洞`\n{% link 超星学习通App存在信息泄露漏洞, https://www.cnvd.org.cn/flaw/show/CNVD-2020-61119, %}\n<div><img src=https://cdn.chuckle.top/images/13-5.webp width=\"40%\" height=\"40%\"></div>\n\n2. 著名蓝色机器人发通知与投票：\n<div><img src=https://cdn.chuckle.top/images/13-6.webp width=\"40%\" height=\"40%\"></div>\n\n3. 博主已中招\n<div><img src=https://cdn.chuckle.top/images/13-7.webp width=\"40%\" height=\"40%\"></div>\n\n4. 学习通的一些`免责条款`：总之，无责\n<div><img src=https://cdn.chuckle.top/images/13-8.webp width=\"40%\" height=\"40%\"></div>\n\n\n***\n","tags":["其它"],"categories":["其它"]},{"title":"记一次超声波避障小车比赛","url":"/article/81935dcb.html","content":"\n>去年第一次红外循迹比赛的时候我还没整博客，第二次便记录一下吧\n\n# 比赛简介\n学校机械院举办的智能小车比赛，一学期一次，上次是红外循迹，这次是超声波避障  \n小车是学院统一采购的，第一次去比赛时拿到的是散件，51单片机、电阻、其它芯片等，都得自己焊  \n\n***\n\n# 关于队伍\n一位机械院的同学在酷安私信我参不参加智能小车比赛，我那时还不认识他，但想着反正闲着也是闲着，参加点活动也好，便一拍即合，后面他又拉来了商学院的一位男同学和两位女同学  \n第一次比赛，我们也是唯一有商学院同学的队伍（其它队伍队均两机械两计科），不过我们队也是女同学最多的，Buff加满   \n\n队名我提议是秋名山车队，又是一拍即合  \n\n***\n\n# 关于比赛\n小车在上次比赛时就已搞好，所以这次重点在写个超声波避障程序烧进去  \n作为队里唯一的计科同学，这个程序当然得我搞了  \n但我倒也摸鱼，程序不难，测试过一次没毛病，剩下就是数值的微调（这就是我比赛前一天晚上才去调的原因么（误））\n\n***\n\n# 比赛过程\n过程简单，就是一遍一遍测试，然后改改数值，调调机制，然后队伍抽签轮流上，看谁跑的时间短  \n上午7个队（本来12个队，弃权了5个，新报名的队伍焊坏小车的不少），取前三进入下午复赛  \n\n***\n\n# 结果\n第一次的比赛我们第二，这次还是第二，属于万年老二了  \n上次有初赛复赛都有奖册，我拿了一本，这次只有复赛一本册子，给了队里一位女同学，争取以后人手一本  \n\n***\n\n# 一些图片\n<div><img src=https://cdn.chuckle.top/images/12-1.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/12-2.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/12-3.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/12-4.webp width=\"100%\" height=\"100%\"></div>\n\n***","tags":["Chuckle"],"categories":["Chuckle"]},{"title":"FakeLocation模拟校园跑教程","url":"/article/c5d354fd.html","content":"\n# 前言\n**本文未在任何平台出售，本站内容免费向互联网所有用户提供，分享本站文章时禁止商业性使用，如有发现倒卖行为欢迎向博主反馈**\n\n我们学校用的是运动世界校园，所以就用这个软件为例，其他软件差不多  \n博主测试设备：红米k40安卓11、红米6pro安卓9  \n>吐槽：这软件，什么都往里塞，天天更新加广告（一指禅干掉）  \n\n**2023-03-17**这学期校园跑软件换成小步点了，软件使用手册里明确指出root和xp框架:\n<img src=https://cdn.chuckle.top/images/11-5.webp width=\"45%\">\n\n问题不大，照样。\n<img src=https://cdn.chuckle.top/images/11-6.webp width=\"30%\">\n\n# 准备工作\n1、首先是有面具**Root**，而非小米官方等残废root  \n2、下载万恶之源：运动世界校园  \n3、下载安装[FakeLocation1.3.0.2版本](https://wwm.lanzoul.com/iMHUo057ibyb)  \n4、下载安装[隐藏应用列表xp模块](https://wwm.lanzoul.com/iQ6lq057irkd)我使用的版本1.6较老，但能稳定用我也没去升级  \n5、安装lsp/xp框架  \n6、下载安装[Godvip](https://wwm.lanzoul.com/i8RYM057ibzc)  \n\n***\n\n# 隐藏防检测\n\n## 运动世界校园权限设置\n确保权限设置与图一致，关闭miui的模糊定位  \n<div><img src=https://cdn.chuckle.top/images/11-1.webp width=\"75%\"></div>\n\n## 隐藏root\n面具本身随机包名安装  \n面具hide对运动世界校园全勾选（如果是24版本的面具，自行去酷安找shamiko模块隐藏root教程，我还没升到24，因为我用hide就能很好地隐藏root）  \n\n## 隐藏应用列表设置\n推荐先看酷安详细图文：[隐藏应用列表使用教程 Pro](https://www.coolapk.com/feed/34458057?shareKey=YjBlYzcxNDgwMzYwNjI4OGIzZmM~)  \n\n简单速通：  \n1、lsp/edxp启用**隐藏应用列表**  \n2、也许需要重启手机  \n3、点击模板管理，启用所有隐藏方式  \n4、选择要隐藏的应用，将FakeLocation、面具、lsp等搞机应用勾选  \n5、对运动校园应用模板  \n<div><img src=https://cdn.chuckle.top/images/11-2.webp width=\"100%\" height=\"100%\"></div>\n\n## 破解FakeLocation\nlsp启用Godvip，模块对FakeLocation起作用  \n\n## FakeLocation设置\n给FakeLocation软件Root权限  \nFakeLocation设置页只打开**模拟GPS信号**  \n<div><img src=https://cdn.chuckle.top/images/11-3.webp width=\"50%\" height=\"50%\"></div>\n\n## 如何模拟跑\n首先到一个较空旷，能接收到gps信号的地方（宿舍阳台、宿舍走廊），拿个椅子坐下，手机关闭wifi（可以开启蓝牙和数据）  \nFakeLocation选择**要模拟的位置**到跑道，当然具体在哪无所谓  \n打开运动软件，**待运动软件接收到gps信号**提示可以开始跑，返回FakeLocation软件，点击**启动模拟**（第一次打开需要等待一会，建议在模拟跑前先开关一次预热），并**打开摇杆**  \n\n摇杆设置：  \n摇杆里的**模拟gps信号**和**步频模拟**都得关掉，不能打开！不能打开！不能打开！   \n<div><img src=https://cdn.chuckle.top/images/11-4.webp width=\"100%\" height=\"100%\"></div>\n\n接着返回运动软件，你会发现显示的位置瞬移到了之前选择的模拟位置处，然后开始运动，要去哪就**用摇杆摇**到哪，步频可以使用其它软件模拟，但**建议抖手**  \n跑完后先结束运动，关闭运动软件，再停止位置模拟  \n\n***\n\n# 可能出现的问题\n1、当摇杆回到中间时（速度为0），运动软件会提示gps信号弱，这是正常现象  \n2、启动模拟后，运动软件上显示的位置没变：杀掉运动软件和FakeLocation，重新操作一次  \n3、启动模拟后，运动软件上显示的位置变了，但一开始运动位置就变回原来位置：杀掉运动软件和FakeLocation，重新操作一次  \n4、被检测到环境异常4：FakeLocation没隐藏好、运动软件检测到gps信号长期未变。请自查有无和教程操作不同的地方  \n\n# 温馨提示\n\n>如有问题可在评论区回复或在酷安找我\n>本教程虽然目前还可行，博主自用了两个学期也没被检测到一次，但安卓设备众多，系统繁杂，不确保教程的通用性\n>Root手机导致手机变砖、假跑被检测到影响体育成绩等后果，博主不承担任何责任\n\n***\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(3)","url":"/article/8636f786.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(2)](/article/9f2dc6c7.html)\n\n# Swing\n**Swing**是一个为Java设计的GUI工具包，是java的基础类（import javax.swing.*;）  \n在Swing中，所有我们在界面中看到的东西都是**部件**（组件）  \n\n其中容器是一种特殊的部件\n部件可以被放进容器中，当然容器也能放进容器中  \n\nSwing提供了一个底层容器类JFrame，即整个窗口    \n```java JFrame中常用的方法\n//创建一个无标题的窗口\nJFrame()\n//创建标题为s的窗口\nJFrame(String s)\n//设置窗口的初始位置是(a,b),即距屏幕左面a个像素，距屏幕上方b个像素，窗口的宽是width,高是height。\npublic void setBounds(int a,int b,int width,int height)\n//设置窗口的大小。\npublic void setSize(int width,int height)\n//设置窗口的位置，默认位置是(0,0)。\npublic void setLocation(int x,int y)\n//设置窗口是否可见，窗口默认是不可见的。\npublic void setVisible(boolean b)\n//设置窗口是否可调整大小，默认可调整大小。public voiddispose()撤销当前窗口，并释放当前窗口所使用的资源。\npublic void setResizable(boolean b)\n//撤销当前窗口，并释放当前窗口所使用的全部资源\npublic void dispose()\n//设置窗口的扩展状态\npublic void setExtendedState(int state)\n//其中参数state取JFrame类中的下列类常量:\nMAXIMIZED_HORIZ (水平方向最大化)，\nMAXIMIZED_VERT (垂直方向最大化)，\nMAXIMIZED_BOTH (水平、垂直方向都最大化)。\n//该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎样的处理，\npublic void setDefaultCloseOperation(int operation)\n//其中的参数operation取JFrame类中的下列int型static常量，程序根据参数operation取值做出不同的处理:\nDO_NOTHING_ON_CLOSE(什么也不做)，\nHIDE_ON_CLOSE (隐藏当前窗口)，\nDISPOSE_ON_CLOSE (隐藏当前窗口，并释放窗体占有的其他资源)，\nEXIT_ON_CLOSE (结束窗口所在的应用程序)\n```\n\n## add\n通过add把一个部件加到一个容器中  \n部件被加到容器后，就受这个容器所管理  \n容器管理部件的方式叫**布局管理器**  \nJFrame默认采用的布局管理器叫**BorderLayout**,默认把部件放到CENTER  \n```java\ntheView = new View(theField);//theView是一个容器\nJFrame frame = new JFrame();//创建一个底层容器\nframe.add(theView);//把theView容器加到底层容器中。默认为中间\nJButton btnstep =new JButton(\"单步\");//btnstep是一个按钮部件\nframe.add(btnstep, BorderLayout.SOUTH);//把btnstep部件加到底层容器中，且放到南边（窗口最下面）\n```\n\n## BorderLayout\nBorderLayout把整个容器划分为五个部分  \n<div><img src=https://cdn.chuckle.top/images/7-13.webp width=\"60%\" height=\"60%\"></div>\n\n后面放进去的部件会替换掉相同位置的部件（这就是为什么之前界面中只剩下一个按钮了）  \n当有部分没有部件时，其他部分会膨胀，将那个位置所占据  \n\nBorderLayout会根据部件里面的东西来帮我们计算，这个部件需要占据多大的空间 \n\n## 消息机制\n现在我们有了一个按下去没反应的按钮  \n如何让按钮按下去有反应？程序如何知道按钮被按下去了？  \n用户在图形界面做了一些操作，通过一些路径让程序知道，这个路径叫做**消息机制**  \n\nJava的Swing类实现了一个有意思的消息机制  \n```java\nJButton btnstep =new JButton(\"单步\");\nframe.add(btnstep, BorderLayout.SOUTH);\nbtnstep.addActionListener(new ActionListener(){\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tSystem.out.println(\"成功按下!\");\n\t}\n});\n```\n运行一下，当我们点击一次按钮，控制台都会输出一次“成功按下!”\n\n现在程序已经知道按钮被按下，且在上面的古怪代码中能成功做一些我们期望程序做的事（输出点东西）  \n我们可以把输出点东西换成其它事情，在狐狸和兔子中，step()函数控制单步  \n我们只需要做下面一些动作，就能让按钮控制单步  \n```java\nprivate JFrame frame;//把frame从FoxAndRabbit()中拿出来，让它变为FoxAndRabbit类中的成员变量\n···\n//JFrame frame = new JFrame();\nframe = new JFrame();\n···\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n···\n//fab.start(500);把main里的这句去掉，不让程序主动地开始\n``` \n现在每按一次按钮，程序就会运行一步  \n\n按钮自己有代码，知道自己被按下去了，但按钮作为一个早已经定好的类不可能有代码去调用step()\n但实际效果就是，每按一次按钮，step()就会被调用一次，这是怎么做到的？  \n<div><img src=https://cdn.chuckle.top/images/7-14.webp width=\"90%\" height=\"90%\"></div>\n\nJButton类提供了一个接口，只要实现了这个接口的类的对象，都可以通过**addActionListener()**方法**注册**给JButton，当按钮发现自己被按下去了，就会检查有没有东西注册在按钮那，接着找到重写的**actionPerformed()**，这样JButton就知道step()了  \n注册进去的东西，是运行时候一个动态的对象  \n\n这就是**反转控制**（Swing的消息机制）：\n·由按钮公布一个守听者接口和一对注册/注销函数  \n·你的代码实现那个接口，将守听者对象注册在按钮上  \n·一旦按钮被按下，就会反过来调用你的守听者对象的某个函数   \n\n## 内部类、匿名类\n刚刚实现接口的代码看起来十分奇怪\n```java\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n```\n可以换种写法\n```java\n//在类中新增这个类\nprivate class stepListener implements ActionListener {\n\t@Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n\t\tframe.repaint();\t\t\t\n\t}\n}\n···\n//原来的代码替换为这句\nbtnstep.addActionListener(new stepListener());\n```\n在一个类的内部，再定义一个类，这个类就叫**内部类**  \n内部类可以**直接访问**其所处类的**所有**成员  \njava的内部类也是类的成员  \n外部是函数时，只能访问那个函数里**final**的变量   \n\n用匿名类实现接口\n```java\nnew ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n}\n```\n在**new对象**的时候给出的**类的定义**形成了匿名类  \n匿名类可以**继承某类**，也可以**实现某接口**  \nSwingl的消息机制广泛使用匿名类  \n外部是函数时，只能访问那个函数里**final**的变量  \n\n为什么需要匿名类？\nSwing的消息机制决定了，每个部件发出的消息，都需要新的类去实现接口，然后去接收消息，当部件很多时，给每个类起名字非常麻烦   \n\n***\n\n# 一个课程表\n做一个课程表程序，它有8行7列，有表头表示7天，每个格子用户能自己编辑内容  \n效果是这样：  \n<div><img src=https://cdn.chuckle.top/images/7-15.webp width=\"60%\" height=\"60%\"></div>\n\n有前面Swing的基础，我们知道想要有一个窗口，需要用到JFrame类，来创建一个底层窗口  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n现在运行，只有一个空空的窗口，一个空空的容器，我们需要往里面放部件  \n想要一个表格，那就放一个表格进去  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n\t\tJTable table = new JTable());//声明一个表格\n        frame.add(table);//把表格放进去\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n运行一下，还是啥都没有，因为我们还没初始化表格，还没给表格它要的数据  \n\n用JTable类可以以表格的形式显示和编辑数据。  \nJTable类的对象并不存储数据，它只是数据的表现。  \nJTable实现了数据与表现的分离  \n\n新建一个KCBData类，作为表格的数据  \n让这个类实现一个叫TableModel的接口  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    @Override\n    public int getRowCount() {\n        return 0;\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 0;\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return false;\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n\n    }\n}\n```\nTableModel接口是由JTable提供给我们的  \nTableModel告诉我们，只要实现了它，就能作为数据交给JTable  \n\n完善一下KCBData  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    private String[] title = {\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"};//表格标题\n    private String[][] data = new String[8][7];//真正放7天8节课的数据结构\n    //这个data数组里面都是String类型的管理者，所以需要初始化每个管理者去管理一个String类型的空数据\n    public KCBData() {\n        //构造方法,初始化数据,每一行的数据都是空的,即没有数据,这样才能显示表格,否则会报错\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[i].length; j++) {\n                data[i][j] = \"\";//让每一个单元格都是空的\n            }\n        }\n    }\n    @Override\n    public int getRowCount() {\n        return 8;//表格有8行\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 7;//表格有7列\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return title[columnIndex];//返回一个表头\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return String.class;//告诉表格每列的数据类型,每一个都是String类型\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return true;//每个单元格都可以编辑\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return data[rowIndex][columnIndex];//将每一个单元格的数据返回，让表格拿到\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n        data[rowIndex][columnIndex] = (String) aValue;//将每一个单元格的数据设置为aValue,即用户输入的数据\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n        //添加监听器\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n        //移除监听器\n    }\n}\n\n```\n现在表格能拿到数据了，它知道该怎么画一个表格  \n但运行一下，还是没有表头  \n\n这是因为JTable组件显示数据时，如果直接将其放置在Frame的contentPane中则表头一行会显示不出来，如果将其放置在JScrollPane中显示数据的话，表头会自动显示出来。  \n暂时无需关心为什么  \n\n再完善下KCB类，一个课程表就完成了  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        JTable table = new JTable(new KCBData());//声明一个表格\n        JScrollPane pane = new JScrollPane(table);//声明一个滚动面板\n        frame.add(pane);//将滚动面板添加到窗口\n        frame.pack();//自动调整窗口大小\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭方式\n        frame.setVisible(true);//显示窗口\n    }\n\n}\n```\n\n## MVC设计模式\n刚刚的课程表结构是这样的  \n<div><img src=https://cdn.chuckle.top/images/7-16.webp width=\"85%\" height=\"85%\"></div>\n\n当JTable决定显示多少列时会调用getColumnCount，当它要显示表头时会调用getColumnName  \n程序运行过程中JTable反过来调用我们自己的KCBData里的方法  \n\n数据由我们自己实现了TableModel的对象来维护，JTable只管表现不管数据  \n\n**MVC**:数据、表现和控制三者分离，各负其责  \n·M=Model（模型)  \n·V=View(表现)  \n·C=Control(控制)  \n\n模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新  \n表现：从模型获得数据，根据数据画出表现  \n控制：从用户得到输入，根据输入调整数据  \n\n<div><img src=https://cdn.chuckle.top/images/7-17.webp width=\"85%\" height=\"85%\"></div>\n\n不是由接收到用户输入的代码去修改界面上的显示，而是去修改内部的数据，内部的数据去触发界面的更新  \n\n这样做的好处：每一部分都很单纯，尤其是View表现，只管拿到想要的数据去表现，至于数据是怎么更新，怎么生成的，它统统不管  \n\n在代码实现中，View和Control通常在同个表达界面的类中实现，因为表现和用户控制都是在界面中完成的，这和MVC并不矛盾，只是在具体实现MVC模式时的技巧  \n\n***\n\n# Exception异常\n异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。  \n比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。  \n\n写出下面的程序，idea的编辑器不会指出数组越界的错误，但运行程序控制台会抛出异常  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n}\n```\n\n```java 异常\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat ArrayIndex.main(ArrayIndex.java:4)\n```\n在main里面有Exception异常，问题出在在ArrayIndex的第四行，问题叫做ArrayIndexOutOfBoundsException，即数组越界  \n\n## 两种类型的异常与错误\n\n检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。  \n运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。  \n错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。  \n\n异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。  \n\n## 捕获异常\n当代码某一处可能出现问题、可能出现异常，就可以将这块代码放在一个用于捕捉异常的代码块中  \n```java\ntry\n{\n   // 可能出现异常的程序代码\n}catch(ExceptionName e1)//可以多个catch\n{\n   //处理异常的代码\n}catch(ExceptionName e2)\n{\n   //处理异常的代码\n}finally{\n  //无论是否发生异常，finally 代码块中的代码总会被执行。\n  // 程序代码\n}\n```\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。try/catch代码块中的代码称为保护代码  \n\nCatch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。  \n如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样.  \n\n将刚刚数组越界的代码用捕捉异常处理  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n        a[10] = 10;\n        System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n运行一下\n```java\nerror\n```\n\n异常是程序运行过程中可能出现的问题，现在这个代码是一定会出错的，我们改造一下  \n```java\nimport java.util.Scanner;\n\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        int idx = 0;\n        Scanner in = new Scanner(System.in);\n        idx = in.nextInt();\n        try{\n            a[idx] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n\n```java 输出\n输入：2\nhello\n输入：12\nerror\n```\n\n## 异常处理机制\n把可能发出异常的代码放到try里，在try后面用catch去匹配可能出现的异常类型。  \n当try里的代码没有异常，catch里的代码不会被运行，当try里的代码出现异常，try里后续的代码都不会被执行，会直接调到catch里，在catch里处理完异常，会继续往下运行整个程序，而不会回到try。   \n当匹配到一个catch之后，异常就已经被处理完了，不会再去匹配另一个异常。  \n\n运行下面的代码  \n```java\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n    public static void main(String[] args) {\n        try{\n            f();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n当给数组赋值出现异常后，f方法后面的代码都不会被执行，然后回到调用f方法的地方，try会捕捉到f方法的异常，然后传递给catch  \n\n当有异常被抛出时，可以遵循下面的图来判断该在哪个地方处理这个异常  \n<div><img src=https://cdn.chuckle.top/images/7-18.webp width=\"92%\" height=\"92%\"></div>\n\n```java 示例\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;//抛出ArrayIndexOutOfBoundsException异常\n        System.out.println(\"hello\");//异常后面的代码不会被执行\n    }\n\n    public static void g(){\n        f();//f方法抛出异常，异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void h(){\n        int i = 10;\n        if(i < 100){\n            g();//所处不是函数，跳出一层\n        }//异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void k(){\n        try{\n            h();//有try捕捉异常\n        }catch(NullPointerException e){//没有对应catch匹配，退出到外层\n            System.out.println(\"k error\");\n        }//所处是函数\n        //返回调用者\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();//有try捕捉异常\n        }catch(ArrayIndexOutOfBoundsException e){//有对应catch匹配\n            System.out.println(\"error\");//处理异常\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n\n## Java 内置异常类\n\n| 异常  | 描述    |\n| -----    | ------ |\n| ArithmeticException  |当出现异常的运算条件时，抛出此异常。例如，一个整数\"除以零\"时，抛出此类的一个实例|\n|ArrayIndexOutOfBoundsException|用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引|\n|ArrayStoreException|试图将错误类型的对象存储到一个对象数组时抛出的异常|\n|ClassCastException|当试图将对象强制转换为不是实例的子类时，抛出该异常|\n|IllegalArgumentException|抛出的异常表明向方法传递了一个不合法或不正确的参数|\n|IllegalMonitorStateException|抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程|\n|IllegalStateException|在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下|\n|IllegalThreadStateException|线程没有处于请求操作所要求的适当状态时抛出的异常|\n|IndexOutOfBoundsException|指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出|\n|NegativeArraySizeException|如果应用程序试图创建大小为负的数组，则抛出该异常|\n|NullPointerException|当应用程序试图在需要对象的地方使用 null 时，抛出该异常|\n|NumberFormatException\t|当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常|\n|SecurityException|由安全管理器抛出的异常，指示存在安全侵犯|\n|StringIndexOutOfBoundsException|此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小|\n|UnsupportedOperationException|当不支持请求的操作时，抛出该异常|\n|下面是Java 定义在 java.lang 包中的检查性异常类：||\n|ClassNotFoundException|应用程序试图加载类时，找不到相应的类，抛出该异常|\n|CloneNotSupportedException|当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常|\n|IllegalAccessException|拒绝访问一个类的时候，抛出该异常|\n|InstantiationException|当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常|\n|InterruptedException|一个线程被另一个线程中断，抛出该异常|\n|NoSuchFieldException|请求的变量不存在|\n|NoSuchMethodException|\t请求的方法不存在|\n\n## 异常方法\n当catch匹配到了异常，实际上是拿到了一个异常类型的对象，我们可以让对象做事情  \n```java\npublic class a {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n            a[10] = 20;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n            System.out.println(e.getMessage());\n            System.out.println();\n            System.out.println(e);\n            System.out.println();\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nerror\nIndex 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat a.main(a.java:5)\n\n```\n\n| 异常方法  | 描述    |\n| -----    | ------ |\n|String getMessage()|返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了|\n|Throwable getCause()|返回一个 Throwable 对象代表异常原因|\n|String toString()|返回此 Throwable 的简短描述|\n|void printStackTrace()|将此 Throwable 及其回溯打印到标准错误流|\n|StackTraceElement [] getStackTrace()|返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底|\n|Throwable fillInStackTrace()|用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中|\n\n## throw再度抛出\n当一个异常已经被处理了，将不会再次被捕捉  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){//k中已经处理了异常\n            System.out.println(\"k error\");\n        }\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){//不会再次处理\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nmain\n```\n但可以通过throw主动地再次抛出这个异常  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"k error\");\n            throw e;//捕捉到后在此抛出该异常\n        }\n    }\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nerror\nmain\n```\n\n## 为什么要异常机制\n我们希望程序能够根据运行过程中可能出现的各种情况进行处理  \n早期，函数都有特定的返回值，通过函数内很多的if-else来判断返回什么，以返回值来做相应处理  \n\n函数内出现很多与功能无关的if-else，会导致函数可读性很差，而且不利于增加新的功能  \n异常机制将业务逻辑与异常处理在代码上分开  \n```java\ntry{\n    //业务逻辑都放在一起\n    open the file;\n    determine its size;\n    allocate that much memory;\n    read the file into memory;\n    close the file;\n    //如果上面的业务逻辑出了问题，就用下面的catch去处理对应的问题\n}catch(fileOpenFailed){\n    doSomething;\n}catch(sizeDeterminationFailed){\n    doSomething;\n}catch(memoryAllocationFailed ){\n    doSomething;\n}catch(readFailed ){\n    doSomething;\n}catch(fileCloseFailed ){\n    doSomething;\n}\n```\n异常机制最大的好处就是清晰地分开了正常的业务逻辑代码和遇到情况时的处理代码  \n\n## 异常的抛出和声明\n在Java中可以自定义异常。  \n1、所有异常都必须是 Throwable 的子类。  \n2、如果希望写一个检查性异常类，则需要继承 Exception 类。  \n3、如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。  \nRuntimeException继承自Exception  \n\n```java 声明一个异常类型\nclass MyException extends Exception{\n}\n```\n```java 声明一个可能会抛出异常的方法\npublic void f() throws MyException{\n    throw new MyException();//抛出一个MyException异常\n}\n```\n所有调用这个方法的地方都必须套上try-catch，来处理可能发生的异常  \n```java\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"error\");\n    }\n}\n```\n\n可以声明并不会真的抛出的异常,但调用该方法的地方必须处理全部可能抛出的异常  \n```java\npublic void f() throws MyException,YouException{\n    throw new MyException();//抛出一个MyException异常\n}\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"MyError\");\n    }catch(YouException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"YouError\");\n    }\n}\n```\n\n任何继承了Throwable类的对象都可以被throw  \nException类继承了Throwable，我们通常让自定义的异常类从Exception类得到继承  \n\n```java Exception类的两种构造\n//我们在自定义异常类时也通常会有这两种构造\nthrow new Exception();  \nthrow new Exception(\"HELP\");//可以用这个字符串来表达一些东西  \n```\n\n## catch的匹配机制\n抛出子类的异常会被捕捉父类异常的catch给捉到  \n```java\n//声明两个异常类，YouException继承自MyException\nclass MyException extends Exception{}\nclass YouException extends MyException{}\n\npublic class Test{\n\n    public static void f() throws MyException, YouException {\n        throw new YouException();//抛出一个YouException异常\n    }\n\n    public static void main(String[] args) {\n        try{\n            throw new YouException();\n        }catch(MyException e){//MyException匹配到了它的子类YouException\n            System.out.println(\"YouException\");\n        }\n    }\n}\n```\n如果同时捕捉父类子类两个异常，子类catch要写在父类前面，否则会报错  \n```java\ntry{\n    throw new YouException();\n}catch(YouException e){\n    System.out.println(\"YouException\");\n}catch(MyException e){\n    System.out.println(\"YouException\");\n}\n```\n\n捕捉任何异常\n```java\ncatch(Exception e){\n}\n```\n\n### 运行时刻异常\n像ArrayIndexOutOfBoundsException这样java本身提供的异常是不需要声明的，如果需要去声明这些异常，那么每个方法都将带上一长串的声明    \n但是如果没有适当的机制来捕捉，就会最终导致程序终止  \n\n## 异常遇到继承\n当覆盖一个方法的时候，子类不能声明抛出比父类的版本更多的异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public static void f() throws MyException {}\n    public static void main(String[] args) {}\n}\nclass NewClass extends Test{\n    //NewClass'中的f()'与' Test'中的'f()'冲突；重写的方法未抛出NewException'\n    public void f() throws NewException {}\n    //正确的\n    public void f() throws YouException {}\n    public void f() throws MyException {} \n    public void f() {} \n}\n```\n\n在子类的构造方法中，必须声明父类可能抛出的全部异常，可以抛出更多异常,可以是父类抛出异常的父类异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public Test() throws YouException{}\n    public static void main(String[] args) {}\n}\n\nclass NewClass extends Test {\n    //允许\n    public NewClass() throws YouException{}\n    public NewClass() throws MyException{}\n    public NewClass() throws MyException,NewException{}\n    //不允许\n    public NewClass(){}\n    public NewClass() throws NewException{}\n}\n```\n\n***\n\n# Stream流\n任何程序都有输入输出，会向用户那读点东西，也会向用户那输出点东西  \n所以，任何一个编程语言都给程序员提供了输入输出的方式，让这个程序可以和外界打交道  \n\n对于java语言，以及之后的新语言，处理输入输出的手段叫做**流**  \n\n流是一个抽象、动态的概念，是一连串连续动态的数据集合。  \n流给数据源和程序之间提供了数据信息传输的通道，编程语言提供了多种流用于数据传输  \n\n## Hallo World\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"Hello World!\");\n    }\n}\n```\n这个程序就用到了输出流，把Hallo World输出给用户看  \n**System**是一个类，**out**是这个类的一个静态成员，**println**是这个成员能做的事情  \n实际上，**out**这个成员就是用于做输出的流  \n\n## 流的基础\n在java的基础类库中，所有的输出都基于**OutputStream**类，所有的输入都基于**InputStream**类，这两个类构成了输入和输出的基础  \n\n但这两个类是抽象的，具体使用时应该用它们的子类  \n在这里可以看到java系统类库中所有的包[Java®平台、标准版和Java开发工具包第18版API规范](https://docs.oracle.com/en/java/javase/18/docs/api/index.html)  \n在其中的java.base中有[java.io](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/package-summary.html)，这里面有java输入输出所有相关的东西  \n在里面可以找到**InputStream**和**OutputStream**类，当然这里面还有很多的类，以及其它的东西  \n\n点击InputStream，可以看到这个类的描述，以及它所有的方法  \n<div><img src=https://cdn.chuckle.top/images/7-19.webp width=\"100%\" height=\"100%\"></div>\n\n**InputStream**把外界的输入当做**字节**的流来看待，**OutputStream**也同理，当我们使用这两个类，只能做字节层面上的读和写  \n\n尝试一下：  \n```java\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n        byte[] buffer = new byte[1024];//一个1k字节的butter\n        int len = 0;//让系统读取输入流，并将读取到的内容存储到buffer中，返回读取到的字节数\n        try {//所有io的操作都存在风险，所以要捕获异常\n            len = System.in.read(buffer);\n            String s = new String(buffer, 0, len);//将buffer中从0开始到len的这么多个字节构造一个字符串\n            System.out.println(\"读到了：\"+len+\"字节\");//输出读取到的字节数\n            System.out.println(s);//输出字符串\n            System.out.println(\"s的长度：\"+s.length());//输出字符串有多少个字符\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nHello World!\n输入:123abc\n读到了：7字节\n123abc\n\ns的长度：7\n\n```\n123abc是6个字节，但后面还有个回车，所以读到7个字节，且输出s时，把回车也输出了  \n\n换个输入：\n```java 输出\nHello World!\n输入：123汉字abc\n读到了：13字节\n123汉字abc\n\ns的长度：9\n\n```\n在UTF-8编码中,一个中文字符等于三个字节，所以一共读到13个字节  \n\n## 文件流\n**System.in**和**System.in**是标准输入和标准输出的流  \n如果想要直接写文件，就需要使用到**文件流**：**FileInputStream**、**FileOutputStream**  \n\n实际工程中已经较少直接对文件进行读写（除了在造轮子）  \n更常用的是以在内存数据或通信数据上建立的流，如数据库的二进制数据读写或网络端口通信  \n具体的文件读写往往有更专业的类，比如配置文件和日志文件  \n\n尝试一下**FileOutputStream**：  \n```java\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            FileOutputStream out = new FileOutputStream(\"a.dat\");//如果文件不存在，则创建，存在则覆盖\n            out.write(buf);//将buf中的数据写入文件\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n用**Hexdump**打开这个16进制文件  \n```\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: 00 01 02 03 04 05 06 07 08 09                      ..........\n\n```\n1到9都已经被写入  \n\n## 流过滤器\n无论是System.in和out还是文件流，都只能处理单个字节，一个个字节地读，一个个字节地写  \n如果要把一个10进制地整数写入到一个文件中，就要同时读写4个字节，显然前面介绍的流无法做到  \n\n**流过滤器**可以在已存在的流的基础上，去增加一层层的过滤器，每一层的过滤器都可以做点事情，其中一些过滤器就可以做int、double这些基础类型数据的读和写  \n\n尝试一下：  \n```java\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            DataOutputStream out = new DataOutputStream(\n                    new BufferedOutputStream(//缓冲输出流\n                            new FileOutputStream(\"a.dat\")));\n            //打开这个文件之后，在上面接了一个缓冲流，缓冲流外面还有一个流，最终得到的是一个DataOutputStream的对象\n            //我们可以往DataOutputStream这个流里面写入数据，数据会被缓冲到缓冲流里面，缓冲流里面的数据会被写入到文件里面\n            int i = 0xcafebabe;\n            out.writeInt(i);//写入一个int类型的数据,DataOutputStream流的writeInt方法可以写入一个int类型的数据\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: CA FE BA BE                                        J~:>\n```\n0xcafebabe这个16进制数已经被写入  \n```java 输出\nHello World!\n-889275714\n```\n0xcafebabe这个16进制的数对应的10进制数是-889275714  \n\n每一层过滤器都可以起到一定的作用，在上面的程序中，BufferedOutputStream起到了缓冲垫作用，DataOutputStream起到了读写基本数据类型的作用  \n\n## 文本的输入和输出\n加上了DataOutputStream也只能以二进制处理基本数据类型，如何处理文本？  \n\n二进制数据采用InputStream/OutputStream  \n文本数据采用Reader/Writer  \n\n但Reader/Writer本身是处理Unicode编码的字符的，如果文件是Unicode编码，可以直接用Reader/Writer处理文件，但一般情况下，文件本身并不是Unicode编码，它可能是GBK，可能是UTF-8  \n在这种情况下，我们需要借助Stream，用字节形式打开文件，再在Stream流的基础上，用过滤器的方式去建立Reader/Writer ，来做文本的输入和输出，**StreamReader**可以将字节流转换为字符流，然后交给Reader/Writer，当然中间可以加上Buffered实现缓冲  \n\n尝试一下：  \n```java\nimport java.io.*;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            PrintWriter out = new PrintWriter(//创建一个输出流,PrintWriter可以通过连接BufferedWriter实现的缓冲功能\n                    new BufferedWriter(//创建一个缓冲流\n                            new OutputStreamWriter(//将字节流转换为字符流\n                                new FileOutputStream(\"a.txt\"))));//创建一个文件输出流\n            //我们做了一个文件流，但它只能处理字节\n            // 在此基础上再做一个桥梁：OutputStreamWriter\n            // 它构建起了Stream和Writer的桥梁，它的输入是OutputStream，输出是Writer\n            int i = 123456;\n            out.println(i);//在PrintWriter的基础上，我们可以用println方法来输出数据\n            out.close();\n            //和上面输出一样，如果要读取一个文件，我们需要做一个桥梁：InputStreamReader\n            //它构建起了Stream和Reader的桥梁，它的输入是InputStream，输出是Reader\n            BufferedReader in = new BufferedReader(// BufferedReader类从字符输入流中读取文本并缓冲字符\n                    new InputStreamReader(//将字节流转换为字符流\n                        new FileInputStream(\"src/test.java\")));//创建一个文件输入流，打开这个程序的源码文件\n            //readLine()方法从字符输入流中读取一行，并返回该行。\n            String line;\n            while ((line = in.readLine()) != null){//当读取到的行不为空时，执行循环，就可以读取整个文件\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n运行：在a.tet文件中有123456字符,控制台也将这整个源码输出了出来  \n\n除了BufferedReader，还有LineNumberReader，里面的getLineNumber()可以读取指定的行  \n\n**FileReader**是InputStreamReader类的子类，所有方法都从父类中继承而来，它可以直接读取一个二进制文件，建立起一个流，然后形成一个Reader    \nFileReader(File file)在给定从中读取数据的Fe的情况下创建一个新FileReader  \nFileReader(String fileName)在给定从中读取数据的文件名的情况下创建一个新FileReader  \nFileReader不能指定编码转换方式  \n\n## 汉字编码问题\nFileOutputStream(\"a.txt\")可以以二进制形式打开一个文件  \nOutputStreamWriter(FileOutputStream(\"a.txt\"))将字节流转换为字符流,如果不指定编码，那么它优先使用程序源码文件的编码去转换这个字节流为字符流，这就很容易导致汉字乱码  \n\n我们可以指定编码进行转换OutputStreamWriter(FileOutputStream(\"a.txt\"),\"utf8\")  \n用utf8去将这个字节流转换成字符流 \n\n当然还有其它方法，这里不展开讲\n\n## 格式化输入输出\n格式化输出：使用printf(\"格式\", );用法和C语言的基本一样，这里不展开讲，博主同样有篇C语言学习笔记  \n\n格式化输入：如果想从一个文本中读取出一些数字，可以在流上构建一个Scanner，然后用next系列的方法去读取数字、单词等等  \n\n## Stream/Reader/Scanner的选择\n<div><img src=https://cdn.chuckle.top/images/7-20.webp width=\"92%\" height=\"92%\"></div>\n\n## 流的应用\n现在已经很少有程序需要用流的方式去打开一个文件，裸地去进行文件读和写的操作，更多地是从某个地方得到了一个流  \n\n### 服务器通信\n下面这个程序将从本地服务器得到一个流，并向这个流写入东西  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n当然，直接运行这个程序一定报错，因为本地没有任何服务器程序在12345端口上听着，连接建立不起来  \n\n使用netcat可以实现监听  \n从[netcat](https://eternallybored.org/misc/netcat/)下载netcat1.12  \n解压后把nc.exe移动到C:\\Windows\\System32目录，压缩包内其它东西用不上  \n然后打开cmd，运行nc -l -p -12345\n\n现在再运行程序，cmd窗口就会输出Hello, world!  \n\n还可以接收服务端的数据  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.flush();//刷新缓冲区，将缓冲区中的数据立即发送出去\n            BufferedReader in = new BufferedReader(\n                    new InputStreamReader(\n                            //getInputStream()方法获取Socket对象的输入流，并构造一个BufferedReader对象\n                            socket.getInputStream()));//创建一个BufferedReader对象，用于接收服务器端的信息\n            String line = in.readLine();//读取服务器端的一行文本\n            System.out.println(line);//输出读取的文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n在cmd窗口输入任意文本，idea的控制台也会输出这个文本  \n\n### 对象串行化\n写入和读取一个对象，使用ObjectOutputStream和ObjectInputStream，被读写的类要实现Serializable接口  \n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.Serializable;\nimport java.io.*;\n\nclass Student implements Serializable {//可以串行化的类\n    private String name;\n    private int age;\n    private int grade;\n\n    public Student(String name, int age, int grade) {\n        this.name = name;\n        this.age = age;\n        this.grade = grade;\n    }\n\n    public String toString() {\n        return \"Student: \" + name + \" \" + age+ \" \" + grade;\n    }\n}\n\npublic class chh {\n    public static void main(String[] args) {\n        try {\n            Student s1 = new Student(\"zhangsan\", 20, 1);\n            ObjectOutputStream out = new ObjectOutputStream(\n                    new FileOutputStream(\"obj.dat\"));\n            out.writeObject(s1);\n            out.close();\n            ObjectInputStream in = new ObjectInputStream(\n                    new FileInputStream(\"obj.dat\"));\n            Student s2 = (Student) in.readObject();\n            System.out.println(s2);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java obj.bat\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: AC ED 00 05 73 72 00 07 53 74 75 64 65 6E 74 98    ,m..sr..Student.\n00000010: 61 28 66 C5 BE 55 BC 02 00 03 49 00 03 61 67 65    a(fE>U<...I..age\n00000020: 49 00 05 67 72 61 64 65 4C 00 04 6E 61 6D 65 74    I..gradeL..namet\n00000030: 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72    ..Ljava/lang/Str\n00000040: 69 6E 67 3B 78 70 00 00 00 14 00 00 00 01 74 00    ing;xp........t.\n00000050: 08 7A 68 61 6E 67 73 61 6E                         .zhangsan\n\n```\n```java 输出\nStudent: zhangsan 20 1\n```\n\n***\n\n>完结撒花！\n>javase的学习暂且告一段落，但学习的步伐永不停歇\n>翁恺老师讲的课循序渐进，简洁明了，好评，但课程上只学到流，刚步入javase的高级部分\n>后面还有一个重要部分：线程\n>过段时间实操一个java的管理系统（万物起源管理系统），暂且咕咕咕吧\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"给Butterfly加上顶部加载条","url":"/article/13d6481a.html","content":"\n>效果已在本站实装，切换页面顶部有加载进度条\n>参考文章[为Hexo博客添加顶部加载条](https://cloud.tencent.com/developer/article/1960734)\n\n# 旧版顶部长条\n\n## 引入css\n```css\n.pace {\n  -webkit-pointer-events: none;\n  pointer-events: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n\n.pace-inactive {\n  display: none;\n}\n\n.pace .pace-progress {\n  background: #e90f92;\n  position: fixed;\n  z-index: 2000;\n  top: 0;\n  right: 100%;\n  width: 100%;\n  height: 2px;\n}\n\n.pace .pace-progress-inner {\n  display: block;\n  position: absolute;\n  right: 0px;\n  width: 100px;\n  height: 100%;\n  box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92;\n  opacity: 1.0;\n  -webkit-transform: rotate(3deg) translate(0px, -4px);\n  -moz-transform: rotate(3deg) translate(0px, -4px);\n  -ms-transform: rotate(3deg) translate(0px, -4px);\n  -o-transform: rotate(3deg) translate(0px, -4px);\n  transform: rotate(3deg) translate(0px, -4px);\n}\n\n.pace .pace-activity {\n  display: block;\n  position: fixed;\n  z-index: 2000;\n  top: 15px;\n  right: 15px;\n  width: 14px;\n  height: 14px;\n  border: solid 2px transparent;\n  border-top-color: #e90f92;\n  border-left-color: #e90f92;\n  border-radius: 10px;\n  -webkit-animation: pace-spinner 400ms linear infinite;\n  -moz-animation: pace-spinner 400ms linear infinite;\n  -ms-animation: pace-spinner 400ms linear infinite;\n  -o-animation: pace-spinner 400ms linear infinite;\n  animation: pace-spinner 400ms linear infinite;\n}\n\n@-webkit-keyframes pace-spinner {\n  0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-moz-keyframes pace-spinner {\n  0% { -moz-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -moz-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-o-keyframes pace-spinner {\n  0% { -o-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -o-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-ms-keyframes pace-spinner {\n  0% { -ms-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -ms-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@keyframes pace-spinner {\n  0% { transform: rotate(0deg); transform: rotate(0deg); }\n  100% { transform: rotate(360deg); transform: rotate(360deg); }\n}\n/* 在下面修改进度条外观 */\n.pace .pace-progress {\n  background: #1ef4fbec; /*进度条颜色*/\n  height: 3px;/* 进度条厚度 */\n}\n.pace .pace-progress-inner {\n  box-shadow: 0 0 10px #1ef4fbce, 0 0 5px #1ecffbd0; /*阴影颜色*/\n}\n.pace .pace-activity {\n  border-top-color: #1edafbe5;\t/*上边框颜色*/\n  border-left-color: #1ef4fbec;\t/*左边框颜色*/\n}\n```\n\n## 引入js\n\n```js\n<script src=\"//cdn.bootcss.com/pace/1.0.2/pace.min.js\"></script>\n```\n\n**然后三连即可**\n\n***\n\n# 新版胶囊\n<img src=https://cdn.chuckle.top/images/10-1.webp width=\"50%\" height=\"50%\">\n\n&emsp;&emsp;看这个文章即可，虽然实现过程不太一样，但效果差不多：[为你的Butterfly添加顶部加载进度条](https://xlenco.eu.org/posts/769f.html)\n\n***\n\n\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"基于UptimeRobot的监控面板","url":"/article/8f1fedc5.html","content":"\n>演示：[轻笑的网站监控面板](https://status.chuckle.top/)\n\n# 注册UptimeRobot\n\n填写邮箱以完成注册  \n>[跳转至注册](https://uptimerobot.com/signUp?ref=website-header)\n\n\n# 新建监视器\n点击左上角Add New Monitor  \n<div><img src=https://cdn.chuckle.top/images/9-1.webp width=\"70%\" height=\"70%\"></div>\n\n在弹出窗口填写需要需要监控的站点的相关信息  \n\n<div><img src=https://cdn.chuckle.top/images/9-2.webp width=\"70%\" height=\"70%\"></div>\n\n点击Create Monitor完成创建   \n\n\n# 创建API密钥\n\n点击My Settings\n<div><img src=https://cdn.chuckle.top/images/9-3.webp width=\"70%\" height=\"70%\"></div>\n为监视器创建一个api密钥（也可选择第三个，为所有监视器创建一个密钥）  \n<div><img src=https://cdn.chuckle.top/images/9-4.webp width=\"70%\" height=\"70%\"></div>\n\n# fork监控面板仓库\n选择其中一个fork  \n[yb/uptime-status](https://github.com/yb/uptime-status)  \n[Ice-Hazymoon/status](https://github.com/Ice-Hazymoon/status)  \n\n# 修改config.js\n\n进入刚fork的仓库，打开/public/config.js  \n添加监视器的api密钥  \n>需要监控的站点较多，也可为所有监控器创建一个api密钥填入\n\n```\n ApiKeys: [\n    '在这里粘贴api密钥',\n  ],\n```\n>还可以选择在ApiDomain修改自定义反代域名，详见https://github.com/yb/uptime-status/\n\n# vercel部署\n\n新建一个项目  \nimport监控面板仓库  \n等待几分钟创建完成，点击vist，一个监控面板就完成了  \n<div><img src=https://cdn.chuckle.top/images/9-5.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/9-6.webp width=\"70%\" height=\"70%\"></div>\n\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(2)","url":"/article/9f2dc6c7.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(1)](/article/bfb663c6.html)\n\n# 城堡游戏（可扩展性）\n整体思路：用Room先初始化5个房间，Room类中有房间名称、四个方向所连接的房间，currentRoom = outside;设置出生点  \n进入goRoom方法，匹配用户输入的方向，让nextroom指向下一个房间，然后让currentRoom = outside;并输出房间信息。  \n大致以此循环  \n \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    public String description;\n    //房间四个方向连接的房间\n    public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = null;//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n```java 输出\n欢迎来到城堡!\n这是一个超级无聊的游戏。\n如果需要帮助，请输入'help'\n\n你在城堡外\n出口有：\neast\nsouth\nwest\n\ngo south\n你在书房\n出口有：\nnorth\neast\n\ngo east\n你在卧室\n出口有：\nwest\n\nhelp\n迷路了吗？你可以做的命令有：go bye help\n如：\tgo east\nbye\n感谢您的光临。再见！\n```\n\n## 消除代码复制\n在printWelcome和goRoom方法中都有一段相同的输出出口方向的代码  \n将这段代码提取出来，做成一个方法，在需要输出房间信息的地方调用即可  \n```java\npublic void showPrompt()\n{\n    // 输出当前房间的描述\n    System.out.println(\"你在\"+ currentRoom);\n    System.out.println(\"出口有：\");\n    if(currentRoom.northExit != null)\n        System.out.println(\"north\");\n    if(currentRoom.eastExit != null)\n        System.out.println(\"east\");\n    if(currentRoom.southExit != null)\n        System.out.println(\"south\");\n    if(currentRoom.westExit != null)\n        System.out.println(\"west\");\n    System.out.println();\n}\n\n```\n\n## 封装\n这个程序没有bug，能正常运行，但不见得是一个好的代码  \n评价一个代码质量的好坏是多元的，尤其是这个代码是否能适应将来的需要  \n\n**可扩展性**：代码是否易于将来增加新的东西\n\n我们想在这个游戏里给每个房间增加两个方向down和up  \n我们需要改的地方很多  \nRoom.java里需要增加两个房间对象public Room downExit;和public Room upExit; setExits方法需要增加两个参数并进行判断  \nGame.java里很多方法也要增加if判断，还要改每个房间的初始化  \n\n总之，想增加一个方向，代码几乎每个地方都要改变  \n\n要想增加可扩展性，首先要降低类和类之间的耦合  \n\n### 用封装来降低耦合\nRoom类和Game类都有大量的代码和出口相关  \n尤其是Game类中大量使用了Room类的成员变量  \n类和类之间的关系称作**耦合**  \n耦合**越低越好**，保持距离是形成良好代码的关键  \n\n我们可以让Room自己告诉Game有哪些出口，出口连接的房间  \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    private String description;\n    //public String description;\n    //房间四个方向连接的房间\n    private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;\n    /*public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;*/\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        /*String returnString = \"Exits:\";\n        if (northExit != null)\n            returnString += \"north \";\n        if (eastExit != null)\n            returnString += \"east \";\n        if (southExit != null)\n            returnString += \"south \";\n        if (westExit != null)\n            returnString += \"west \";\n        return returnString;*/\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n        /*System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();*/\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        /*if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }*/\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n            /*System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();*/\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n        /*System.out.println(\"出口有：\");\n        if(currentRoom.northExit != null)\n            System.out.println(\"north\");\n        if(currentRoom.eastExit != null)\n            System.out.println(\"east\");\n        if(currentRoom.southExit != null)\n            System.out.println(\"south\");\n        if(currentRoom.westExit != null)\n            System.out.println(\"west\");\n        System.out.println();*/\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n\n### 用接口来实现聚合\n原本Room有什么出口，连接着什么房间，Game是能直接获取使用的  \n现在我们在Room中实现了两个接口getExitDesc和getExit,把方向的细节彻底隐藏在Room类内部  \n今后方向如何实现就和外部无关了  \n\n### 用容器来实现灵活性\n在Room当中，有四个Room对象，用于保存这个房间连接着的四个房间（null，或者房间名）  \n这种一一对应的关系，可以使用HashMap去实现  \n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n    /*private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;*/\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    /*public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }*/\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        /*if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");*/\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n        /*if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;*/\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        /*outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);*/\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n//现在当我们想增加出口方向，很简单  \nlobby.setExits(\"up\", pub);  \npub.setExits(\"down\", lobby);  \n\n这里发生了什么？  \n将lobby的出口方向和对应房间传给它的setExits的方法后  \nlobby里面的容器就会多一对出口和房间的对应关系  \nlobby里面的getExitDesc、getExit方法以及未来可能加入的新方法，都遍历这个容器  \n所以，增加出口和连接的房间，只需要调用setExits方法，去往lobby里的容器写入东西即可  \n\n现在，对于增加出口来说，已经具有了可扩展性\n\n### 以框架+数据来提高可扩展性\n我们原来用硬编码去保存room的出口  \n现在我们用容器，HashMap和对应的方法（接口方法）组成了一个框架，数据就是放在HashMap里的东西  \n在这个框架中要增加出口很容易  \n\n启发：  \n命令的解析是否可以脱离if-else  \n定义一个Handler来处理命令  \n用Hash表来保存命令和Handler之间的关系  \n\n现在我们可以用相同的思路去解决用户命令（help，go，bye）的硬编码问题  \n一个字符串对应调用一个方法，这显然也是一一对应的关系  \n但容器**只能放对象**，一个方法不能放进容器中  \n\n### 如何把方法放进容器中\n创建一个Handler类，然后把每个命令创建为Handler的子类  \n将命令字符串和Handler子类的对象一一对应放入HashMap中  \n将功能在Handler的子类的doCmd方法中实现  \n在game中通过父类对象管理者去管理子类对象（从HashMap中获取子类对象），管理者调用doCmd方法即可  \n\n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n    //创建一个HashMap对象，用于保存所有的命令处理器\n    private HashMap<String, Handler> handlers = new HashMap<String, Handler>();\n\n    public Game()//构造函数\n    {\n        //将字符串和命令处理器对应\n        handlers.put(\"go\",new HandlerGo(this));//把game对象作为参数传入HandlerGo类，让HandlerGo能管理game\n        handlers.put(\"help\",new HandlerHelp(this));\n        handlers.put(\"bye\",new HandlerBye(this));\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    /*private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }*/\n\n    public void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public void play(){//游戏开始\n        Scanner in = new Scanner(System.in);\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            Handler handler = handlers.get(words[0]);//获取用户输入的命令,从HashMap中获取对应的子类对象,让handler管理这个对象\n            String value = \"\";//保存命令的字符串\n            if(words.length > 1)//判断是不是bye命令\n            {\n                value = words[1];//获取参数\n            }\n            if(handler != null){//如果命令存在\n                handler.doCmd(value);//调用命令处理器\n                if ( handler.isBye() ) {//如果命令处理器返回true，则退出游戏\n                    System.out.println(\"感谢您的光临。再见！\");\n                    break;\n                }\n            }\n        }\n        in.close();//关闭Scanner\n    }\n\n    public static void main(String[] args) {\n        /*Scanner in = new Scanner(System.in);*/\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n        game.play();\n        /*while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }*/\n        //System.out.println(\"感谢您的光临。再见！\");\n        //in.close();//关闭Scanner\n    }\n}\n```\n```java Handler.java\npackage castle;\n\npublic class Handler {\n    protected Game game;//创建一个Game对象的管理者，为了方便设为protected\n    public Handler(Game game) {\n        this.game = game;//两个game管理者管理同一个Game对象\n    }\n\n    public void doCmd(String word) {}//一个接口，用于运行命令\n    public boolean isBye() { return false; }\n}\n```\n```java HandlerBye.java\npackage castle;\n\npublic class HandlerBye  extends Handler {\n    //必要的构造器\n    public HandlerBye(Game game) {\n        super(game);\n    }\n    @Override\n    public boolean isBye() {\n        return true;\n    }\n}\n```\n```java HandlerHelp.java\npackage castle;\n\npublic class HandlerHelp extends Handler {\n    //必要的构造器\n    public HandlerHelp(Game game) {\n        super(game);\n    }\n    @Override\n    public void doCmd(String word) {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n}\n```\n```java HandlerGo.java\npackage castle;\n\npublic class HandlerGo extends Handler {\n    public HandlerGo(Game game) {\n        super(game);//现在HandlerGo能管理game对象了\n    }\n    //help和bye都与game无关，但go需要调用goRoom方法，所以需要拿到game对象的管理者\n    public void doCmd(String word) {\n        game.goRoom(word);//调用game的goRoom方法\n    }\n\n}\n```\n>HandlerGo在未来有更好的方法去实现，现在还是用管理者吧\n\n如果要加入新的命令，也非常简单  \n创建一个新的Handler子类，在里面实现命令的功能  \n在Game的构造器中将命令字符串和Handler的子类对象放进去  \n\n现在这个城堡游戏已经有极高的可扩展性了  \n>这个城堡游戏例子非常全面，偶尔回来看看这个例子，是个不错的选择\n\n***\n\n# 抽象abstract\n关键字：**abstract**\n```java\npublic abstract class Shape {//抽象类\n    public abstract void draw(Graphics g);//抽象方法不带{}，即不带方法体\n}\n```\n抽象方法：表达概念，但无法实现具体功能（代码）的方法  \n抽象类：表达概念而无法构造出实体（对象）的类  \n\n有抽象方法的类**一定**是抽象类  \n抽象类不能**制造**对象，但是可以**定义**类变量（任何继承了抽象类的非抽象类的对象可以使用赋给这个类变量，即任何抽象类的子类的对象都可以由这个类变量来管理）  \n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。  \n\n继承自抽象类的子类必须覆盖父类中的抽象方法，否则自己成为抽象类（即子类必须实现抽象父类的抽象方法）\n\n## 两种抽象\n与具体相对  \n·表示一种概念而非实体  \n与细节相对  \n·表示在一定程度上忽略细节而着眼大局  \n\n*** \n\n# 细胞自动机\n\n死亡：如果活着的邻居的数量小于2或大于3，则死亡  \n新生：如果正好有3个邻居活着，则新生其他情况则保持原状  \n\n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n \npublic class Cell {\n\tprivate boolean alive = false;//默认为死亡状态\n\t\n\tpublic void die() { alive = false; }//让细胞死亡\n\tpublic void reborn() { alive = true; }//让细胞重生\n\tpublic boolean isAlive() { return alive; }//返回细胞状态,判断细胞是否存活\n\t//绘制细胞\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tg.drawRect(x, y, size, size);//画个空心矩形\n\t\tif ( alive ) {//如果细胞存活\n\t\t\tg.fillRect(x, y, size, size);//画个实心矩形\n\t\t}\n\t}\n}\n\n```\n\n```java CellMachine.java\npackage cellmachine;\n\nimport javax.swing.JFrame;\n\nimport cell.Cell;\nimport field.Field;\nimport field.View;\n\npublic class CellMachine {\n\n\tpublic static void main(String[] args) {\n\t\t//数据准备阶段,画出一个细胞网格\n\t\tField field = new Field(30,30);//一个30*30的网格\n\t\t//遍历网格，每个网格都有一个细胞\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tfield.place(row, col, new Cell());//每个细胞都有一个状态，初始状态为死亡\n\t\t\t}\n\t\t}\n\n\t\t//遍历每个细胞，设置初始细胞的生存状态\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t//利用随机数让整个网格的五分之一的细胞生存\n\t\t\t\tif ( Math.random() < 0.2 ) { //Math.random()返回0~1之间的随机数\n\t\t\t\t\tcell.reborn();//reborn()方法设置细胞的生存状态为true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        //在窗口中显示细胞网格\n\t\tView view = new View(field);//将网格传入View类中\n\t\tJFrame frame = new JFrame();//创建一个JFrame对象,是java当中的窗口,用来显示细胞网格\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭时的操作\n\t\tframe.setResizable(false);//设置窗口不可改变大小\n\t\tframe.setTitle(\"Cells\");//设置窗口的标题\n\t\tframe.add(view);//将网格添加到窗口中\n\t\tframe.pack();//设置窗口的大小\n\t\tframe.setVisible(true);//设置窗口可见,即显示出来\n\n\t\t//模拟细胞网格的运行\n\t\t//遍历整个网格,取出每个细胞\n\t\tfor ( int i=0; i<1000; i++ ) {//进行1000次模拟\n\t\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t\tCell[] neighbour = field.getNeighbour(row, col);//获取(row,col)位置上的细胞的邻居\n\t\t\t\t\tint numOfLive = 0;//计数器，记录邻居中活细胞的个数\n\t\t\t\t\t//遍历邻居，计算邻居中有多少个细胞是活的\n\t\t\t\t\tfor ( Cell c : neighbour ) {\n\t\t\t\t\t\tif ( c.isAlive() ) {//如果邻居中有一个细胞是活的\n\t\t\t\t\t\t\tnumOfLive++;//让计数器加一\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//控制台输出当前细胞的状态\n\t\t\t\t\tSystem.out.print(\"[\"+row+\"][\"+col+\"]:\");//打印细胞的位置\n\t\t\t\t\tSystem.out.print(cell.isAlive()?\"live\":\"dead\");//打印细胞的状态\n\t\t\t\t\tSystem.out.print(\":\"+numOfLive+\"-->\");//打印细胞的邻居中有多少个细胞是活的\n\t\t\t\t\t//写入下一次的细胞状态\n\t\t\t\t\tif ( cell.isAlive() ) {//如果当前细胞是活的\n\t\t\t\t\t\tif ( numOfLive <2 || numOfLive >3 ) {//判断是否满足让细胞死的条件条件\n\t\t\t\t\t\t\tcell.die();//让细胞死\n\t\t\t\t\t\t\tSystem.out.print(\"die\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( numOfLive == 3 ) {//如果当前细胞是死的，判断是否满足让细胞活的条件条件\n\t\t\t\t\t\tcell.reborn();//让细胞活\n\t\t\t\t\t\tSystem.out.print(\"reborn\");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"UPDATE\");\n\t\t\tframe.repaint();//整个Field都更新好后，画出棋盘\n\t\t\t//延时\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Field {\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;//一个二维数组field，存放每个格子（细胞）\n\t//构造器，初始化棋盘\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\tpublic int getWidth() { return width; }\n\tpublic int getHeight() { return height; }\n\t//添加细胞\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\t//获取某个格子\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\t//获取周围细胞\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor ( int i=-1; i<2; i++ ) {\n\t\t\tfor ( int j=-1; j<2; j++ ) {\n\t\t\t\tint r = row+i;\n\t\t\t\tint c = col+j;\n\t\t\t\tif ( r >-1 && r<height && c>-1 && c<width && !(r== row && c == col) ) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        //toArray会自动把一个Cell[]数组装好，让返回这个数组\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\t//清空所有格子\n\tpublic void clear() {\n\t\tfor ( int i=0; i<height; i++ ) {\n\t\t\tfor ( int j=0; j<width; j++ ) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -5258995676212660595L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\n\t//构造器\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t//每次当窗口被重绘时调用，被调用时会得到一个Graphics对象，即当前要画的对象\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);//调用父类的paint方法\n\t\t//绘制网格\n\t\tfor ( int row = 0; row<theField.getHeight(); row++ ) {//行\n\t\t\tfor ( int col = 0; col<theField.getWidth(); col++ ) {//列\n\t\t\t\tCell cell = theField.get(row, col);//得到每个格子的对象\n\t\t\t\tif ( cell != null ) {//如果该格子有对象\n\t\t\t\t\tcell.draw(g, col*GRID_SIZE, row*GRID_SIZE, GRID_SIZE);//绘制该格子\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth()*GRID_SIZE+1, theField.getHeight()*GRID_SIZE+1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tField field = new Field(10,10);\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {\n\t\t\t\tfield.place(row, col, new Cell());\n\t\t\t}\n\t\t}\n\t\tView view = new View(field);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(view);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n}\n\n```\n\n## Cell、Field、View的关系\nField只需要管好数据以及提供数据  \nView只管拿到数据之后按数据把整个网格都重新画一遍  \n而Cell只管自己应该画空心还是实心，Field要就提供给它  \n\n不去精心设计哪个局部需要更新，需要更新就整个重画   \n这样简化了程序逻辑，是在计算机运算速度提高的基础上实现的  \n<div><img src=https://cdn.chuckle.top/images/7-8.webp width=\"80%\" height=\"80%\"></div>\n\n## 数据与表现分离\n程序的业务逻辑与表现无关  \n-表现可以是图形的也可以是文本的  \n-表现可以是当地的也可以是远程的  \n\n需要不同表现，那就用不同表现的代码去取数据，然后表现出来  \n\n## 责任驱动的设计\n将程序要实现的功能分配到合适的类/对象中去是设计中非常重要的一环  \n\n将功能拆分成很多个部分，每个部分只做自己擅长做的、简单的事  \n\n## 网格化\n图形界面本身有更高的解析度，但是将画面网格化以后，数据就更容易处理了  \n\n无需关心x、y轴坐标，只需知道要操作的对象在第几行第几列\n\n***\n\n# 狐狸和兔子\n细胞自动机是细胞在一个网格上，每个细胞都有两种状态  \n\n现在要模拟一个有狐狸和兔子的农场：   \n·狐狸和兔子都有年龄，且有规律增加  \n·当年龄到了一定的上限就会自然死亡  \n·狐狸可以随机决定在周围的兔子中吃一个，吃了后年龄上限会提高  \n·狐狸和兔子可以随机决定生一个小的，放在旁边的空的格子里  \n·如果不吃也不生，狐狸和兔子可以随机决定向旁边空的格子移一步  \n\n这比只有细胞，细胞只有两种状态要复杂得多  \n\n## 源码\n这个没注释，原理和细胞自动机差不多  \n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\n\n```java Animal.java\npackage animal;\n\nimport java.util.ArrayList;\nimport field.Location;\n\npublic abstract class Animal {\n\n\tprivate int ageLimit;\n\tprivate int breedableAge;\n\tprivate int age;\n\tprivate boolean isAlive = true;\n\n\tpublic Animal(int ageLimit, int breedableAge) {\n\t\tthis.ageLimit = ageLimit;\n\t\tthis.breedableAge = breedableAge;\n\t}\n\n\tprotected int getAge() {\n\t\treturn age;\n\t}\n\n\tprotected double getAgePercent() {\n\t\treturn (double) age / ageLimit;\n\t}\n\n\tpublic abstract Animal breed();\n\n\tpublic void grow() {\n\t\tage++;\n\t\tif (age >= ageLimit) {\n\t\t\tdie();\n\t\t}\n\t}\n\n\tpublic void die() {\n\t\tisAlive = false;\n\t}\n\n\tpublic boolean isAlive() {\n\t\treturn isAlive;\n\t}\n\n\tpublic boolean isBreedable() {\n\t\treturn age >= breedableAge;\n\t}\n\n\tpublic Location move(Location[] freeAdj) {\n\t\tLocation ret = null;\n\t\tif (freeAdj.length > 0 && Math.random() < 0.02) {\n\t\t\tret = freeAdj[(int) (Math.random() * freeAdj.length)];\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\" + age + \":\" + (isAlive ? \"live\" : \"dead\");\n\t}\n\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\treturn null;\n\t}\n\n\tprotected void longerLife(int inc) {\n\t\tageLimit += inc;\n\t}\n}\n\n```\n\n```java Fox.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Fox extends Animal implements Cell {\n\n\tpublic Fox() {\n\t\tsuper(20, 4);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));// (int)((20-getAge())/20.0*255)));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.05) {\n\t\t\tret = new Fox();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Fox:\" + super.toString();\n\t}\n\n\t@Override\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\tAnimal ret = null;\n\t\tif (Math.random() < 0.2) {\n\t\t\tret = neighbour.get((int) (Math.random() * neighbour.size()));\n\t\t\tlongerLife(2);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n```\n\n```java Rabbit.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport cell.Cell;\n\npublic class Rabbit extends Animal implements Cell {\n\n\tpublic Rabbit() {\n\t\tsuper(10, 2);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(255, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.12) {\n\t\t\tret = new Rabbit();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Rabbit:\" + super.toString();\n\t}\n}\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\nimport cell.Cell;\n\npublic class Field {\n\n\tprivate static final Location[] adjacent = {\n\t\t\tnew Location(-1, -1), new Location(-1, 0), new Location(-1, 1),\n\t\t\tnew Location(0, -1), new Location(0, 0), new Location(0, 1),\n\t\t\tnew Location(1, -1), new Location(1, 0), new Location(1, 1)\n\t};\n\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;\n\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\tint r = row + i;\n\t\t\t\tint c = col + j;\n\t\t\t\tif (r > -1 && r < height && c > -1 && c < width && !(r == row && c == col)) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\n\tpublic Location[] getFreeNeighbour(int row, int col) {\n\t\tArrayList<Location> list = new ArrayList<Location>();\n\t\tfor (Location loc : adjacent) {\n\t\t\tint r = row + loc.getRow();\n\t\t\tint c = col + loc.getCol();\n\t\t\tif (r > -1 && r < height && c > -1 && c < width && field[r][c] == null) {\n\t\t\t\tlist.add(new Location(r, c));\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Location[list.size()]);\n\t}\n\n\tpublic boolean placeRandomAdj(int row, int col, Cell cell) {\n\t\tboolean ret = false;\n\t\tLocation[] freeAdj = getFreeNeighbour(row, col);\n\t\tif (freeAdj.length > 0) {\n\t\t\tint idx = (int) (Math.random() * freeAdj.length);\n\t\t\tfield[freeAdj[idx].getRow()][freeAdj[idx].getCol()] = cell;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic Cell remove(int row, int col) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = null;\n\t\treturn ret;\n\t}\n\n\tpublic void remove(Cell cell) {\n\t\tfor (int row = 0; row < height; row++) {\n\t\t\tfor (int col = 0; col < width; col++) {\n\t\t\t\tif (field[row][col] == cell) {\n\t\t\t\t\tfield[row][col] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void clear() {\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tfor (int j = 0; j < width; j++) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void move(int row, int col, Location loc) {\n\t\tfield[loc.getRow()][loc.getCol()] = field[row][col];\n\t\tremove(row, col);\n\t}\n}\n```\n\n```java Location.java\npackage field;\n\npublic class Location {\n\n\tprivate int row;\n\tprivate int col;\n\n\tpublic Location(int row, int col) {\n\t\tthis.row = row;\n\t\tthis.col = col;\n\t}\n\n\tpublic int getRow() {\n\t\treturn row;\n\t}\n\n\tpublic int getCol() {\n\t\treturn col;\n\t}\n}\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport javax.swing.JPanel;\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -2417015700213488315L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);\n\t\tg.setColor(Color.GRAY);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tg.drawLine(0, row * GRID_SIZE, theField.getWidth() * GRID_SIZE, row * GRID_SIZE);\n\t\t}\n\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\tg.drawLine(col * GRID_SIZE, 0, col * GRID_SIZE, theField.getHeight() * GRID_SIZE);\n\t\t}\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tcell.draw(g, col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth() * GRID_SIZE + 1, theField.getHeight() * GRID_SIZE + 1);\n\t}\n}\n```\n\n```java FoxAndRabbit.java\npackage foxnrabbit;\n\nimport java.util.ArrayList;\nimport javax.swing.JFrame;\nimport animal.Animal;\nimport animal.Fox;\nimport animal.Rabbit;\nimport cell.Cell;\nimport field.Field;\nimport field.Location;\nimport field.View;\n\npublic class FoxAndRabbit {\n\n\tprivate Field theField;\n\tprivate View theView;\n\n\tpublic FoxAndRabbit(int size) {\n\t\ttheField = new Field(size, size);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tdouble probability = Math.random();\n\t\t\t\tif (probability < 0.05) {\n\t\t\t\t\ttheField.place(row, col, new Fox());\n\t\t\t\t} else if (probability < 0.15) {\n\t\t\t\t\ttheField.place(row, col, new Rabbit());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttheView = new View(theField);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(theView);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n\tpublic void start(int steps) {\n\t\tfor (int i = 0; i < steps; i++) {\n\t\t\tstep();\n\t\t\ttheView.repaint();\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void step() {\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tAnimal animal = (Animal) cell;\n\t\t\t\t\tanimal.grow();\n\t\t\t\t\tif (animal.isAlive()) {\n\t\t\t\t\t\tLocation loc = animal.move(theField.getFreeNeighbour(row, col));\n\t\t\t\t\t\tif (loc != null) {\n\t\t\t\t\t\t\ttheField.move(row, col, loc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// eat\n\t\t\t\t\t\t// animal.eat(theField);\n\t\t\t\t\t\tCell[] neighbour = theField.getNeighbour(row, col);\n\t\t\t\t\t\tArrayList<Animal> listRabbit = new ArrayList<Animal>();\n\t\t\t\t\t\tfor (Cell an : neighbour) {\n\t\t\t\t\t\t\tif (an instanceof Rabbit) {\n\t\t\t\t\t\t\t\tlistRabbit.add((Rabbit) an);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!listRabbit.isEmpty()) {\n\t\t\t\t\t\t\tAnimal fed = animal.feed(listRabbit);\n\t\t\t\t\t\t\tif (fed != null) {\n\t\t\t\t\t\t\t\ttheField.remove((Cell) fed);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// breed\n\t\t\t\t\t\tAnimal baby = animal.breed();\n\t\t\t\t\t\tif (baby != null) {\n\t\t\t\t\t\t\ttheField.placeRandomAdj(row, col, (Cell) baby);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttheField.remove(row, col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFoxAndRabbit fab = new FoxAndRabbit(50);\n\t\tfab.start(500);\n\t}\n}\n\n```\n\n## 项目结构及分析\n<div><img src=https://cdn.chuckle.top/images/7-9.webp width=\"40%\" height=\"40%\"></div>\n\n在英文中Cell有两种意思，格子、细胞  \n在刚刚到细胞自动机中，Cell类表达细胞，或者没有细胞的空格子，这很合理  \n\n狐狸和兔子类有很多相似的属性和动作，所以它们应该有一个父类  \n但这个父类不应该是Cell，Cell在这个程序中应该表达有东西或没东西的格子才合理  \n所以这个父类应该是Animal  \n\n现在类之间关系是这样的：  \n<div><img src=https://cdn.chuckle.top/images/7-10.webp width=\"100%\" height=\"100%\"></div>\n\n在细胞自动机中我们通过place(r,c,cell)将Cell放进网格中  \n但现在Fox、Rabbit和Cell没有联系，无法将它们放进网格中  \n如果按照之前的思路，Fox、Rabbit应该也是Cell的子类，但多继承是不被允许的（除了C++）  \n\n如果让Animal从Cell继承，这在语意上是模糊的，动物不应该是一种格子（虽然这样做能实现）  \n\n## 接口\n接口是纯抽象类  \n·所有的成员函数都是抽象函数  \n·所有的成员变量都是public static final  \n\n类表达一个具体的东西，而接口表达一种概念、一种规范  \n接口规定了长什么样，但是不管里面有什么  \n\n我们可以将Cell类改造成接口： \n```java Cell\nimport java.awt.Graphics;\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\nCell现在的作用：所有实现了Cell这个接口的类，都应该有draw这个方法  \n在这个程序中，只要实现了这个方法的类的对象，都可以直接放到Field中  \n\n为什么Cell接口只要求实现draw方法？  \n因为将来View只需要拿Cell去draw，所以只需要要求放到Field里的类的对象实现draw方法  \n\n现在类之间关系是这样的：  \n<div><img src=https://cdn.chuckle.top/images/7-11.webp width=\"100%\" height=\"100%\"></div>\n\n现在Fox、Rabbit的对象都可以放进Field里（Field需要一个Cell，而Fox、Rabbit都实现了Cell）  \n\n### implements\n用关键字implements让类实现接口  \n```java\npublic class Fox extends Animal implements Cell{\n    //Fox是一种Animal，它实现了Cell\n}\n```\n在Field的place方法中,place需要一个Cell类的对象  \nCell本身是一个接口，它本身是抽象的，不可能有对象  \n但**所有实现了Cell接口**的对象都可以交给Cell对象的管理者  \n```java\npublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n```\n当Fox实现Cell后，就必须重写Cell中的方法  \n把draw方法实际地做出来  \n```java\n@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n```\n类用extends,接口用implements  \n类可以实现很多接口  \n接口可以继承接口，但不能继承类  \n接口不能实现接口  \n\n### interface\n声明一个接口  \n```java\npublic interface Cell{//接口\n}\npublic class Cell{//类\n}\n```\ninterface是一种特殊的class，它替代掉了class  \n\n### 面向接口的编程方式\n在上面的程序中，Field需要一个能draw的类的对象，然后Field提供了一个Cell接口，所有实现了这个接口的东西都可以交给Field，而它不关心这个东西是什么，只需要符合接口即可  \n\n设计程序时先定义接口，再实现类  \n任何需要在函数间传入传出的一定是接口而不是具体的类  \n是Java成功的关键之一，因为极适合多人同时写一个大程序：每个人只需要用接口去提出要求，其他人根据借口实现具体的类   \n也是Java被批评的要点之一，因为代码量膨胀起来很快，显得程序十分臃肿  \n\n## 增加一个按钮\n\n在狐狸与兔子程序的图形界面中增加一个按钮，按一下执行一步   \n\n在FoxAndRabbit.java中，这么一段代码生成了一个窗口  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\nframe.pack();\nframe.setVisible(true);\n```\n首先要在窗口中增加一个按钮  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\n//有一个类叫JButton，做一个叫btnstep的对象\nJButton btnstep =new JButton(\"单步\");\n//把这个按钮加到窗口中\nframe.add(btnstep);\nframe.pack();\nframe.setVisible(true);\n```\n运行一下\n<div><img src=https://cdn.chuckle.top/images/7-12.webp width=\"30%\" height=\"30%\"></div>\n\n整个窗口只剩下了我们加进去的这个按钮,解决这个问题我们需要了解Swing  \n\n***\n\n>下接[JAVA/面向对象学习笔记(3)](/article/8636f786.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"Butterfly魔改","url":"/article/ab2d75d5.html","content":"\n# 最新文章标志\n\n{% link 给首页文章卡片加上最新文章标志,/article/2ed7d622.html,%}\n<img src=https://cdn.chuckle.top/images/20-1.webp width=\"30%\" height=\"30%\">\n\n# 首页第一个卡片加个class\n\n{% link 首页第一个卡片加个class,/article/dbde845d.html,%}\n<img src=https://cdn.chuckle.top/images/21-1.webp width=\"40%\" height=\"40%\">\n\n# 加载进度条\n\n{% link 一个加载进度条,/article/13d6481a.html,%}\n<img src=https://cdn.chuckle.top/images/10-1.webp width=\"40%\" height=\"40%\">\n\n# 控制单页背景样式\n\n{% link 给指定单页加个class以控制其背景样式,/article/eb3a4679.html,%}\n<img src=https://cdn.chuckle.top/images/22-1.webp width=\"40%\" height=\"40%\">\n\n# 归档、分类、标签页文章卡片加上所属分类和标签\n\n{% link 给归档、分类、标签页文章卡片的标题下方加上所属分类和标签,/article/a19bb7fb.html,%}\n<img src=https://cdn.chuckle.top/images/23-2.webp width=\"80%\" height=\"80%\">\n\n# 添加音乐页面\n\n{% link 添加音乐页面,/article/3322c8a8.html,%}\n<img src=https://cdn.chuckle.top/images/24-1.webp width=\"40%\" height=\"40%\">\n\n# 给网站增加悬浮伸缩侧边栏\n\n{% link 给网站增加悬浮伸缩侧边栏,/article/fab5c3df.html,%}\n<img src=https://cdn.chuckle.top/images/25-1.webp width=\"40%\" height=\"40%\">\n\n# 老旧浏览器弹窗提醒\n\n{% link 老旧浏览器弹窗提醒,/article/e61f6567.html,%}\n<img src=https://cdn.chuckle.top/images/29-1.webp width=\"50%\" height=\"50%\">\n\n# 使用MiniSandbox前端代码可视化\n\n{% link 使用MiniSandbox前端代码可视化,/article/b827db53.html,%}\n<img src=https://cdn.chuckle.top/images/30-3.webp width=\"50%\">\n\n# BF添加输入页数跳转\n\n{% link BF添加输入页数跳转,/article/8e0b4c43.html,%}\n<img src=https://cdn.chuckle.top/images/34-2.webp width=\"50%\" height=\"50%\">\n\n# 给文章添加自定义文本锚点\n\n{% link 给文章添加自定义文本锚点,/article/6f237a88.html,%}\n<img src=https://cdn.chuckle.top/images/36-2.gif width=\"70%\">\n\n# 页面链接二维码(扫一扫)卡片\n\n{% link 页面链接二维码(扫一扫)卡片,/article/59995f0e.html,%}\n<img src=https://cdn.chuckle.top/images/37-4.gif width=\"40%\">\n\n# 网站添加点赞、踩功能\n\n{% link 网站添加点赞、踩功能,/article/5de26c08.html,%}\n<img src=https://cdn.chuckle.top/images/39-3.webp width=\"70%\">\n\n# 博客添加待办清单页\n\n{% link 博客添加待办清单页,/article/9875347c.html,%}\n<img src=/images/40-1.webp width=\"60%\">\n\n# 文章添加预设或实时生成的AI简介\n\n{% link 文章添加预设或实时生成的AI简介,/article/17d3383a.html,%}\n\n***\n\n>咕咕咕~~\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"JAVA/面向对象学习笔记(1)","url":"/article/bfb663c6.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n\n# 面向对象\n\n## 什么是面向对象\n面向对象是把**一组数据结构**和**处理他们的方法**组成对象。  \n把具有**相同行为**的对象归纳成**类**  \n通过**封装**隐藏类的内部细节  \n通过**继承**使类得到泛化  \n通过**多态**实现基于对象类型的动态分派 \n\n## 只能操作对象\n一切事物都是调用加封装的结果  \n程序实现的一切功能都是**调用**加**封装**的结果  \n程序调用一个个对象  \n封装的也是一个个对象\n\n## 基于对象编程\n同一个事物，构成它的对象能有多种划分方式  \n机器语言、汇编语言将电路上的开关，由1和0组成的指令作为对象  \n\nc语音将对象界定为一个个**数据**和一个个**算法**  \njava将**数据和算法的结合**作为一个对象    \n\n数据和算法分开的编程：面向过程编程  \n数据和算法结合的编程：面向对象编程  \n\n## 面向过程与面向对象\n面向过程关注如何实现，关注如何做，将一个要实现的、复杂的功能，用一个或多个大函数去实现，再抽丝剥茧，用更多的函数去实现这些函数。  \n面向对象关注数据，方法就在这，处理什么数据（对象）  \n\n面向对象中也有面向过程的代码，只是重点不在如何做，而是对对象的**抽象**与**扩展**  \n对于实现功能的核心算法，面向对象与面向过程并无区别，c语言也可通过结构体与函数指针实现面向对象    \n\n面向对象的**封装**、**继承**和**多态**，使得代码、功能的扩展、复用变得非常容易  \n\n这两种编程思想都是为了解决实际的问题  \n\n{% folding, 如何烧水  %}\n**转自互联网**  \n面向过程的烧水：  \n读取热水壶内水的水温，缓存  \n电热装置将发热量缓存  \n损耗算法读取发热量，并将将水的提升温度缓存  \n与水温相加  \n将这个数值重新赋给水温  \n直到温度达到沸点，完成烧水    \n\n面向对象的烧水：  \n定义热水壶类，继承自盛水容器，温度改变装置，温度计，水温控制接口  \n实例化一个热水壶类对象，命名为「我的热水壶」  \n为终止温度赋值：水.沸点  \n我的热水壶.温度处理(终止温度);  \n\n另：个人实现的烧水方法，仅图一乐：  \n为热水壶类实装烧水接口：实装水温监视事件  \n为热水壶类实装烧水接口：定义一个水温枚举器  \n为热水壶类实装烧水接口：实装温度处理方法  \n执行流程：  \n1.执行继承自盛水容器类的盛水方法  \n2.注册继承自温度改变装置类的温度监视事件  \n3.遍历水温枚举器：如果水温提升，则返回当前水温  \n4.如果返回值接近终止温度，跳出枚举过程，完成烧水。  \n5.否则，继续遍历枚举器。  \n\n你肯定会问这哪里优雅了，确实，看起来是复杂了不少，但再仔细想一想，这一整套流程只要稍加修改，稍加改变接口实现，你就可以直接用这个「热水壶类」实现一个热水器，甚至还可以是一个冰箱。  \n毕竟烧的又不一定是水，又不一定要烧水，又不一定要用壶烧水，又不一样要是个烧水壶  \n{% endfolding %}\n\n***\n\n# 对象与类\n对象是实体，需要被创建，可以为我们做事情    \n类是规范，根据类的定义来创建对象    \n\n一个类可以有多个对象  \n\n动物是一个类，每个对象，猫，狗，都是动物类的实体    \n我们用类制造出对象，再给对象所需要的数据，对象可以利用这些数据去做事情，我们大可无需知道对象是如何利用这些数据的，因为我们只要求，这个对象能实现一些功能  \n\n## 面向对象的思维\n我们看到一个事物  \n它有什么东西？  \n能干什么？  \n\n## 第一个程序：自动售货机\n售货机（VendingMachine）有什么？  \n商品的价格：price  \n显示的余额：balance  \n卖了多少钱：total  \n\n售货机能干什么？  \n输出一些提示：showPromot  \n取得一些钱：insertMomey  \n告诉用户余额：showBalance\n给我们商品（食物）：getFood  \n告诉商家总收入：showTotal\n\n我们需要设计VendingMachine这个类，这个类有3个属性，有5个动作（方法）  \n```java\nimport java.util.Scanner;\n//创建一个类\npublic class VendingMachine {\n    int price = 80;//商品价格(假设就只有一个商品，且价格固定)\n    int balance = 0;//当前余额\n    int total = 0;//总收入\n    int amount = 0;//钱\n    Scanner s=new Scanner(System.in);\n\n    void showPromot() {\n        //输出提示\n        System.out.println(\"欢迎！\");\n    }\n\n    void insertMomey(){\n        // 投入钱，更新余额\n        System.out.print(\"请充值余额：\");\n        amount = s.nextInt();\n        balance = balance + amount;\n    }\n\n    void showBalance(){\n        //输出余额\n        System.out.println(\"现在余额： \"+ balance);\n    }\n\n    void getFood(){\n        //给食物\n        if (balance >= price) {\n            System.out.println(\"给你。\");\n            balance = balance - price;\n            total = total + price;\n        }\n        else{\n            System.out.println(\"没有足够的余额！\");\n        }\n    }\n\n    void showTotal(){\n        System.out.println(\"目前总收入：\"+total);\n    }\n}\n```\n有了这个类，就可以通过类去制造一个对象,并让对象去实现一些功能\n```java\npublic class Main {\n    public static void main(String[] args) {\n        //制作一个对象\n        VendingMachine vm = new VendingMachine();\n        boolean t = true;\n        vm.showPromot();\n        vm.showBalance();\n        while (t) {\n            vm.insertMomey();\n            vm.getFood();\n            vm.showBalance();\n            vm.showTotal();\n        }\n    }\n}\n```\n运行结果：  \n```\n欢迎！\n现在余额： 0\n请充值余额：100\n给你。\n现在余额： 20\n目前总收入：80\n请充值余额：20\n没有足够的余额！\n现在余额： 40\n目前总收入：80\n请充值余额：40\n给你。\n现在余额： 0\n目前总收入：160\n请充值余额：\n```\n\n## 创建对象\n使用new运算符，来创建这个类的一个对象  \n然后将这个对象交给这个类型的一个变量  \nVendingMachine vm = new VendingMachine();  \n\n**对象变量是对象的管理者**  \n\n## 让对象做事情\n使用 . 运算符  \nvm.insertMomey();  \nvm.getFood();  \n通过.运算符调用某个对象的方法  \n\n## 成员变量、成员方法\n类定义了**对象中**所具有的变量，这些变量称作成员变量  \n每个对象有自己的变量，和同一个类的其他对象是分开的  \n在方法中可以直接写成员变量（方法）的名字来访问成员变量（方法）（省去了this关键字）  \n\njava会给成员变量默认0值\n\n成员变量（方法）分为实例变量（方法）和类变量（方法）  \n加了static的就是类变量（方法）  \n\n### 类变量\n声明类变量： **static** <类型> <变量名>  \n\n访问类变量：  \n通过对象访问：<对象名>.<类变量名>  \n通过类访问：<类名>.<类变量名>  \n\n类变量不属于任何一个对象，属于这个类，但任何一个对象都拥有这个变量  \n\n修改类变量的值，所有对象中的该变量的值都会改变  \n\n类变量的初始化只会进行一次（在类的装载时）  \n\n### 类方法\n声明类方法： **static** <返回类型> <方法名>() {  }  \n\nstatic方法只能调用static方法，只能访问static变量   \n\n类方法可以通过类的名字去访问，也可以通过对象去访问  \n\n\n## 本地（局部）变量\n定义在**方法内部**的变量是本地变量  \n本地变量的生存期和作用域都是方法内部  \n\n本地变量没被赋值，会被禁止使用  \n\n成员变量的生存期是对象的生存期，作用域是类内部的成员方法 \n\n### var局部变量\n使用var时必须指出初始值(不可以是null)  \nvar <变量名> = <值>;  \n编译器可以推断出该变量的类型，且之后该变量的类型都是确定的，不可以给该变量赋其它类型的值\n\n## 对象初始化\n可以在定义成员变量的地方直接赋值  \nint price = 80;  \n\n在创建一个对象的过程中，会首先去做各种初始化的动作\n\n### 构造方法\n与类同名的函数，没有返回值  \n在创建一个对象时会自动调用的方法\n应该是public\n```java  \nVendingMachine(){\n    total = 10;\n}\n\nVendingMachine(int price ){\n    this.price = price;\n}\n```\n### 方法重载\n一个类里可以有多个**不同参数**的构造方法  \n创建对象的时候给出不同的参数值，就会自动调用不同的构造方法  \n通过this()还可以在构造方法中调用其他构造方法，写在第一行，且只能使用一次    \n一个类里的同名但参数表不同的方法构成了重载关系  \n\n## 对象的识别\n通过巧妙的思想，识别不同出对象的特点，让类更通用  \n例如，要实现一个时钟  \n可以设计一个类，通过这个类可以制造出时、分、秒三个对象  \n\n## 对象的交互\n时、分、秒三个对象可以共同组成一个时钟对象  \n控制时、分、秒之间的交互在时钟对象的方法中完成  \n```java Display.java\npublic class Display {\n    private int value = 0;\n    private int limit = 0;\n\n    public Display(int limit){\n        this.limit = limit;\n    }\n\n    public void increase(){\n        value++;\n        if(value == limit){\n            value = 0;\n        }\n    }\n\n    public int getValue(){\n        return value;\n    }\n\n}\n```\n\n```java Clock.java\npublic class Clock {\n    Display hour = new Display(24);\n    Display minute = new Display(60);\n    Display second = new Display(60);\n\n    public void start() {\n        while (true) {\n            second.increase();\n            if (second.getValue() == 0) {\n                minute.increase();\n                if (minute.getValue() == 0) {\n                    hour.increase();\n                }\n            }\n            System.out.printf(\"%02d:%02d:%02d\\n\", hour.getValue(), minute.getValue(), second.getValue());\n        }\n    }\n}\n```\n\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Clock clock = new Clock();\n        clock.start();\n    }\n}\n```\n\n***\n\n# 访问属性\n**private**：这个成员是私有的，只有在类的内部（成员方法和定义初始化 ）才能访问  \n一般来说，成员变量都该是private   \n**这个限制是对类的而不是对对象的**：同一个类的不同对象可以互相访问对方的成员变量  \n\n**public**：任何人都可以访问  \n任何人指的是在任何类的方法或定义初始化中可以使用  \n使用指的是调用、访问或定义变量  \n很多的成员方法都是public \npublic的类，类名和文件名要一致，一个编译单元只能有一个public的类  \n\n**protected**：受保护的成员  \n\n**friendly**：默认属性，友好的成员  \n\n| 访问属性  | 本类    | 同包       | 子类      |   其它  |\n| -----    | ------ | --------- | ------   |   ---  |\n| private  |   √    |           |          |        |\n| friendly |     √  |   √       |          |        |\n| protected|   √    |     √     |     √    |        |\n| public   |     √  |     √     |      √   |   √    |\n\n***\n\n# 包package\n包是java管理类的一个机制  \n源文件中同名类要在**不同**包内  \n\n声明该类的指定包名  \npackage <包名>;  \n\n包名中的.代表文件夹的层次  \n\n没有package语句的源程序都将视为在同一个无名包内  \n\n## import\n使用import语句引入包中的类和接口  \n\nimport test.Hallo  \ntest包中的Hallo类  \n\n只要用到的类和本类不在同一个包内，就要import它  \n\n如果不使用import，当要用到类时要给出全名：<包名>.<类名>  \n\n引入一个包内的所有东西：import <包名>.*;（注意同名类的冲突） \n\n***\n# NoteBook例子\n记事本可以做什么？  \n1、能存储记录  \n2、不限制能存储的记录的数量  \n3、能知道已经存储的记录的数量  \n4、能查看存进去的每一条记录  \n5、能删除一条记录  \n6、能列出所有的记录  \n\n确定需求后，进行接口设计  \n```java 接口设计\npublic class NoteBook {\n\n    public void add(String s) {\n        //添加内容\n    }\n\n    public int getSize() {\n        //放了多少个\n        return 0;\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return \" \";\n    }\n\n    public boolean removeNote(int index) {\n        //删除\n        return true;\n    }\n\n    public String[] list() {\n        //返回全部内容\n    }\n\n}\n\n```\n接口设计完，考虑实际功能的实现，首先是数据的存放  \n\n## 顺序容器\n```java\nprivate ArrayList<String> notes = new ArrayList<String>();  \n```\n用来存放String的一个ArrayList  \nArrayList内的东西是有顺序的，是加入数据的顺序，形成对应下标的索引（从0开始）  \n\n这种类型叫做范型类：泛型类封装不特定于特定数据类型的操作  \n这种范型类是一种容器  \n\n容器类有两个类型：容器的类型、元素的类型  \n\n利用容器类的方法可以实现需要的功能  \nnotes.add(s);  //向容器添加数据\nnotes.size();  //容器存了多少个东西\nnotes.get(1); //得到1位置处的数据\n\n完成全部功能接口\n```java NoteBook.java\nimport java.util.ArrayList;\n\npublic class NoteBook {\n    private ArrayList<String> notes = new ArrayList<String>();//容器类\n\n    public void add(String s) {\n        //添加内容\n        notes.add(s);\n    }\n\n    public void add(String s, int location) {\n        //加到指定位置前，后面的内容下标后推\n        notes.add(location, s);\n    }\n\n    public int getSize() {\n        //放了多少个\n        return notes.size();\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return notes.get(index);\n    }\n\n    public void removeNote(int index) {\n        //删除，后面下标前移，因为remove方法自会抛异常，所以无需返回boolean\n        notes.remove(index);\n    }\n\n    public String[] list() {\n        //返回全部内容\n        String[] a = new String[notes.size()];\n\n        //for (int i=0; i< notes.size(); i++){\n        //    a[i] = notes.get(i);\n        //}\n        notes.toArray(a);//会自己把数组按顺序填好\n        //要熟悉系统类库里有的方法，无需重复造轮子\n        return a;\n    }\n\n}\n```\n写出上层程序\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        NoteBook nb = new NoteBook();\n\n        nb.add(\"first\");\n        nb.add(\"second\");\n        System.out.println(nb.getSize());\n        System.out.println(nb.getNote(1));\n\n        nb.add(\"third\", 1);\n        System.out.println(nb.getNote(1));\n        System.out.println(nb.getNote(2));\n        System.out.println(nb.getSize());\n\n        nb.removeNote(1);\n        String[] b = nb.list();\n        for (String s : b) {\n            System.out.println(s);\n        }\n    }\n\n}\n\n```\n输出：\n```\n2\nsecond\nthird\nsecond\n3\nfirst\nsecond\n```\n\n## 对象数组\n```java\nString[] a = new String[notes.size()];  \n```\n对象数组中的每个元素都是对象的管理者而非对象本身  \n当创建了一个对象数组，只是管理者们被创建了，但对象还没有，得想办法把每个对象创建出来  \n\n### for-each循环\n对于普通数组：  \n```java\nint[] a = new int[10];\nfor (int i = 0; i < a.length; i++) {\n    a[i] = i;//赋值\n}\nfor ( int k : a ) {\n    System.out.println(k);\n    k++;//每个k都是a中元素的复制品，不会起作用\n}\n```\n对于对象数组：  \n```java\nValue[] a = new Value[10]; \nfor (int i=0; i< 10; i++){\n    a[i] = new Value[];\n    a[i].set(i);\n}\nfor ( Value v : a ){\n    System.out.println(v.get());\n    v.set(0);//起作用，因为对象数组存的是对象管理者，v=a[i]，v也会成为对象管理者\n}\n```\n\n\n## 集合容器\n集合容器内所有元素都不相同  \n而且里面的元素不排序  \n```java\nHashSet<String> s = new HashSet<String>();\ns.add(\"first\");\ns.add(\"second\");\ns.add(\"first\");\nSystem.out.println(s);//容器都可以这样输出\n```\n输出：\n```java\n[second, first]\n```\n\n## public String toString\n在java中只要类中实现了这样一个方法  \n就可以直接用对象名输出这个对象  \n容器当中都有这样一个方法 \n```java\npublic String toString(){  \n    return \"\";  \n}  \n```\n\n## Hash表\n例子：数字与美元硬币名字对应，查找硬币名称  \n1=penny  \n5=nickel  \n10=dime  \n25=quarter  \n50=half-dollar\n\n定义接口：\n```java\npublic class Coin {\n    public String getName(int amount){\n            return  \"\";\n    }\n}\n```\n为什么不用switch-case？  \n体现在代码中的硬编码越少越好  \n\n使用Hash表（一种数据结构）  \n在这个表中，所有东西是以一对值放入的，一个叫做key（键），一个叫做值  \n一个key对应一个值，可以用key取值  \nHash表中的元素没有顺序  \n```java Coin.java\nimport java.util.HashMap;\n\npublic class Coin {\n    //不能使用int，容器当中所有的类型都得是对象,而不能是基本类型\n    //Integer是int的包裹类型\n    private HashMap<Integer, String> coinnames = new HashMap<Integer, String>();\n\n    public Coin(){\n        coinnames.put(1, \"penny\");//1对应penny\n        coinnames.put(10, \"dime\");\n        coinnames.put(25, \"quarter\");\n        coinnames.put(50, \"half-dolar\");\n        \n        System.out.println(coinnames.keySet().size());//keySet()，把所有key做为一个HashSet的集合给你，在这个集合可以得到size\n        System.out.println(coinnames);//也可以直接输出\n        coinnames.put(50, \"五十\");//会替换掉前面的\n        System.out.println(coinnames);\n        for (Integer k : coinnames.keySet()){//遍历Hash表\n            String s = coinnames.get(k);\n            System.out.println(s);\n        }\n    }\n\n    public String getName(int amount){\n        if (coinnames.containsKey(amount))\n            return coinnames.get(amount);\n        else\n            return  \"NOT FOUND\";//不判断的话，不存在会返回null\n    }\n\n\n}\n```\n```java Main.java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int amount = in.nextInt();\n        Coin coin = new Coin();\n        String name = coin.getName(amount);\n        System.out.println(name);\n    }\n}\n```\n输出：\n```java\n10\n4\n{1=penny, 50=half-dolar, 25=quarter, 10=dime}\n{1=penny, 50=五十, 25=quarter, 10=dime}\npenny\n五十\nquarter\ndime\ndime\n```\n\n***\n\n# 继承与子类\n\n## 媒体资料库设计\n和NoteBook一样，需要设计一个类,用类去表达一种媒体（CD,DVD）  \n然后用一个媒体类的容器去装媒体对象，一个资料库就完成了  \n\nCD有什么？  \n名称：title  \n艺术家：artist  \n多少首歌：numofTracks  \n持续时间：playingTime  \n是否被借出：gotIt  \n描述：comment  \n\n能做什么？\n输出一些信息：print\n\n```java CD.java\npublic class CD{\n    private String title;\n    private String artist;\n    private int numofTracks;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        System.out.print(title+\":\");\n        System.out.println(artist);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.list();\n    }\n}\n```\n现在资料库中已经可以存各种CD媒体了  \n但我们还想在资料库中存DVD媒体或者其它媒体类型  \n\n当然，我们可以再创建一个类表示DVD\n```java DVD.java\npublic class DVD{\n    private String title;\n    private String director;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        this.director = director;\n        this.title = title;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        System.out.print(title+\":\");\n        System.out.println(director);\n    }\n}\n```\n设计好类后在Database.java里创建一个放DVD的容器,以及配套的方法    \n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n    //+\n    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n    //+\n    public void add(DVD dvd){\n        listCD.add(dvd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n        //+\n        for(DVD dvd : listDVD){\n            dvd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        //+\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n现在资料库中能存放两种媒体  \n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \n我们创建了一个资料库类  \n资料库类里有两个容器，用来存放两种不同类型的媒体的对象管理者  \n\n<div><img src=https://cdn.chuckle.top/images/7-1.webp width=\"70%\" height=\"70%\"></div>\n\n这样的结构虽然能实现我们需要的功能，但DVD和CD类几乎一模一样   \n出现了很多代码复制，这是代码质量不良的表现  \n当我们需要修改print，add等方法，就得逐个去改  \n当我们需要新增一种媒体，就得为它做很多的工作  \n\n## 继承\nCD和DVD类很相似，我们可以从中提取一些它们共有的东西封装成一个类Item  \nItem可以表达CD或者DVD  \n而Database只需管Item  \n\n```java Item.java\npublic class Item {\n    private String title;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public Item(String title, int playingTime, boolean gotIt, String comment) {\n        this.title = title;\n        this.playingTime = playingTime;\n        this.gotIt = gotIt;\n        this.comment = comment;\n    }\n\n    public Item(){\n\n    }\n\n    public void print() {\n        System.out.print(title+\":\");\n    }\n\n}\n```\n```java CD.java\npublic class CD extends Item{\n//    private String title;\n    private String artist;\n    private int numofTracks;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n//        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        super.print();\n        System.out.println(artist);\n    }\n}\n```\n```java DVD.java\npublic class DVD extends Item{\n//    private String title;\n    private String director;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n        this.director = director;\n//        this.title = title;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        super.print();\n        System.out.println(director);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n//    private ArrayList<CD> listCD = new ArrayList<CD>();\n//    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n    private ArrayList<Item> listItem = new ArrayList<Item>();\n\n//    public void add(CD cd){\n//        listCD.add(cd);\n//    }\n//\n//    public void add(DVD dvd){\n//        listCD.add(dvd);\n//    }\n    public void add(Item item){\n        listItem.add(item);\n    }\n\n    public void list(){\n//        for (CD cd : listCD){\n//            cd.print();\n//        }\n//        for(DVD dvd : listDVD){\n//            dvd.print();\n//        }\n        for (Item item : listItem){\n            item.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \nCD extends Item：CD扩展了Item  \n即CD变成了Item的子类  \n这就是**继承**  \nCD得到了Item里所有的东西  \n\n<div><img src=https://cdn.chuckle.top/images/7-2.webp width=\"70%\" height=\"70%\"></div>\n\n## 子类与父类\n当父类里的东西是private时  \nprivate String title;  \n子类得到了这个东西，但不能用（可以通过父类的方法去用）  \n解决办法：将private改成protect  \n但这样不好，有很多时候父类和子类不在同一个包内  \n\ntitle本来就是父类的东西  \n可以让title在父类中初始化完，再让子类得到title  \n```java\npublic Item(String title) {\n    this.title = title;\n}\n```\n在子类构造器中使用super()来得到父类的title  \n```java\n public CD(String title) {\n    super(title);\n}\n```\n\n### super()\n当程序初始化对象时，会先运行super()  \n然后去运行父类的构造器，再回来继续运行自己的构造器  \n\nsuper():去父类调用一个没有参数的构造器  \nsuper(<参数>):去父类调用一个有对应参数的构造器  \n\n当子类没有super(),会默认去调用父类没有参数的构造器  \n\n通过super关键字来实现对父类成员的访问，用来引用当前对象的父类  \nsuper.<父类成员>  \n\n通过this来区分子类父类中的同名成员  \nthis.aaa();   // this 调用自己的方法  \nsuper.aaa();  // super 调用父类方法  \n\n## 子类和子类型\n类定义了类型  \n子类定义了子类型  \n\n子类的对象可以被当作父类的对象来使用  \n-赋值给父类的变量（父类的对象管理者可以管理子类的对象）  \n<div><img src=https://cdn.chuckle.top/images/7-3.webp width=\"70%\" height=\"70%\"></div>\n\n-传递给需要父类对象的方法  \n\n\n-放进存放父类对象的容器里  \n<div><img src=https://cdn.chuckle.top/images/7-4.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=https://cdn.chuckle.top/images/7-5.webp width=\"35%\" height=\"35%\"></div>\n\n***\n\n# 多态\n## 多态变量\n所有的**对象变量**都是**多态**的（它们能保存不止一种类型的对象，不同时刻可以放不同类型的对象（例如父类的对象变量放子类的对象））  \n它们可以保存的是声明类型的对象，或声明类型的子类的对象  \n\n当把**子类的对象**赋给**父类的变量**的时候，就发生了**向上造型**  \n\n每一个java的对象变量，都具有两个类型  \n一个是**声明类型**  \n一个是**动态类型**  \n有时候两者是一致的，有时候又不一样  \n\n这就是变量的多态（在运行过程中，它所管理的对象类型是会变化的）  \n\n## 造型\n造型：把一个类型的**对象**，赋给另一个类型的**变量**\n\n对象变量的赋值并不是把一个对象赋给另一个对象（注在c++中可以做两个对象之间的赋值）  \n而是让这两个对象的管理者去**管理同一个对象**  \n```java\nString s = \"hello\";\n//原本这个String类型的对象变量s管理着一个对象\n//这个对象里面有个\"hello\"\ns = \"bye\";\n//后来s去管理另一个对象，里面有\"bye\"\n```\n并不是将bye替换掉hello，java不能做这种事  \n\njava中”=“的赋值运算，实际上是在改变指向  \n```java\nString s = \"hello\";\nString t = \"bye\";\ns = t;\n//原本s和t各管理一个对象，现在s和t管理同一个对象，里面有”hello“\n```\n当给一个**对象变量**管理着与它声明（静态）类型**不符**的对象时，就发生了**造型**  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\n//把子类的对象赋给父类的变量，让父类的对象变量去管理子类的对象\n```\n父类对象是不能直接赋给子类对象变量的\n但可以强制把父类对象当成子类的对象，然后去造型  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\nCD cc = item;//不行。父类对象不能直接交给子类对象变量去管理\nCD cc = (CD)item;//行，因为item已经管理着一个CD的对象了\n//强制把item的类型当做CD\n```\n如果没有Item item = cd;\n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\n//Item item = cd;\nCD cc = (CD)item;//编译可以通过，但运行会出错\n```\n将一个变量强制造型成另一个类型，然后赋给另一个变量  \nCD cc = (CD)item;  \n只有当item这个变量**实际管理**着CD类型的对象才不会出错  \n\n在C语言中，有类似写法，但是是类型转换（对于基本类型int、double，java也能强制类型转换）  \nint i = (int)10.2;//强制类型转换\n这与造型是不同的  \n类型转换是将10.2变成了10  \n但造型只是把item当做CD类型来看待  \nitem本身还是Item类型  \n\n(类型名)对象名：将一个对象当做这个类型来看待  \n\n### 向上造型\n向上造型是特殊的造型，无需写(父类类型)  \n拿一个子类的对象，当作父类的对象来用  \n向上造型总是安全的  \n\n## 方法调用的绑定\n```java\npublic void list(){\n    for (Item item : listItem){\n        item.print();\n    }\n}\n```\nitem每次循环管理的对象不一样，甚至管理的对象的类型也不一样，可以是CD或是DVD  \n当item管理CD(DVD)类型的对象时，去调用print方法，调用的是CD(DVD)类型里的print  \n\n\n当通过对象变量调用方法的时候，调用哪个方法这件事情叫做绑定  \n-静态绑定：根据变量的声明类型来决定  \n-动态绑定：根据变量的动态类型来决定  \n在成员函数中调用其他成员函数也是通过this这个对象变量来调用的  \n\njava默认所有的绑定都是动态绑定  \n\n### 覆盖\n子类和父类中存在**名称和参数表**完全相同的函数，这一对函数构成**覆盖**关系  \n通过父类的变量调用存在覆盖关系的函数时，调用变量当时所**管理的对象**所属的类的函数  \n这是一种动态绑定  \n\n## 多态总结\n多态性是对象多种表现形式的体现  \n\n通过一个变量去调用一个函数，我们不去判断变量运行中实际类型是什么，我们只想它能print  \n多态是**同一个行为**具有多个**不同表现形式或形态**的能力  \nitem是CD类型时它这样print，是DVD类型时那样print，但都是print行为  \n\n***\n\n# 类型系统\n\n## Object类\njava中所有类都是Object类型的子类  \n这是一种单根结构  \n<div><img src=https://cdn.chuckle.top/images/7-6.webp width=\"70%\" height=\"70%\"></div>\n\n发生继承时，父类所有public的东西子类都会得到  \n所以java中所有的类，都从Object类中得到了两个函数  \n-toString()  \n-equals()  \n\n## toString()\ntoString()会返回一个字符串，用来表达对象  \n\n当一个类中没有toString()方法时，会调用继承自Object类的toString()  \n```java\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd.toString());\nSystem.out.println(cd);//和上面的效果一个月，编译器会知道这个地方需要调用toString()\n\nString s = \"aa\"+cd;//编译器知道这个地方需要调用toString()\nSystem.out.println(s);\n```\n```java 输出\nCD@3d075dc0\n//类型名+一个类似地址、编号的东西\nCD@3d075dc0\naaCD@3d075dc0\n```\n显然，默认的表达这个对象的toString(),是返回一个类型名+一个类似地址、编号的东西  \n\n我们可以在类中自定义一个toString()  \n即设计一个表达对象的toString()  \n```java\n@Override\npublic String toString() {\n    return \"CD{\" +\n            \"artist='\" + artist + '\\'' +\n            \", numofTracks=\" + numofTracks +\n            '}';\n    }\n```\n```java 输出\nCD{artist='aaa', numofTracks=4}\n```\n\n## equals()\n\n==**无法**比较两个对象的内容是否相同，只能比较这两个对象变量是否管理着同一个对象    \n我们需要使用equals()去比较内容  \n\n当类中没有equals()，会调用继承自Object类的equals()  \n```java\nCD cd1 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nCD cd2 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd1.equals(cd2));\n```\n```java 输出\nfalse\n```\nObject这个公共父类的equals()无法知道它的子类长什么样子，所以也无法比较这两个对象内容是否相等  \nObject的equals()实际上也是在比较两个对象变量是否管理着同一个对象\n\n我们需要使用自定义的equals()去比较内容  \n```java\n@Override\npublic boolean equals(Object o) {\n    CD cc = (CD) o;//将Object o看作是CD类型的\n    return numofTracks == cc.numofTracks && artist.equals(cc.artist);\n}\n```\n```java 输出\ntrue\n```\n\n## @Override\n作用：告诉编译器，这个函数覆盖了父类的同属性、同名、同参方法  \n也可能会在代码界面报错，如果这个函数没有和父类的同名方法有相同属性、参数\n\n不带@Override，如果自定义的equals()和父类的同属性、同名、同参  \n那么也会覆盖掉父类的，@Override只是起帮助检查作用  \n\n***\n\n# 可扩展性\n现在要往Database这个资料库里增加新的媒体类型，是一件非常容易的事情    \n```java VideoGame.java\npublic class VideoGame extends Item {\n    private int numberofPlayers;\n\n    public VideoGame(String title, int playingTime, boolean gotIt, String comment, int numberofPlayers) {\n        super(title, playingTime, gotIt, comment);\n        this.numberofPlayers = numberofPlayers;\n    }\n\n    public void print() {\n        System.out.print(\"VideoGame:\");\n        super.print();\n        System.out.println(numberofPlayers);\n    }\n}\n```\n<div><img src=https://cdn.chuckle.top/images/7-7.webp width=\"70%\" height=\"70%\"></div>\n\n只需要增加一个子类，然后构造一下，覆盖下方法，父类完全不需要去动  \n这种特性叫**可扩展性**：代码无需修改即可扩展去适应新的数据、新的内容  \n\n如果需要修改去适应新的数据、新的内容，则叫**可维护性**  \n\n***\n\n>下接[JAVA/面向对象学习笔记(2)](/article/9f2dc6c7.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"C语言单链表菜品管理系统","url":"/article/a696e8fe.html","content":"\n# 简介\n我的大一上学期期末项目，也是C语言的期末大作业。  \n\n使用单链表进行菜品信息的存储，系统有菜品的增删改查、排序、安全输入、统计、随机输出和文件输入输出等功能。 \n\n现在回去看代码想给自己一锤子（误）\n\n***\n\n# 包含文件\n<div><img src=https://cdn.chuckle.top/images/6-8.webp width=\"70%\" height=\"70%\"></div>\n\n***\n\n# 函数说明\n<div><img src=https://cdn.chuckle.top/images/6-9.webp width=\"70%\" height=\"70%\"></div>\n<div><img src=https://cdn.chuckle.top/images/6-10.webp width=\"70%\" height=\"70%\"></div>\n\n***\n# 代码\n```c 900行有点长\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <time.h>\n#include <windows.h>\n\n#define SIZE1 100 //名称，价格等字数\n#define SIZE2 200 //限制评价字数\n\ntypedef struct _node\n{\t\t\t\t\t\t\t//链表的节点结构体\n\tchar name[SIZE1];\t\t//菜品名称\n\tchar restaurant[SIZE1]; //饭店名字\n\tfloat price;\t\t\t//菜的价格\n\tint fraction;\t\t\t//菜的评分\n\tchar comment[SIZE2];\t//菜品评价\n\tstruct _node *next;\n} Node;\ntypedef struct _list //方便对链表操作\n{\n\tNode *head;\n\tNode *pa;\n\tNode *pb;\n\tNode *pc;\n} List;\n//菜单\nvoid menu(void);\t\t\t   //一级菜单\nvoid menu_inquire(List *list); //二级菜单_查询菜单\nvoid help(void);\t\t\t   //二级菜单_帮助菜单\nint menu_sort(List *list);\t   //三级菜单_排序方法\n//对节点操作\nvoid add(List *list);\t  //添加节点\nvoid delete (List *list); //删除节点\nvoid revise(List *list);  //修改节点\n//安全输入\nchar *s_gets(char *st, int n); //安全输入字符\nint get_int(void);\t\t\t   //安全输入int型\nfloat get_float(void);\t\t   //安全输入float型\n//链表的输出和操作\nvoid inquire_all(List *list);\t\t\t//输出链表全部节点\nvoid inquire_one(List *list);\t\t\t//输出链表指定菜名节点\nvoid inquire_restaurant(List *list);\t//输出链表指定饭店节点\nvoid inquire_part_price(List *list);\t//输出一定价格以下的菜品(这功能。。贫穷)\nvoid inquire_part_fraction(List *list); //输出一定评分以上的菜品\nvoid average_percentage(List *list);\t//查询某饭店或食堂的平均价格和评分\nvoid output(Node *p);\t\t\t\t\t//方便输出\nvoid random_menu(List *list);\t\t\t//随机输出一道菜\nvoid empty(List *list);\t\t\t\t\t//清空链表\n//文件操作\nvoid save(List *list);\t   //保存\nvoid read_txt(List *list); //读取文件_初始链表\n//单链表的排序\nvoid sort_ascending(List *list);\t\t //菜品按价格从低到高排序\nvoid sort_descending(List *list);\t\t //菜品按价格从高到低排序\nvoid sort_score(List *list);\t\t\t //菜品按评分从高到低排序\nint calculate(List *list);\t\t\t\t //计算出单链表的节点个数\nvoid swap1(List *list, List *list_swap); //单链表冒泡排序的算法块1\nvoid swap2(List *list, List *list_swap); //单链表冒泡排序的算法块2\n//其他\nint random_number(List *list); //随机生成不大于节点数的整数\nvoid color(int a);\t\t\t   //控制台文本颜色\n//______________________________________________________\n//------------------------------------------------------\nint main() //主函数\n{\n\t//system(\"chcp 65001\");//GB2313\n\t//system(\"chcp 936\");//UTF8\n\t//system(\"cls\");\n\tmenu(); //输出功能菜单\n\t//佛祖开光无bug\n\treturn 0;\n}\n//菜单\nvoid menu() //一级菜单\n{\n\tint options, z = 1;\n\tList list;\n\tlist.head = NULL;\t\t\t\t   //head指向空，链表不存在\n\tFILE *fp = fopen(\"Menu.txt\", \"a\"); //若无Menu.txt文件，则创建一个\n\tfclose(fp);\n\tread_txt(&list); //读入txt中的数据，初始化链表\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(14);\n\t\tprintf(\"|                    菜品信息系统             \\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"|********************系统功能菜单*********************\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|1、使用帮助|                       \\n\");\n\t\tprintf(\"|*******************|2、添加菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|3、删除菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|4、查询菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|5、修改菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|6、今天吃什么|                     \\n\");\n\t\tprintf(\"|*******************|7、清空所有数据|                     \\n\");\n\t\tprintf(\"|*******************|8、保存|\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|0、退出系统|                       \\n\");\n\t\tcolor(12);\n\t\tprintf(\"|!!!前请先保存再退出系统,否则数据会丢失!!!\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0; //跳出循环\n\t\t\tprintf(\"即将退出系统。\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\thelp();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tadd(&list);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdelete (&list);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmenu_inquire(&list);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevise(&list);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\trandom_menu(&list);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tempty(&list);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsave(&list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n\tsystem(\"pause\");\n}\nvoid help() //二级菜单_帮助菜单\n{\n\tsystem(\"cls\");\n\tprintf(\"\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tcolor(15);\n\tprintf(\"|使用帮助：\\n\");\n\tprintf(\"|1、本菜品信息系统可供用户自行修改内容\\n\");\n\tprintf(\"|2、因为考虑到不同饭店有同样名称的菜品，本系统允许菜品名称有重复\\n\");\n\tprintf(\"|3、请勿输入错误信息，以免造成程序出错\\n\");\n\tprintf(\"|4、关闭系统前记得保存！否则数据会丢失\\n\");\n\tprintf(\"|5、有bug联系1934009145@qq.com\\n\");\n\tprintf(\"|6、github地址:github.com/qxchuckle/Dishes-Management-System\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tprintf(\"\\n\");\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid menu_inquire(List *list) //二级菜单_查询菜单\n{\n\tint options, z = 1;\n\tList *p = list;\t\t\t//方便传结构体指针\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！无法查询！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn; //为空结束函数\n\t}\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、查询全部菜品信息\\n\");\n\t\tprintf(\"|2、按菜名查询菜品信息\\n\");\n\t\tprintf(\"|3、查询饭店或食堂的全部菜品信息\\n\");\n\t\tprintf(\"|4、查询某价格以下的全部菜品\\n\");\n\t\tprintf(\"|5、查询某评分以上的全部菜品\\n\");\n\t\tprintf(\"|6、查询某饭店或食堂的平均价格、评分和价格区间占比\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_all(p);\n\t\t\treturn;\n\t\tcase 2:\n\t\t\tinquire_one(p);\n\t\t\treturn;\n\t\tcase 3:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_restaurant(p);\n\t\t\treturn;\n\t\tcase 4:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_price(p);\n\t\t\treturn;\n\t\tcase 5:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_fraction(p);\n\t\t\treturn;\n\t\tcase 6:\n\t\t\taverage_percentage(p);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t}\n\t}\n}\nint menu_sort(List *list) //三级菜单_排序方法\n{\n\tint options, z = 1, n = 1;\n\tList *p = list;\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、按价格从低到高排序\\n\");\n\t\tprintf(\"|2、按价格从高到低排序\\n\");\n\t\tprintf(\"|3、按评分从高到低排序\\n\");\n\t\tprintf(\"|4、不排序\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\treturn z;\n\t\tcase 1:\n\t\t\tsort_ascending(p);\n\t\t\treturn n;\n\t\tcase 2:\n\t\t\tsort_descending(p);\n\t\t\treturn n;\n\t\tcase 3:\n\t\t\tsort_score(p);\n\t\t\treturn n;\n\t\tcase 4:\n\t\t\treturn n;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n}\n//对节点操作\nvoid add(List *list) //添加节点\n{\n\tfloat k = 1;\n\tint n = 0, i = 0;\n\tNode *last = list->head;\n\tNode *p1 = (Node *)malloc(sizeof(Node)), *p; //给节点分配空间\n\tp1->next = NULL;\n\tsystem(\"cls\");\n\tputs(\"开始录入菜品：\\n----------------\\n\");\n\tputs(\"请输入菜品名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->name, SIZE1);\n\t} while (strlen(p1->name) == 0);\n\tputs(\"请输入菜品所属饭店or食堂名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->restaurant, SIZE1);\n\t} while (strlen(p1->restaurant) == 0);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(p1->name, p->name) || strcmp(p1->restaurant, p->restaurant)))\n\t\t{\n\t\t\tcolor(12);\n\t\t\tprintf(\"该饭店/食堂内已存在同名菜品！\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"请输入菜品的价格：\");\n\tp1->price = get_float();\n\tputs(\"请输入0-10的整数对菜品进行评分：\");\n\tdo\n\t{\n\t\tn = get_int();\n\t\tif (n >= 0 && n <= 10) //判断评分是否是0-10\n\t\t{\n\t\t\tp1->fraction = n;\n\t\t\ti = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor(12);\n\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (!i);\n\tputs(\"请对菜品进行评价：\");\n\tdo\n\t{\n\t\ts_gets(p1->comment, SIZE2);\n\t} while (strlen(p1->comment) == 0);\n\tif (last) //如果last有值，则说明head已指向链表第一个节点\n\t{\n\t\twhile (last->next)\n\t\t{\n\t\t\tlast = last->next; //last始终指向最后一个节点\n\t\t}\n\t\tlast->next = p1; //在最后一个节点后面再加一个节点\n\t}\n\telse\n\t{\n\t\tlist->head = p1; //如果last为NULL，则要将head指向第一个节点\n\t}\n\tcolor(11);\n\tputs(\"录入成功！\");\n\tsystem(\"pause\");\n}\nvoid delete (List *list) //删除节点\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL)\n\t{ //判断链表是否为空\n\t\tprintf(\"还未存入任何菜品！删除失败！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入你要删除的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next)\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //遍历链表\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要修改的节点\n\t\t{\n\t\t\tn++;   //记录找到了\n\t\t\tif (q) //判断找到的是不是第一个节点\n\t\t\t{\n\t\t\t\tq->next = p->next; //让该节点的前一个节点都next指向后一个节点\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlist->head = p->next; //让head的next指向后一个节点\n\t\t\t}\n\t\t}\n\t}\n\tif (!n)\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n删除成功%d道菜。\\n\", n);\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid revise(List *list) //修改节点\n{\n\tfloat k = 1;\n\tint n = 0, m = 0, i = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tprintf(\"还未存入任何菜品！无法修改！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入要修改的菜品的名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要删除的节点\n\t\t{\n\t\t\tn++; //记录找到\n\t\t\tprintf(\"\\n原来的菜品信息:\\n\");\n\t\t\tprintf(\"|菜名:%s\\n\", p->name);\n\t\t\tprintf(\"|所属:%s\\n\", p->restaurant);\n\t\t\tprintf(\"|价格:%.2f\\n\", p->price);\n\t\t\tprintf(\"|评分:%d\\n\", p->fraction);\n\t\t\tprintf(\"|评价:%s\\n\", p->comment);\n\t\t\tprintf(\"\\n\");\n\t\t\tputs(\"请修改菜品的价格：\");\n\t\t\tp->price = get_float();\n\t\t\tputs(\"请输入0-10的整数以修改菜品的评分：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\tm = get_int();\n\t\t\t\tif (m >= 0 && m <= 10)\n\t\t\t\t{\n\t\t\t\t\tp->fraction = m;\n\t\t\t\t\ti = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolor(12);\n\t\t\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\t\t\tcolor(15);\n\t\t\t\t}\n\t\t\t} while (!i);\n\t\t\tputs(\"请修改对菜品的评价：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts_gets(p->comment, SIZE2);\n\t\t\t} while (strlen(p->comment) == 0);\n\t\t}\n\t}\n\tif (n)\n\t{\n\t\tprintf(\"\\n修改完成。\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\n//安全输入\nchar *s_gets(char *m, int n) //安全输入字符\n{\n\tchar *p;\n\tchar *find;\n\tp = fgets(m, n, stdin);\n\tif (p)\n\t{\n\t\tfind = strchr(m, '\\n'); //查找换行符\n\t\tif (find)\t\t\t\t//如果地址不是NULL\n\t\t\t*find = '\\0';\t\t//在此处放一个空字符\n\t\telse\n\t\t\twhile (getchar() != '\\n')\n\t\t\t\tcontinue;\n\t}\n\treturn p;\n}\nint get_int() //安全输入int型\n{\n\tint n;\n\tchar ch;\n\twhile (scanf(\"%d%*c\", &n) != 1)\n\t{\n\t\twhile ((ch = getchar()) != '\\n')\n\t\t\tputchar(ch);\n\t\tcolor(4);\n\t\tprintf(\" 不是一个正整数！\\n请您重新输入：\\n\");\n\t\tcolor(15);\n\t}\n\treturn n;\n}\nfloat get_float() //安全输入float型\n{\n\tfloat n = 1;\n\tchar ch;\n\tdo\n\t{\n\t\tif (n <= 0)\n\t\t{ //用户输入不是正数输出提示\n\t\t\tcolor(12);\n\t\t\tputs(\"请重新输入一个正数！\");\n\t\t\tcolor(15);\n\t\t}\n\t\twhile (scanf(\"%f%*c\", &n) != 1)\n\t\t{\n\t\t\twhile ((ch = getchar()) != '\\n')\n\t\t\t\tputchar(ch);\n\t\t\tcolor(12);\n\t\t\tprintf(\" 不是一个正数！\\n请您重新输入：\\n\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (n <= 0);\n\treturn n;\n}\n//链表的输出和操作\nvoid inquire_all(List *list) //输出链表全部节点\n{\n\tNode *p;\n\tint n = 1;\n\tsystem(\"cls\");\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tprintf(\"\\n第%d道菜:\", n);\n\t\toutput(p);\n\t\tn++;\n\t}\n\tcolor(11);\n\tprintf(\"\\n所有菜品查询完毕\\n\");\n\tsystem(\"pause\");\n}\nvoid inquire_one(List *list) //输出指定菜名\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->name)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_restaurant(List *list) //输出指定饭店所有菜品\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_price(List *list) //输出一定价格以下的菜品(这功能。。贫穷)\n{\n\tint n = 0;\n\tfloat money, k = 1;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入封顶价格：\");\n\tmoney = get_float();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->price <= money) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_fraction(List *list) //输出一定评分以上的菜品\n{\n\tint n = 0;\n\tint score;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入最低评分：\");\n\tscore = get_int();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->fraction >= score) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid average_percentage(List *list) //查询某饭店或食堂的平均价格和评分\n{\n\tint n = 0;\n\tfloat sum1 = 0, sum2 = 0, b[5] = {0};\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要查的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\tsum1 += p->price;\t //累加价格\n\t\t\tsum2 += p->fraction; //累加评分\n\t\t\tif (p->price <= 5)\n\t\t\t{\n\t\t\t\tb[0]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (p->price <= 10)\n\t\t\t\t{\n\t\t\t\t\tb[1]++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p->price <= 15)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[2]++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (p->price < 20)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[3]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[4]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tn++; //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tif (n)\n\t{\n\t\tprintf(\"该饭店/食堂的一共有%d道菜\\n平均价格是：%.2f\\t平均评分是：%.2f\\n\", n, sum1 / n, sum2 / n);\n\t\tprintf(\"其中：\\n0~5元占:%.1f%%\\n5~10元占:%.1f%%\\n10~15元占:%.1f%%\\n\", b[0] / n * 100, b[1] / n * 100, b[2] / n * 100);\n\t\tprintf(\"15~20元占:%.1f%%\\n20元以上占:%.1f%%\\n\\n\", b[3] / n * 100, b[4] / n * 100);\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"无该饭店或食堂！\\n\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid output(Node *p) //方便输出\n{\n\tprintf(\"\\n|菜名:%s\\n\", p->name);\n\tprintf(\"|所属:%s\\n\", p->restaurant);\n\tprintf(\"|价格:%.2f\\n\", p->price);\n\tprintf(\"|评分:%d\\n\", p->fraction);\n\tprintf(\"|评价:%s\\n\", p->comment);\n}\nvoid random_menu(List *list) //随机输出一道菜\n{\n\tsystem(\"cls\");\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tList *q = list;\n\tNode *p = list->head;\n\tint n = random_number(q), i = 1; //将随机出来的数赋予n，并初始i等于第一道菜，判断数字是否相等，即可找到那个随机出来的菜\n\twhile (p != NULL)\n\t{\n\n\t\tif (i == n) //借助随机数来随机输出菜\n\t\t{\n\t\t\toutput(p);\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t\tp = p->next;\n\t}\n}\nvoid empty(List *list) //清空链表\n{\n\tNode *p, *q;\n\tint n;\n\tsystem(\"cls\");\n\tcolor(12);\n\tprintf(\"此操作将清空所有数据！\\n输入 1 继续，输入 0 取消：\\n\");\n\tdo\n\t{\n\t\tn = get_int();\n\t} while (!(n == 0 || n == 1));\n\tif (n == 1)\n\t{\n\t\tfor (p = list->head; p; p = q) //遍历链表\n\t\t{\n\t\t\tq = p->next;\n\t\t\tfree(p);\n\t\t}\n\t\tlist->head = NULL;\n\t\tprintf(\"清除完成！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n}\n//文件操作\nvoid save(List *list) //保存\n{\n\tif (list->head == NULL)\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！保存为空！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tNode *p = list->head;\n\tFILE *fp = fopen(\"Menu.txt\", \"w\");\n\tif (fp)\n\t{\n\t\twhile (p)\n\t\t{\n\t\t\tfprintf(fp, \"\\n%s %s %0.2f %d %s\", p->name, p->restaurant, p->price, p->fraction, p->comment);\n\t\t\tp = p->next;\n\t\t}\n\t\tfclose(fp);\n\t\tcolor(11);\n\t\tprintf(\"\\n保存成功\\n\");\n\t\tsystem(\"pause\");\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"保存失败，请自查或联系作者\");\n\t}\n}\nvoid read_txt(List *list) //读取文件_初始链表\n{\n\tint i = 1;\n\tNode *last;\n\tNode *p1;\n\tint a = 1;\n\tchar f[5];\n\tFILE *fp = fopen(\"Menu.txt\", \"r\");\n\tfgets(f, 10, fp); //读取第一行，并进入下一行，防止bug\n\twhile (!feof(fp)) //当读取到文件结束符跳出循环结束读取\n\t{\n\t\tlast = list->head;\n\t\tp1 = (Node *)malloc(sizeof(Node));\n\t\tp1->next = NULL;\n\t\tfscanf(fp, \"%s%s%f%d%s\", p1->name, p1->restaurant, &p1->price, &p1->fraction, p1->comment);\n\t\tif (last)\n\t\t{\n\t\t\twhile (last->next)\n\t\t\t{\n\t\t\t\tlast = last->next;\n\t\t\t}\n\t\t\tlast->next = p1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlist->head = p1;\n\t\t}\n\t}\n\tfclose(fp);\n}\n//单链表的冒泡排序，这指来指去，作者一口气写完到断气的，不想加注释了，应该会有更好的算法，咕咕咕，以后优化\nvoid sort_ascending(List *list) //菜品按价格从低到高排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price > list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_descending(List *list) //菜品按价格从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price < list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_score(List *list) //菜品按评分从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->fraction < list_swap.pc->fraction)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nint calculate(List *list) //计算出单链表的节点个数\n{\n\tint n = 0;\n\tNode *p = list->head;\n\twhile (p->next != NULL)\n\t{\n\t\tn++;\n\t\tp = p->next;\n\t}\n\treturn n + 1;\n}\nvoid swap1(List *list, List *list_swap) //单链表冒泡排序的算法块1\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pb->next = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\telse\n\t{\n\t\tlist->head = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\tlist_swap->pb = list_swap->pc;\n\tlist_swap->pc = list_swap->pa->next;\n}\nvoid swap2(List *list, List *list_swap) //单链表冒泡排序的算法块2\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list_swap->pb->next;\n\t}\n\telse\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list->head;\n\t}\n}\n//其他\nint random_number(List *list) //随机生成不大于节点数的整数\n{\n\tint n = 0, m = 0, sum = 1, i = 0;\n\tList *q = list;\n\tsrand((unsigned)time(NULL) * 12);\n\tm = calculate(q);\n\ti = m;\n\twhile (m > 0)\n\t{\n\t\tsum = sum * 10;\n\t\tm = m / 10;\n\t}\n\twhile (1)\n\t{\n\t\tn = rand() % sum;\n\t\tif (n <= i && n > 0)\n\t\t{\n\t\t\ti = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\nvoid color(int a) //控制台文本颜色\n{\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), a); //更改控制台文字颜色\n}\n\n```\n***\n\n# 部分功能截图\n**主菜单**\n<div><img src=https://cdn.chuckle.top/images/6-1.webp width=\"50%\" height=\"50%\"></div>\n\n**查找功能**\n<div><img src=https://cdn.chuckle.top/images/6-2.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.chuckle.top/images/6-5.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.chuckle.top/images/6-6.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=https://cdn.chuckle.top/images/6-7.webp width=\"50%\" height=\"50%\"></div>\n\n**排序**\n<div><img src=https://cdn.chuckle.top/images/6-3.webp width=\"50%\" height=\"50%\"></div>\n\n**修改功能**\n<div><img src=https://cdn.chuckle.top/images/6-4.webp width=\"45%\" height=\"45%\"></div>\n\n***\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["C语言"],"categories":["项目"]},{"title":"C语言学习笔记","url":"/article/13675369.html","content":"\n# 整数运算\n两个整数运算结果也只能是整数  \na+=5等价于a=a+5  \na*=b+5等价于a=a*(b+5)  \na++等a+=1等a=a+1  \na++是a加1以前的值，++a是a加1后的值  \n运算符优先级：算数>关系>赋值，判断是否相等的优先级比大于小于低\n***\n# 所表达的数的范围\nchar< short<int< float<double\n***\n# sizeof()\nsizeof()是一个运算符,给出某个类型或变量在内存中所占据的字节数  \nsizeof()是静态运算符,它的结果在编译时刻就决定了，不要在 sizeof的括号里做运算,这些运算不会做的\n***\n# unsigned\nunsigned：如果一个字面量常数想要表达自己是 unsigned,可以在后面加u或U，255U用l或L表示long(long)  \nunsigned的初衷并非扩展数能表达的范围,而是为了做纯二进制运算,主要是为了移位\n***\n# 整数的输入输出\n只有两种形式:int或 long long  \n%d: int  \n%u: unsigned  \n%ld: longlong  \n%lu: unsigned long long\n***\n# 选搔整数类型\n为什么整数要有那么多种?为了准确表达内存,做底层程序的需要  \n没有特殊需要,就选int  \n现在的CPU的字长普遍是32位或64位,一次内存该写就是个int,一次计算也是一个int,选择更短的类型不会更快,甚至可能更慢  \n现代的编译器一般会设计内存对齐,所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)\n***\nunsigned与否只是输出的不同,内部计算是一样的  \nprintf输出inf表示超过范围的浮点数:±∞  \nprint输出nan表示不存在的浮点数  \n带小数点的字面量是 double而非 float  \nfloat需要用或F后綴来表明身份  \n1.234f\n***\n判断两个浮点数是否相等可能失败  \nfabs(fl-2)< le-2//两个浮点数相减的绝对值小于一个很小的数，可认为两个浮点数相等\n***\n# 选浮点类型\n如果没有特殊需要,只使用 double  \n现代CPU能直接对 double做硬件运算,性能不会比float差,在64位的机器上,数据存儲的速度也不比float慢\n***\n# 自动类型转换\n当运算符的两边出现不一致的类型时,会自动转换成較大的类型  \n大的意思是能表达的数的范围更大  \nchar——> short——>int——>long——>long long  \nint——> float——> double  \n对于 printf,任何小于int的类型会被转换成int，float会被转换成 double  \n但是scanf不会,要输入short,需要%hd\n***\n# 强制类型转换\n要把一个量强制转换成另一个类型(通常是較小的类型),需要:(类型)值  \n比如：  \n(int)10.2  \n(short)32  \n注意这时候的安全性,小的变量不总能表达大的量  \n(short)32768  \n只是从那个变量计算出了一个新的类型的值,它并不改变那个变量,无论是值还是类型都不改变  \n强制类型转换的优先级高于四则运算\n***\n# 逻辑运算符优先级:\n!>&&>||\n***\n# 短路\n逻辑运算是自左向右进行的,如果左边的结果已经能够决定结果了,就不会做右边的计算  \na==6&&b==1  \na==6&&b+=1  \n对于&&,左边是 false时就不做右边了  \n对于‖,左边是true时就不做右边了  \n***\n# tip1\n不要把赋值,包括复合赋值组合进表达式!  \n一个代码内有重复相似段是程序质量不良的表现  \n函数是一块代,接收零个或多个参数做一件事情,并返回零个或一个值\n***\n# 数组的大小\nsizeof给出整个数组所占据的内容的大小,单位是字节  \nsizeof(a)/sizeof(a[0])  \nsizeof(a[0])给出数组中单个元素的大小,于是相除就得到了数组的单元个数  \n这样的代码,一旦修改数组中初始的数据,不需要修改遍历的代吗\n***\n# 数组的操作\n遍历数组：通常都是使用for循环,让循环变量i从0到<数组的长度,这样循环体内最大的正好是数组最大的有效下标  \n数组作为函数的参数时:不能在[]中给出数组的大小，不能再利用 sizeof来计算数组的元素个数!  \n数组作为函数参数时,往往必再用另一个参数来传入数组的大小\n# 作为参数的指针\nvoid f(int * p)  \n在被调用的时候得到了某个变量的地址  \nint i=O; f(&i)  \n在函数里面可以通过这个指针访问外面的这个  \n函数参数表中的数组实际上是指针  \nsizeof(a)==sizeof(int *)  \n但是可以用数组的运算符进行运算\n***\n# 指针是const\n表示一旦得到了某个变量的地址,不能再指向其他变量  \nint *const q=&i;//q是 const  \n*q=26;//OK  \nq++; //ERROR\n***\n# 所指是 const\n表示不能通过这个指针去修改那个变量(并不能使得那个变量成为 const)  \nconst int *p=&i  \n*p= 26; //ERROR!  \ni=26;//OK  \nP=&i;//OK\n***\n# const\nlnt i  \nconst int* p1 =&i  \nint const* p2=&i  \nint *const p3=&i  \n判断哪个被const了的标志是const在*的前面还是后面  \n*const p指针不许动  \nconst *p指针不许动变量\n***\n## 转换\n总是可以把一个非 const的值转換成 const的  \nvoid f(const int* x)  \nint a =15:  \nf(&a);//ok  \nconst int b = a  \nf(&b);//ok  \nb =a+1: // Error  \n当要传递的参数的类型比地址大的时候,这是常用的手段:既能用比較少的字节数传递值给参数,又能避免函数对外面的变量的修改\n***\n## const数组\nconst int a[]={1,2,3,4,5,6};  \n数组变量已经是 const的指针了,这里的 const表明数组的每个单元都是 const Int所以必须通过初始化进行赋值\n***\n## 保护数组值\n因为把数组传入函数时传递的是地址,所以那个函数内部可以修改数组的值  \n为了保护数组不被函数破坏,可以设置参数为 const  \nint sum(const int a[], int length);\n***\n# 指针\nint *p ：指针加一p+1是指加上一个sizeof(int)，将指针移到下一个单元  \nint *p=a[];  \n*p -->a[0]  \n*(p+1)-->a[1]  \n*(p++)可以遍历数组\n***\n给一个指针加|表示要让指针指向下一个变量  \nint a[l0]  \nint *p= a  \n*(p+1)-->a[1]  \n如果指针不是指向一片连分配的空间,如数组,则这种运算没有意义  \n*(p+n)<-->a[n]  \n*p*q两个指针相减p-q，等于q加多少个单元等于p\n***\n*p++  \n取出p所指的那个数据来,完事之后顺便把移到下一个位置去  \n*的优先级然高,但是没有++高  \n常用于数组类的连续空间操作  \n在某些CPU上,这可以直接被翻译成一条汇编指令\n\n指针乘除无意义\n***\n## 指针遍历数组方法 \n```\n*p a[10]\np=a\nfor(i=0;i<sizeof(a)/sizeof(a[0]); i++ ){\nprintf(\"%d\\n\", acri[i]);\n}  \na[9]=-1//在数组末尾放入一个特殊的东西\nwhile(*p!=-1){\nprintf(\"%d\\n\",*p++);\n}\n```\n***\n## 指针比較\n<,<=,==,>,>=,!=都可以对指针做  \n比较它们在内存中的地址  \n数组中的单元的地址肯定是线性从小到大递增的\n***\n## 0地址\n当然你的内存中有0地址,但是0地址通常是个不能随便碰的地址  \n所以你的指针不应该具有0值  \n\n因此可以用0地址来表示特殊的事情:  \n1返回的指针是无效的  \n2指针没有被真正初始化(先初始化为0)  \n\nNULL（必须是大写）是一个预定定义的符号,表示0地址  \n有的编译器不愿意你用0来表示0地址\n***\n## 指针的类型\n无论指向什么类型,所有的指针的大小都是一样的,因为都是地址  \n但是指向不同类型的指针是不能直接互相赋值的  \n这是为了避免用错指针\n## 指针的类型转换\nvoid*表示不知道指向什么东西的指针  \n计算时与char*相同(但不相通)\n\n指针也可以转换类型  \nint*p =&i  \nvoid*p<-->(void *)p  \n这并没有改变p所指的变量的类型,而是让后人用不同的眼光通过p看它所指的变量  \n我不再当你是int,我认为你就是个void!\n***\n## 用指针来做什么\n需要传入較大的数据时用作参数  \n传入数组后对数组做操作  \n函数返回不止一个结果是  \n需要用函数来修改不止一个变量  \n动态申请的内存\n***\n# 内存操作\n## malloc(跟系统要一块内存)\n```\n#include <stdlib. h>\nvoid*malloc(size_t size)\n//向malloc申请的空间的大小是以字节为单位返回的结果是void,需要类型转换为自己需要的类型\n(int *)malloc(n*sizeof(int))\n```\n如果申请失敗则返回0,或者叫做NULL\n***\n## free()\n把申请得来的空间还给“系统”  \n申请过的空间,最终都应该要还  \n只能还申请来的空间的首地址\n## free常见问题\n申请了没free—>长时间运行内存逐漸下降  \n新手:忘了  \n老手:找不到合的free的时机  \nfree过了再free  \n地址变过了,直接去free\n***\n# 字符串\nchar a[]={'h','a','l','l','o','!'}//字符数组  \nchar a[]={'h','a','l','l','o','!','\\0'}//字符串\n***\n以0(整数0)结尾的一串字符  \n0或'\\0'是一样的,但是和0不同  \n0标志字符串的结束,但它不是字符串的一部分  \n计算字符串长度的时候不包含这个0  \n字符串以数组的形式存在,以数组或指针的形式访问  \n更多的是以指针的形式  \nstring.h里有很多处理字符串的函数\n***\n```\nchar*str=\"Hello\"\nchar word[]=\"Hello\"\nchar linel[10]=\"Hello\"\n```\n***\n## 字符串常量\nChar* s=\"Hello, world\"  \n●s是一个指针,初始化为指向一个字符串常量 \n●由于这个常量所在的地方,所以实际上s是 const  \nchar*s,但是由于历史的原因,编译器接受不带const的写法  \n●但是试图对s所指的字符串做写入会导致严重的后果\n***\nchar S[]=\"Hello, world\"//这个字符串就在我这里  \nChar* s=\"Hello, world\"//指向某个地方的字符串  \n数组:这个字符串在这里(作为本地变量,空间自动被回收)  \n指针:这个字符串不知道在哪里(处理参数,动态分配空间)  \n如果要构造一个字符串一>数组  \n如果要处理一个字符串一>指针\n***\n## 字符串输入输出\n```\nchar string[8];\nscanf(\"%s\", string);\nprintf(\"%s\", string);\n//scanf读入一个単词(到空格、tab或回车为止)\n//scanf是不安全的,因为不知道要该入的内容的长度\nscanf(\"%7s\", string)\n//在%和s之间的数字表示最多允许该入的字符的数量,这个数字应该比数组的大小小\n```\n***\n## 空字符串\n```\nchar buffer[100]=\"\";\n//这是一个空的字符串, buffer[O]==\"\\0\";\nchar buffer[]=\"\";\n//这个数组的长度只有1\n```\n***\n## 复制一个字符串\n```\nchar*dst=(char*)malloc(strlen(src)+1)\nstrcpy(dst, src)\n```\n***\n# 枚挙\n枚挙是一种用戶定义的数据类型,它用关键字enum以如下语法来声明  \nenum枚挙类型名字{名字0,……,名字n};  \n\n枚挙类型名字通常并不真的使用,要用的是在大括号里的名字,因为它们就是就是常量符号,它们的类型是int,值则依次从0到n。如：  \nenum colors {red, yellow, green};  \n就创建了三个常量,red的值是0, yellow是1,而 green是2。  \n当需要一些可以排列起来的常量值时,定义枚举的意义就是给了这些常量值名字。\n>声明枚挙量的时候可以指定值\n>enum COLOR {RED=1, YELLOW, GREEN =5};\n\n***\n\n# 结构\n## 声明结构的形式\n```\nstruct point{\nint X;\nInt y;\n};\nstruct point p1, p2\n//pl和p2都是 point里面有x和y的值\n\nstruct {\nInt x;\nint y;\n}pl, p2;\n//pl和p2都是一种无名结构,里面有x和y\n\nstruct point {\nInt x;\nint y;\n}pl, p2;\n//pI和p2都是point, 里面有x和y的值t\n```\n>和本地变量一样,在函数内部声明的结构类型只能在函数内部使用  \n>所以通常在函数外部声明结构类型,这样就可以被多个函数所使用了\n\n***\n## 结构指针\n和数组不同,结构变量的名字并不是结构变量的地址,必须使用&运算符\n```\nstruct date*pdate= &today;\n```\n***\n## 结构作为函数参数\n```\nint numberofdays(struct date d)\n```\n整个结构可以作为参数的值传入函数  \n这时候是在函数内新建一个结构变量,并复制调用者的结构的值  \n也可以返回一个结构  \n这与数组完全不同\n***\n## 指向结构的指针\n```\nstruct date {\nint month;\nint day;\nint yeari;\n}myday;\nstruct date *p =&myday;\n(*p).month 12;\np->zmonth 12;\n//用->表示指针所指的结构变量中的成员\n```\n***\n# 全局变量初始化\n没有做初始化的全局变量会得到0值  \n指针会得到NULL值  \n只能用编译时刻已知的值来初始化全局变量  \n它们的初始化发生在main函数之前  \n全局变量不应该和另一个全局变量有联系  \n同名变量，本地变量优先级高于全局变量，即本地变量隐藏了全局变量\n***\n# 静态本地变量（全局生存期，本地作用域）\n在本地变量定义时加上 static修饰符就成为静态本地变量  \n当函数离开的时候,静态本地变量会銖存在并保持其值  \n静态本地变量的初始化只会在第一次进入这个函数时做（只做一次初始化）,以后进入函数时会保持上次离开时的值  \n静态本地变量实际上是特殊的全局变量，它们位于相同的内存区域  \n静态本地变量具有全局的生存期,函数内的局部作用域  \nstatic在这里的意思是局部作用域(本地可访问)\n>不要使用全局变量来在函数间传递参数和结果  \n>尽量避免使用全局变量  \n>丰田汽车的案子  \n>使用全局变量和静态本地变量的函数是线程不安全的  \n\n***\n# 返回指针的函数\n返回本地变量的地址是危险的  \n返回全局变量或静态本地变量的地址是安全的  \n返回在函数内 malloc的内存是安全的,但是容易造成问题  \n最好的做法是返回传入的指针\n***\n# 编译预处理指令\n#开头的是编译预处理指令  \n它们不是C语言的成分,但是C语言程序离不开它们\n***\n## #define(纯文本替换)\n#define用来定义一个宏  \n#define<名字><值>  \n注意没有结尾的分号,因为不是C的语句  \n名字必颁是一个单词,值可以是各种东西  \n在C语言的编译器开始编译之前,编译预处理程序  \n(cpp)会把程序中的名字换成值  \n完全的文本替换  \nacc-save-temps\n***\n## 宏\n如果一个宏的值中有其他的宏的名字,也是会被替换的  \n如果一个宏的值超过一行,最后一行之前的行末需要加  \\   \n宏的值后面出现的注释不会被当作宏的值的一部分\n***\n### 预定义的宏\n```\n_LINE_\n_FILE_\n_DATE_\n_TIME_\n_STDC_\n```\n### 带参数的宏\n```\n#define cube(x) ((x)*(x)*(x))\n```\n在大型程序的代吗中使用非常普遍  \n可以非常复杂,如“产生”函数:在#和##这两个运算符的帮助下  \n存在中西方文化差异  \n部分宏会被inline函数替代\n***\n# 变量的声明\nint i;是变量的定义  \nextern int i;是变量的声明\n***\n# 声明和定义\n声明是不产生代码的东西  \n函数原型  \n变量声明  \n结构声明  \n宏声明  \n枚挙声明  \n类型声明  \ninline函数  \n定义是产生代码的东西  \n头文件放声明是规则\n***\n# 重复声明\n同一个编译单元里,同名的结构不能被重复声明  \n如果你的头文件里有结构的声明,很难这个头文件不会在一个编译单元里被#include多次，所以需要\"标准头文件结构\"\n***\n# 标准头文件结构(宏的if)\n```\n#ifndef _LIST_HEAD_\n#define _LIST_HEAD_\n#include \"node.h\"\ntypedef struct _list{\n    Node* head\n    Node* tail\n}List\n#endif\n//运用条件编译和宏,保证这个头文件在一个编译单元中只会被#include一次\n#pragma once//也能起到相同的作用,但是不是所有的编译器都支持\n```\n\n# 链表\n>0建一个node结构  \n>1首选有个node结构(作为节点)，结构里有int(或者其他类型)变量去存数据，还有个同样结构的*next(next要等于下一个节点)（套娃）  \n>2读入数据，并新建一个node结构p，要让一个node结构head始终等于链表第一个节点  \n>3要有一个node结构last，每次要让last从head开始，直到last->next是空的，然后让next等于新的p结构（这样就链起来了）  \n>4每次读入新的数据，就新建一个p，然后让last从head开始遍历链表，直到last->next是空的，然后然后让next等于新的p结构  \n\n**要在函数内改变指针的指向，就要传指针的指针进去**\n***\n## 遍历链表\n```\nfor(p=list.head; p; p=p->next){}\n//单用一个指针p可以遍历链表\n```\n\n但要让删除链表中某一结点，需要另一个指针q，q一开始为null，后来始终指向p前一个节点  \n当p找到了要删除的节点，就让q->next等于p->next，然后free(p)  \nfor(q=null，p=list.head; p; q=p，p=p->next){}  \n当然还要判断链表的第一个元素是不是我们要删除的  \n如果是，就不能让q->next等于p->next，因为q一开始是NULL  \n我们应该让head->next等于p->next，然后free(p)  \n>\".\"一般情况下读作\"的”。  \n>\"->\"一般读作\"指向的结构体的\"。  \n\n***\n## 清除整个链表\n```\nfor(p=head;p;p=q){\n     q=p->next;\n     free(p)\n}\n//先让指针p等于head，让q始终指向p的下一个节点，然后free(p),再让p=q，p去等于下一个节点\n```\n\n***\n# main()\nmain(成为C语言的入口函数其实和C语言本身无关,你的代码是被一小段叫做启动代的程序所调用的,它需要叫做main的地方)  \n操作系统把你的可执行程序装载到内存里,启动运行,然后调用你的main函数  \n在不同操作系统，入口函数可能不是main()\n***","tags":["C语言"],"categories":["学习笔记"]},{"title":"博客搜索挂了解决方法","url":"/article/f8c79a1b.html","content":">省流助手：删除所有local-search.js中下面这行代码\n>window.pjax && window.pjax.refresh($resultContent)\n\n# 遇到的问题\n我使用的是本地搜索，local-search，装好后一直正常使用，也没去动过配置\n前天捣鼓着博客，突然发现博客部署到github上后搜索挂了\n<img src=https://cdn.chuckle.top/images/4-2.webp width=\"60%\" height=\"60%\">\n一直卡在数据库加载中\n\n但是，部署在本地，搜索却一切正常\n<img src=https://cdn.chuckle.top/images/4-3.webp width=\"60%\" height=\"60%\">\n尝试过重装插件，清除浏览器缓存，search.xml改为json，但过一会又挂了\n\n看网上也有不少人遇到这种问题，却找不到解决办法\n\n***\n\n# 解决过程\nlocal-search会请求生成在本地的search.xml，也就是数据库加载中里的“数据库”\n\n部署在本地时正常请求\n<img src=https://cdn.chuckle.top/images/4-8.webp width=\"80%\" height=\"80%\">\n而部署在github时没有请求\n<img src=https://cdn.chuckle.top/images/4-9.webp width=\"65%\" height=\"65%\">\n直接访问search.xml正常，不是search.xml的问题\n<img src=https://cdn.chuckle.top/images/4-5.webp width=\"60%\" height=\"60%\">\n查看报错，看起来是这个js的问题\n<img src=https://cdn.chuckle.top/images/4-6.webp width=\"60%\" height=\"60%\">\n本地找到local-search.js，这三个代码都一样\n<img src=https://cdn.chuckle.top/images/4-7.webp width=\"60%\" height=\"60%\">\njs中只有一处pjax报错\n<img src=https://cdn.chuckle.top/images/4-10.webp width=\"60%\" height=\"60%\">\n类型“Window & typeof globalThis”上不存在属性“pjax”。ts(2339)  \n\n\n看不懂这种报错，但问题多半就是这行代码导致的，查看整个js后，尝试删除此行\n```\nwindow.pjax && window.pjax.refresh($resultContent)\n```\n删除后，搜索挂了的问题解决，博客正常请求search.xml\n<img src=https://cdn.chuckle.top/images/4-8.webp width=\"70%\" height=\"70%\">\n\n但点击搜索结果后pjax失效，具体表现是aplayer停止播放音乐\n\n看来是pjax的bug，不过感知不强，其余地方的pjax仍然生效\n\n暂时先这样，以后找到更好的解决办法再更新\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Hexo博客的基本操作","url":"/article/aa2a7b7e.html","content":"\n> **Hexo官方文档:**[Hexo](https://hexo.io/zh-cn/docs)\n\n# Hexo操作\n\n## 指令\n\n```js 新建文章，在blog\\source\\_posts\nhexo new post (文章名称)\n```\n```js 新建页面，在blog\\source\nhexo new page (页面名称)\n```\n```js 清除缓存文件 (db.json) 和已生成的静态文件 (public)\nhexo clean\n```\n```js 生成静态文件\nhexo g\n```\n```js 启动服务器，访问网址:http://localhost:4000\nhexo s\n```\n```js 部署网站\nhexo d\n```\n```js hexo三连,四连\nhexo cl && hexo g && hexo s\nhexo cl && hexo g && gulp && hexo d\n```\n```js push三连\ngit add .\ngit commit -m \"github action update\"\ngit push origin master\n```\n<br>\n\n## 文章操作\n\n>**Markdown 教程**\n>[菜鸟教程](https://www.runoob.com/markdown/md-tutorial.html)\n>[官网--Markdown基本语法](http://markdown.p2hp.com/basic-syntax/)\n\n\n> **blog\\scaffolds中修改三种文章模板**\n\n>*斜体文本* &emsp;\\*斜体文本\\* \n>**粗体文本** &emsp;\\*\\*粗体文本\\*\\*\n>***粗斜体文本*** &emsp;\\*\\*\\*粗斜体文本\\*\\*\\* \n>~~横线删除~~ &emsp;\\~\\~横线删除\\~\\~ \n\n>***水平分割线\n\n```html 文字蓝链 \n文字内容[tittle](https://*******)\n```\n```html 文章中自定义文本，size文字大小，face字体，color颜色，&emsp空格\n<font size=\"2\" face=\"verdana\" color=\"blue\" >&emsp;这是一个文本</font>\n\n```\n```html 插入自定义图片,\n\n<div align=left><img src=1.png width=\"25%\" height=\"25%\"></div>\n\n<div align=left><img src=1.png><img src=2.png></div>\n\n![文本](图片地址 \"鼠标悬停弹出文本提示\")\n```\n***\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"测试用文章","url":"/article/d87f7e0c.html","content":"\n米歇潘在不经意间这样说过，生命是一条艰险的峡谷，只有勇敢的人才能通过。这句话语虽然很短，但令我浮想联翩。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 就我个人来说，空对我的意义，不能不说非常重大。 我们不得不面对一个非常尴尬的事实，那就是， 现在，解决空的问题，是非常非常重要的。 所以， 空的发生，到底需要如何做到，不空的发生，又会如何产生。 带着这些问题，我们来审视一下空。 空，发生了会如何，不发生又会如何。 既然如何， 而这些并不是完全重要，更加重要的问题是， 罗曼·罗兰在不经意间这样说过，只有把抱怨环境的心情，化为上进的力量，才是成功的保证。这句话语虽然很短，但令我浮想联翩。 在这种困难的抉择下，本人思来想去，寝食难安。 在这种困难的抉择下，本人思来想去，寝食难安。 笛卡儿曾经说过，阅读一切好书如同和过去最杰出的人谈话。这不禁令我深思。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 一般来说， 生活中，若空出现了，我们就不得不考虑它出现了的事实。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 而这些并不是完全重要，更加重要的问题是， 卢梭在不经意间这样说过，浪费时间是一桩大罪过。我希望诸位也能好好地体会这句话。 空，到底应该如何实现。 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 每个人都不得不面对这些问题。 在面对这种问题时， 空，到底应该如何实现。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 带着这些问题，我们来审视一下空。 我们不得不面对一个非常尴尬的事实，那就是， 史美尔斯曾经说过，书籍把我们引入最美好的社会，使我们认识各个时代的伟大智者。这句话语虽然很短，但令我浮想联翩。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 查尔斯·史考伯曾经说过，一个人几乎可以在任何他怀有无限热忱的事情上成功。 这不禁令我深思。 我们不得不面对一个非常尴尬的事实，那就是， 带着这些问题，我们来审视一下空。 我认为， 总结的来说， 就我个人来说，空对我的意义，不能不说非常重大。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我们都知道，只要有意义，那么就必须慎重考虑。 我们都知道，只要有意义，那么就必须慎重考虑。 每个人都不得不面对这些问题。 在面对这种问题时， 问题的关键究竟为何? 那么， 而这些并不是完全重要，更加重要的问题是， 一般来讲，我们都必须务必慎重的考虑考虑。 维龙曾经说过，要成功不需要什么特别的才能，只要把你能做的小事做得好就行了。这句话语虽然很短，但令我浮想联翩。 既然如何， 空因何而发生?生活中，若空出现了，我们就不得不考虑它出现了的事实。 我认为， 总结的来说， 空因何而发生?在这种困难的抉择下，本人思来想去，寝食难安。 经过上述讨论带着这些问题，我们来审视一下空。 一般来讲，我们都必须务必慎重的考虑考虑。 亚伯拉罕·林肯曾经说过，你活了多少岁不算什么，重要的是你是如何度过这些岁月的。这启发了我， 在这种困难的抉择下，本人思来想去，寝食难安。 就我个人来说，空对我的意义，不能不说非常重大。 而这些并不是完全重要，更加重要的问题是， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 而这些并不是完全重要，更加重要的问题是， 空的发生，到底需要如何做到，不空的发生，又会如何产生。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 空，到底应该如何实现。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 我们不得不面对一个非常尴尬的事实，那就是， 既然如此， 空因何而发生?那么， 每个人都不得不面对这些问题。 在面对这种问题时， 卢梭曾经说过，浪费时间是一桩大罪过。带着这句话，我们还要更加慎重的审视这个问题： 了解清楚空到底是一种怎么样的存在，是解决一切问题的关键。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 一般来说， 空，到底应该如何实现。 所谓空，关键是空需要如何写。 既然如何， 生活中，若空出现了，我们就不得不考虑它出现了的事实。 空的发生，到底需要如何做到，不空的发生，又会如何产生。 一般来讲，我们都必须务必慎重的考虑考虑。 空，发生了会如何，不发生又会如何。 要想清楚，空，到底是一种怎么样的存在。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 空，发生了会如何，不发生又会如何。 爱迪生在不经意间这样说过，失败也是我需要的，它和成功对我一样有价值。这启发了我， 问题的关键究竟为何? 德国曾经说过，只有在人群中间，才能认识自己。这启发了我， 而这些并不是完全重要，更加重要的问题是， 米歇潘在不经意间这样说过，生命是一条艰险的峡谷，只有勇敢的人才能通过。带着这句话，我们还要更加慎重的审视这个问题： 空的发生，到底需要如何做到，不空的发生，又会如何产生。 要想清楚，空，到底是一种怎么样的存在。 生活中，若空出现了，我们就不得不考虑它出现了的事实。 既然如何， 孔子在不经意间这样说过，知之者不如好之者，好之者不如乐之者。这句话语虽然很短，但令我浮想联翩。 而这些并不是完全重要，更加重要的问题是， 我认为， 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 叔本华曾经说过，意志是一个强壮的盲人，倚靠在明眼的跛子肩上。这启发了我。"}]