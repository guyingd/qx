[{"title":"CodeFA×Hexo体验","url":"/article/cf571182.html","content":"\n# 前言\n&emsp;&emsp;Hexo是一个无后端的静态博客框架，但不妨碍各路大佬基于Github Action自动化部署实现假后端，为的就是随时随地可以通过假后端来写or修改文章，当然也可以改源码和配置。\n\n&emsp;&emsp;流行的假后端有Qexo、Wexa等，博主尝试过Wexa，但还是习惯于Vscode上的体验，假后端就凉一旁吃灰了，也关掉了Github Action自动化部署，本地Bat双击实现推送也很快。\n```bat\n@echo off\ncd C:\\chuckle\\blog\nhexo clean&&hexo g&&gulp&&hexo d\n```\n\n&emsp;&emsp;不过，随时修改文章，或者在外闲着无事给博客写个单页的需求也还是客观存在的，于是我又尝试了github.dev，这个github提供的在线vscode，启动很方便，仓库地址在把com改成dev后跳转即可，但它不能装插件、没有终端，浏览器打开需要等上一会，并且这是一个在线服务离不开网络。\n\n&emsp;&emsp;我将目光转向了早些年捣鼓过的Termux，可以配合CodeServer实现一个本地Vscode，但还是得配合VNC或者浏览器，依旧麻烦笨重。\n\n&emsp;&emsp;最终，我找到了它[CodeFA](https://www.coolapk.com/apk/com.nightmare.code)，[github地址：vscode_for_android](https://github.com/nightmare-space/vscode_for_android)，使用LinuxArm64启动一个code-server，ubuntu版本22.04，然后使用WebView进行加载，WebView加载的内容完全来自本地，并非套壳在线的网站。安装在平板上再合适不过（生产力MAX？）\n\n# 上手体验\n&emsp;&emsp;因为其本质就是一个ubuntu，且贴心地集成好了不少东西，上手非常轻松。第一件事当然是安装好环境跑几个代码玩玩（啊，不对，是先美化），`apt install gcc`、`apt install g++`、`apt install openjdk-17-jdk`等，没空去配置调试环境，也用不上，装上Coderunner插件，C、JAVA都可以运行了。和win端一样，支持智能提示和补全，java也支持psvm、sout等快捷方式。\n<img src=/images/27-1.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;当然，我们的重点不是跑代码，而是部署Hexo。\n\n## 部署Hexo\n>并不是完整教程，只是记录，实际上和ubuntu下部署hexo没啥大区别。\n\n&emsp;&emsp;首先，安装NodeJs、git、npm、vim，`pkg install nodejs`，`pkg install git`，`pkg install vim`，`apt install npm`。\n&emsp;&emsp;然后安装Hexo和gulp，`npm install hexo-cli -g`，`npm install --global gulp-cli`，`npm install gulp --save`。\n&emsp;&emsp;配置一下git，然后`git clone`博客源码，cd进去运行`npm install`，让它慢慢安装完依赖和我用到的插件。\n\n&emsp;&emsp;现在hexo三连，nodejs会报错：**System limit for number of file watchers reached**，问题不大，在`/etc/sysctl.conf/`中加上`fs.inotify.max_user_watches=524288`，然后运行`sysctl -p`。\n\n&emsp;&emsp;再次三连，不出意外的话，浏览器访问`http://localhost:4000/`就可以看到自己的hexo网站啦~。四连也可以推送网站到github和服务器端（当然前提是配置好了git，这就不赘述了，openssh自带无需安装）。\n<img src=/images/27-4.webp width=\"60%\" height=\"60%\">\n\n## 多端协作\n&emsp;&emsp;得益于vscode便利的git管理，一个文件或者文章，电脑端写完，推送push上github，平板端pull下来，就能继续写。得益于hexo的高性能，即使在虚拟环境下跑，hexo g也能在几秒内完成。\n<img src=/images/27-2.webp width=\"60%\" height=\"60%\"><img src=/images/27-3.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;配合小米平板的pc模式，还不错。\n<img src=/images/27-5.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;完全体。\n<img src=/images/27-6.webp width=\"60%\" height=\"60%\">\n\n# 后记\n\n暂无\n","tags":["Hexo","VScode"],"categories":["Hexo"]},{"title":"CSS/JS备忘录","url":"/article/2ec41fd7.html","content":"\n# CSS备忘录\n\n## 元素水平和垂直居中\n```css 水平居中\n.example{/* 父元素的宽度是确定的 */\n    margin: 0 auto;\n}\n.example{/* 文本水平居中 */\n    text-align: center;\n}\n\n```\n\n```css 垂直居中(元素父级添加flex)\n.example{\n    display: flex;\n    -webkit-box-align: center;\n    align-items: center;\n}\n\n```\n\n## 文本自动换行\n```css \n.example{\n    white-space: normal;\n    word-break: break-all;\n    word-wrap: break-word;\n    text-overflow: ellipsis;\n}\n\n```\n\n## 隐藏浏览器滚动条\n```css \n.example::-webkit-scrollbar{\n    display:none\n    /* or */\n    width:0;\n}\n\n```\n\n## 水平镜像旋转元素\n```css \n.example{\n    -moz-transform:scaleX(-1);\n    -webkit-transform:scaleX(-1);\n    -o-transform:scaleX(-1);\n    transform:scaleX(-1);\n}\n\n```\n\n## 媒体自适应css\n```css \n@media screen and (min-width: 1000px) and (max-width: 1300px){\n    .example{\n    }\n}\n\n```\n\n\n\n\n\n***\n\n# JS备忘录\n\n\n\n\n\n***","tags":["JS","CSS","前端"],"categories":["学习笔记"]},{"title":"给网站增加悬浮伸缩侧边栏","url":"/article/fab5c3df.html","content":"\n# 前言\n&emsp;&emsp;看到了不！看到了不！[@Heo](https://blog.zhheo.com/)的网站又双叒变好看了，还增加了个音乐灵动球！\n<img src=/images/25-2.webp width=\"80%\" height=\"80%\">\n\n&emsp;&emsp;开抄开抄~我也有了思路，魔改原来的悬浮aplayer，但一问，噢《新写了一个》，尝试抄了下却不能播放。但问题不大，按之前思路结合一下刚弄好的侧边栏，非常好。\n<img src=/images/25-3.webp width=\"60%\" height=\"60%\">\n\n&emsp;&emsp;很快成品完工~（但是还是好馋那个灵动乐球~）\n<img src=/images/25-1.webp width=\"60%\" height=\"60%\">\n\n***\n\n# 实现\n&emsp;&emsp;aplayer怎么开启看butterfly的文档。\n&emsp;&emsp;在`layout.pug`里加上：\n```pug 记得修改网易云歌单id\ninclude ./rightside.pug\n!=partial('includes/third-party/search/index', {}, {cache: true})\n!=partial('includes/dorakika/rightmenu',{}, {cache:true})\ninclude ./additional-js.pug\n//- 上面的是本来就有的，对齐上面的缩进，加上下面的内容\n.contact-info\n  .option\n    i.fas.fa-rocket\n    .bloktop\n    .text 还不造有啥用滴悬浮模块\n      .strip\n  .option\n    i.fas.fa-cube\n    .blok\n    .text 还不造有啥用滴悬浮模块\n      .strip\n  .option\n    i.fas.fa-music\n    .blokbottom\n    .text.aplayertext\n      .strip\n      .aplayer.no-destroy(mutex='true', listfolded='true', data-id='你的网易云歌单id', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n\n```\n\n&emsp;&emsp;引入css：\n```css 不生效就在对应属性加上!important\n.contact-info{\n    position: fixed;\n    top: 22%;\n    z-index: 200;\n    left: -51px;\n    transition: 0.4s;\n  }\n  .contact-info:hover{\n    left: 0px;\n  }\n  .contact-info .option{\n    cursor: pointer;\n    position: relative;\n  }\n  \n  .contact-info .option i{\n    display: block;\n    width: 50px;\n    text-align: center;\n    height: 60px;\n    line-height: 60px;\n    background: rgb(255, 255, 255);\n    color: #b9b9b9;\n    font-size: 20px;\n    transition: 0.4s;\n    border-radius: 0 10px 10px 0;\n  }\n  \n  .contact-info .option:hover i{\n    color: #3498db;\n  }\n  .contact-info .text{\n    border-radius: 15px;\n    position: absolute;\n    height: 60px;\n    width: 200px;\n    background: rgba(255,255,255,.85);\n    top: 0;\n    z-index: -1;\n    left: -136px;\n    color: rgb(0, 0, 0);\n    line-height: 60px;\n    text-align: center;\n    transition: 0.4s;\n  }\n  .contact-info .aplayertext{\n    transition: none!important;\n  }\n  .aplayer{\n    position: absolute!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-body{\n    left: -60px;\n    position: absolute!important;\n    width: 370px!important;\n    transition: none!important;\n    border-radius: 10px!important;\n  }\n  .aplayer.aplayer-fixed{\n    left: -300px;\n  }\n  .contact-info .option:hover .aplayer.aplayer-fixed .aplayer-body,.contact-info .option:hover .aplayer.aplayer-fixed{\n    left: 0px;\n  }\n  .contact-info .option:hover .text{\n    left: 60px;\n  }\n  .contact-info .blok{\n    position: absolute;\n    height: 60px;\n    width: 100px;\n    top: 0;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .bloktop{\n    position: absolute;\n    height: 75px;\n    width: 100px;\n    bottom: 0px;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .blokbottom{\n    position: absolute;\n    height: 75px;\n    width: 100px;\n    top: 0;\n    z-index: -1;\n    left: 0px;\n  }\n  .contact-info .option:hover .blok,.contact-info .option:hover .bloktop,.contact-info .option:hover .blokbottom{\n    left: 0px;\n  }\n  .contact-info .option:hover .aplayertext{\n    left: 60px!important;\n    width: 370px!important;\n    background: transparent!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-miniswitcher{\n    border-radius: 0 10px 10px 0!important;\n  }\n  .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{\n    transition: 0.28s!important;\n    border-radius: 10px!important;\n  }\n  .aplayer .aplayer-pic{\n    height: 60px!important;\n  }\n  .aplayer .aplayer-info{\n    height: 60px!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body{\n    height: 60px;\n  }\n  .aplayer .aplayer-list.aplayer-list-hide{\n    margin-bottom: 59px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-list{\n    margin-bottom: 62px!important;\n    max-height: 240px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-info{\n    transition: none!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body{\n    height: 60px!important;\n  }\n  .aplayer.aplayer-narrow .aplayer-body, .aplayer.aplayer-narrow .aplayer-pic{\n    border-radius:  10px 0 0 10px!important;\n  }\n  .aplayer.aplayer-fixed{\n    border-radius: 10px!important;\n  }\n  .aplayer .aplayer-pic{\n    border-radius:  0 0 0 10px!important;\n  }\n  .aplayer.aplayer-fixed .aplayer-list{\n    border-radius: 10px 10px 0 0!important;\n  }\n  [data-theme=dark]\n  .contact-info .option i{\n    background: rgb(22, 22, 22);\n    color: #b9b9b9;\n  }\n  [data-theme=dark]\n  .contact-info .text{\n    background: rgba(23, 23, 23, 0.85);\n    color: rgba(255, 255, 255, 0.92);\n  }\n  @media screen and (max-width:1300px){\n    .contact-info{\n        display: none!important;\n      }\n  }\n  .aplayer{\n    opacity: .93!important;\n  }\n  [data-theme=dark]\n  .aplayer{\n    background: rgb(22, 22, 22)!important;\n    color: rgb(255, 255, 255);\n  }\n  [data-theme=dark]\n  .aplayer.aplayer-fixed .aplayer-body{\n    background: rgb(22, 22, 22)!important;\n    color: rgb(255, 255, 255);\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li:hover{\n    background: #3b3b3b;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li.aplayer-list-light{\n    background: #686868;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-info .aplayer-controller .aplayer-time{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li .aplayer-list-index{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-list ol li .aplayer-list-author{\n    color: #d4d4d4;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{\n    fill: #d4d4d4;\n  }\n\n.contact-info .text .strip{\n    border-radius: 5px;\n    position: absolute;\n    height: 36px;\n    width: 5px;\n    background: rgba(20, 163, 230, 0.8);\n    top: 12px;\n    z-index: -1;\n    right: 4px;\n    transition: 0.4s;\n  }\n  .aplayertext .strip{\n    transition: none!important;\n  }\n  .contact-info .option:hover .aplayertext .strip{\n    background: transparent;\n  }\n  [data-theme=dark]\n  .aplayer .aplayer-miniswitcher{\n    background: rgba(23, 23, 23, 0.85);\n  }\n  .aplayer .aplayer-miniswitcher .aplayer-icon:hover path{\n    fill: #3498db;\n  }\n  [data-theme=dark]\n  .contact-info .option:hover i{\n    color: #3498db;\n  }\n\n```\n\n> 还缺着两个空位不知道该放些啥\n\n***\n\n# 后记\n&emsp;&emsp;9月26日，Meting挂了，原因是ssl证书到期。\n&emsp;&emsp;为了aplayer的稳定，还是播放本地音乐吧。\n```pug #aplayer后加上js,并在配置文件关闭meting\n#aplayer.aplayer.no-destroy(mutex='true', listfolded='true', data-id='6609736315', data-preload=\"none\" , data-server='netease', data-volume='0.25', data-order='random', data-type='playlist', data-fixed='true', data-autoplay='false')\n  script.\n    const ap = new APlayer({\n      container: document.getElementById('aplayer'),\n      fixed: true,\n      order: 'random',\n      preload: 'none',\n      volume: 0.25,\n      audio: [\n        {\n        name: '越权访问-崩坏：星穹铁道',\n        artist: 'Hanser',\n        url: '/music/songs/1.mp3',\n        lrc: '/music/lrc/1.lrc',\n        cover: '/music/images/songs/1.webp'\n        }\n      ]\n    });\n```\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"添加音乐页面","url":"/article/3322c8a8.html","content":"\n# 前言\n&emsp;&emsp;没有音乐页面怎么行，花里胡哨的都安排上，本来想摆烂直接上aplayer，但考虑到网站速度以及aplayer的稳定性（和卜算子日常歇菜），还是弄个音乐播放器放自己本地的音乐好，又快又稳定。\n&emsp;&emsp;在网上找了个能用的h5播放器源码(找不到原作者)，适配下pjax和hexo，再改改样式就完成啦：[查看音乐页面](/music/)\n<img src=/images/24-1.webp width=\"50%\" height=\"50%\">\n\n***\n\n# 实现\n&emsp;&emsp;让指定单页的背景透明可以看此教程：[控制指定单页的背景样式](/article/eb3a4679.html)\n&emsp;&emsp;新建music单页，cv以下内容覆盖原内容：\n```html\n---\ncomments: false\naside: false\n---\n{% raw %}\n<!-- 播放器 -->\n<div class=\"music-player\">\n\t<!-- audio标签 -->\n\t<audio class=\"music-player__audio\" ></audio>\n\t<!-- 播放器主体 -->\n\t<div class=\"music-player__main\">\n\t\t<!-- 模糊背景 -->\n\t\t<div class=\"music-player__blur\"></div>\n\t\t<!-- 唱片 -->\n\t\t<div class=\"music-player__disc\">\n\t\t\t<!-- 唱片图片 -->\n\t\t\t<div class=\"music-player__image\">\n\t\t\t\t<img width=\"100%\" src=\"\" alt=\"\">\n\t\t\t</div>\n\t\t\t<!-- 指针 -->\n\t\t\t<div class=\"music-player__pointer\"><img width=\"100%\" src=\"/img/cd_tou.png\" alt=\"\"></div>\n\t\t</div>\n\t\t<!-- 控件主体 -->\n\t\t<div class=\"music-player__controls\">\n\t\t\t<!-- 歌曲信息 -->\n\t\t\t<div class=\"music__info\">\n\t\t\t\t<h3 class=\"music__info--title\">...</h3>\n\t\t\t</div>\n\t\t\t<!-- 控件... -->\n\t\t\t<div class=\"player-control\">\n\t\t\t\t<div class=\"player-control__content\">\n\t\t\t\t\t<div class=\"player-control__btns\">\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--prev\"><i class=\"iconfont icon-prev\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--play\"><i class=\"iconfont icon-play\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--next\"><i class=\"iconfont icon-next\"></i></div>\n\t\t\t\t\t\t<div class=\"player-control__btn player-control__btn--mode\"><i class=\"iconfont icon-random\"></i></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"player-control__volume\">\n\t\t\t\t\t\t<div class=\"control__volume--icon player-control__btn\"><i class=\"iconfont icon-volume\"></i></div>\n\t\t\t\t\t\t<div class=\"control__volume--progress progress\"></div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"player-control__content\">\n\t\t\t\t\t<div class=\"player__song--progress progress\"></div>\n\t\t\t\t\t<div class=\"player__song--timeProgess nowTime\">00:00</div>\n\t\t\t\t\t<div class=\"player__song--timeProgess totalTime\">00:00</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t<!-- 歌曲列表 -->\n\t<div class=\"music-player__list\">\n\t\t<ul class=\"music__list_content\">\n\t\t</ul>\n\t</div>\n</div>\n<script src=\"/js/utill.js\"></script>\n<script src=\"https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.slim.min.js\"></script>\n<script src=\"/js/player.js?10\"></script>\n<div style=\"text-align:center;margin:-100px 0; font:normal 14px/24px 'MicroSoft YaHei';color:#ffffff\"></div>\n\n{% endraw %}\n\n```\n\n&emsp;&emsp;在`blog\\source\\music`下新建`songs`和`images`文件夹，`songs`内直接放入歌曲。再在`images`文件夹内新建`songs`文件夹，里面放歌曲封面。\n&emsp;&emsp;在`blog\\source\\img`内放入这两张图片[cd.png](https://blog.chuckle.top/img/cd.png)，[cd_tou.png](https://blog.chuckle.top/img/cd_tou.png)。\n\n&emsp;&emsp;在`\\blog\\themes\\butterfly\\source\\js`新建`player.js`。\n```js\n//创建一个音乐播放器的类 单例模式\nclass Player {\n    constructor() { //类的构造函数\n        //如果没有实例化，就去构造一个实例\n        return this.getInstance(...arguments);\n    }\n\n    //构建实例\n    getInstance() {\n        let instance = new PlayerCreator(...arguments);\n        //让实例可以使用到Player的原型的属性方法\n        // instance.__proto__=Player.prototype;\n        // instance.constructor=Player;\n        //把构建好的实例挂在Player类上\n        Player.instance = instance;\n        return instance;\n    }\n}\n\n//歌曲信息\nclass Musics {\n    //歌曲\n    constructor() {\n        this.songs = [{\n                id: 1,\n                title: '越权访问-崩坏：星穹铁道 - Hanser',\n                singer: '越权访问-崩坏：星穹铁道 - Hanser',\n                songUrl: './songs/1.mp3',\n                imageUrl: './images/songs/1.webp'\n            },\n            {\n                id: 2,\n                title: '妄想Reality（翻自 洛天依） - 炎祾',\n                singer: '妄想Reality（翻自 洛天依） - 炎祾',\n                songUrl: './songs/2.mp3',\n                imageUrl: './images/songs/2.webp'\n            },\n\t\t\t{\n                id: 3,\n                title: '人间失宠 - 昔诺',\n                singer: '人间失宠 - 昔诺',\n                songUrl: './songs/3.mp3',\n                imageUrl: './images/songs/3.webp'\n            },\n            {\n                id: 4,\n                title: '崩坏世界的歌姬 (Movie Ver.) - 小林未郁',\n                singer: '崩坏世界的歌姬 (Movie Ver.) - 小林未郁',\n                songUrl: './songs/4.mp3',\n                imageUrl: './images/songs/4.webp'\n            },\n\t\t\t{\n                id: 5,\n                title: '玛德琳娜电塔 - 花玲',\n                singer: '玛德琳娜电塔 - 花玲',\n                songUrl: './songs/5.mp3',\n                imageUrl: './images/songs/5.webp'\n            },\n        ]\n    }\n    //根据索引获取歌曲的方法\n    getSongByNum(index) {\n        return this.songs[index];\n    }\n}\n\n//真正的构建播放器的类\nclass PlayerCreator {\n    constructor() {\n        this.audio = document.querySelector('.music-player__audio') // Audio dom元素, 因为很多api都是需要原生audio调用的，所以不用jq获取\n        // this.audio.muted = true; // 控制静音\n        this.audio.volume = 0.2;\n\n        //工具\n        this.util = new Util();\n        this.musics = new Musics(); //歌曲信息\n        this.song_index = 0; // 当前播放的歌曲索引\n        this.loop_mode = 1; // 1 2\n        // 下方歌曲列表容器\n        this.song_list = $('.music__list_content');\n\n        this.render_doms = { //切换歌曲时需要渲染的dom组\n            title: $('.music__info--title'),\n            singer: $('.music__info--singer'),\n            image: $('.music-player__image img'),\n            blur: $('.music-player__blur')\n        }\n        this.ban_dom = { //禁音时需要渲染的dom组\n            control__btn: $('.control__volume--icon')\n        }\n\n        // 时间显示容器\n        this.render_time = {\n            now: $('.nowTime'),\n            total: $('.totalTime')\n        }\n\n        // 唱片\n        this.disc = {\n            image: $('.music-player__image'),\n            pointer: $('.music-player__pointer')\n        };\n        //播放器初始化\n        this.init();\n    }\n    //初始化函数\n    init() {\n        this.renderSongList();\n        this.renderSongStyle();\n        this.bindEventListener();\n    }\n    //生成播放列表\n    renderSongList() {\n        let _str = '';\n        this.musics.songs.forEach((song, i) => {\n            _str += `<li class=\"music__list__item\">${song.title}</li>`\n        });\n        this.song_list.html(_str);\n    }\n\n    //根据歌曲去渲染视图\n    renderSongStyle() {\n        let {\n            title,\n            singer,\n            songUrl,\n            imageUrl\n        } = this.musics.getSongByNum(this.song_index);\n        this.audio.src = songUrl;\n        this.render_doms.title.html(title);\n        this.render_doms.singer.html(singer);\n        this.render_doms.image.prop('src', imageUrl);\n        this.render_doms.blur.css('background-image', 'url(\"' + imageUrl + '\")');\n\n        //切换列表中的item的类名 play\n        this.song_list.find('.music__list__item').eq(this.song_index).addClass('play').siblings().removeClass('play');\n    }\n    //绑定各种事件\n    bindEventListener() {\n        //播放按钮\n        this.$play = new Btns('.player-control__btn--play', {\n            click: this.handlePlayAndPause.bind(this)\n        });\n        //上一首\n        this.$prev = new Btns('.player-control__btn--prev', {\n            click: this.changeSong.bind(this, 'prev')\n        });\n        //下一首\n        this.$next = new Btns('.player-control__btn--next', {\n            click: this.changeSong.bind(this, 'next')\n        });\n        //循环模式\n        this.$mode = new Btns('.player-control__btn--mode', {\n            click: this.changePlayMode.bind(this)\n        });\n        //禁音\n        this.$ban = new Btns('.control__volume--icon', {\n            click: this.banNotes.bind(this)\n        })\n        //列表点击\n        this.song_list.on('click', 'li', (e) => {\n            let index = $(e.target).index();\n            this.changeSong(index);\n        })\n\n        //音量控制 audio标签音量 vlouem 属性控制0-1\n\n        new Progress('.control__volume--progress', {\n            min: 0,\n            max: 1,\n            value: this.audio.volume,\n            handler: (value) => { //更改进度时\n                this.audio.volume = value;\n            }\n        })\n        //歌曲进度 this.audio.duration\n        //可以播放的时候触发（歌曲的基本信息都已经获取到了）\n        this.audio.oncanplay = () => {\n            //避免重复实例化\n            if (this.progress) {\n                this.progress.max = this.audio.duration; //切换歌曲后更新时长\n                this.render_time.total.html(this.util.formatTime(this.audio.duration));\n                return false;\n            };\n            this.progress = new Progress('.player__song--progress', {\n                min: 0,\n                max: this.audio.duration,\n                value: 0,\n                handler: (value) => {\n                    this.audio.currentTime = value;\n                }\n            })\n            //调整总时长\n            this.render_time.total.html(this.util.formatTime(this.audio.duration));\n        }\n\n        //会在播放的时候持续触发\n        this.audio.ontimeupdate = () => {\n            this.progress.setValue(this.audio.currentTime);\n            //调整当前时长\n            this.render_time.now.html(this.util.formatTime(this.audio.currentTime));\n        }\n\n        //当歌曲播放完成的时候\n        this.audio.onended = () => {\n            this.changeSong('next');\n            //播放完，换歌后，重新播放\n            this.audio.play();\n        }\n\n    }\n\n    //播放暂停控制\n    handlePlayAndPause() {\n        let _o_i = this.$play.$el.find('i');\n        //this.audio.pauseed值为true 说明目前是不播放\n        if (this.audio.paused) { //现在是暂停的 要播放\n            this.audio.play();\n            _o_i.removeClass('icon-play').addClass('icon-pause');\n            this.disc.image.addClass('play');\n            this.disc.pointer.addClass('play')\n        } else {\n            this.audio.pause();\n            _o_i.addClass('icon-play').removeClass('icon-pause');\n            this.disc.image.removeClass('play');\n            this.disc.pointer.removeClass('play');\n        }\n    }\n\n    //更改循环模式\n    changePlayMode() {\n        this.loop_mode++;\n        if (this.loop_mode > 2) this.loop_mode = 0;\n        this.renderPlayMode();\n    }\n    //更改按钮样式\n    renderPlayMode() {\n        let _classess = ['loop', 'random', 'single'];\n        let _o_i = this.$mode.$el.find('i');\n        //prop 改一些标签的自有属性 attr改一些标签的自定义属性\n        _o_i.prop('class', 'iconfont icon-' + _classess[this.loop_mode])\n    }\n    //更改歌曲索引\n    changeSongIndex(type) {\n        if (typeof type === 'number') {\n            this.song_index = type;\n        } else {\n            if (this.loop_mode === 0) {\n                //列表循环\n                this.song_index += type === 'next' ? 1 : -1;\n                if (this.song_index > this.musics.songs.length - 1) this.song_index = 0;\n                if (this.song_index < 0) this.song_index = this.musics.songs.length - 1;\n            } else if (this.loop_mode === 1) {\n                //随机播放\n                let _length = this.musics.songs.length;\n                let _random = Math.floor(Math.random() * _length);\n                for (let i = 0; i < 10000; i++) { //随机的数为本身则继续随机\n                    if (this.song_index == _random) {\n                        _random = Math.floor(Math.random() * _length);\n                    } else {\n                        this.song_index = _random;\n                        break;\n                    }\n                }\n            } else if (this.loop_mode === 2) {\n                this.song_index = this.song_index;\n            }\n        }\n    }\n    //歌曲时长\n    songTime() {\n        let totalMinute = parseInt(this.audio.duration / 60) < 10 ? \"0\" + parseInt(this.audio.duration / 60) : parseInt(this.audio.duration / 60);\n        let totalSecond = parseInt(this.audio.duration % 60) < 10 ? \"0\" + parseInt(this.audio.duration % 60) : parseInt(this.audio.duration % 60);\n        $('.totalTime').text(totalMinute + ':' + totalSecond);\n    }\n    //切换歌曲\n    changeSong(type) {\n        //更改索引\n        this.changeSongIndex(type);\n        //记录切歌前的状态\n        let _is_pause = this.audio.paused;\n        //切歌后更改视图显示\n        this.renderSongStyle();\n        //如果切歌前是在播放，就继续播放\n        if (!_is_pause) this.audio.play();\n    }\n    //禁音\n    banNotes() {\n        let _o_i = this.$ban.$el.find(\"i\");\n        if (this.audio.muted == true) { //如果禁音则开启\n            this.audio.muted = false;\n            _o_i.removeClass('icon-muted').addClass('icon-volume');\n        } else {\n            this.audio.muted = true;\n            _o_i.removeClass('icon-volume').addClass('icon-muted');\n        }\n    }\n}\n\n//进度条\nclass Progress {\n    constructor(selector, options) {\n        $.extend(this, options);\n        ///给this挂载传入的参数\n        this.$el = $(selector);\n        this.width = this.$el.width();\n        this.init();\n    }\n\n    //进度条初始化\n    init() {\n        this.renderBackAndPointer();\n        this.bindEvents();\n        this.drag();\n        this.value;\n        this.changeDOMStyle(this.width * this.value);\n    }\n    //为进度条渲染back和pointer\n    renderBackAndPointer() {\n        this.$back = $('<div class=\"back\">');\n        this.$pointer = $('<div class=\"pointer\">');\n\n        this.$el.append(this.$back);\n        this.$el.append(this.$pointer);\n    }\n\n    setValue(value) { //主动调用，传入value值，设置进度条样式\n        let _distance = this.width * value / (this.max - this.min);\n        this.changeDOMStyle(_distance);\n    }\n\n    drag() {\n        let ele = this.$pointer;\n        let father = this.$el;\n        let flag = false; //鼠标是否点击\n        ele.mousedown((e) => {\n            flag = true;\n            let mousePos = {\n                x: e.offsetX\n            }\n            $(document).mousemove((e) => {\n                if (flag === true) {\n                    let _left = e.clientX - father.offset().left - mousePos.x;\n                    let _distance = Math.max(0, Math.min(_left, father.outerWidth(false) - ele.outerWidth(false)))\n                    let _ratio = _distance / father.outerWidth(false);\n                    let _value = _ratio * (this.max - this.min); //当前的音量值\n                    this.changeDOMStyle(_distance);\n                    this.handler(_value); //更改进度之后，执行回调\n                }\n            })\n        })\n        $(document).mouseup(() => {\n            flag = false;\n        })\n\n    }\n\n    bindEvents() { //鼠标点击时更改\n        this.$el.click((e) => {\n            let _x = e.offsetX; //鼠标距离元素左边的距离\n            let _ratio = _x / this.width;\n            let _value = _ratio * (this.max - this.min); //当前的音量值\n            this.changeDOMStyle(_x);\n            this.handler(_value); //更改进度之后，执行回调\n        })\n    }\n    //更改pointer和back\n    changeDOMStyle(distance) {\n        this.$back.width(distance + 7 == 7 ? 0 : distance + 7);//进度为0时将进度条背景改为0否则加上进度按钮的长度\n        this.$pointer.css('left', distance + 'px');\n    }\n}\n\n\n//按钮类 \nclass Btns {\n    constructor(selector, handlers) {\n        this.$el = $(selector); //元素\n        this.bindEvents(handlers);\n    }\n    bindEvents(handlers) { //绑定事件\n        for (const event in handlers) {\n            //使用值的时候保证键值对在对象中是存在的\n            if (handlers.hasOwnProperty(event)) {\n                this.$el.on(event, handlers[event]);\n            }\n        }\n    }\n}\nnew Player();\ndocument.addEventListener('pjax:complete', (e) => {\n    new Player();\n})\n\n```\n\n&emsp;&emsp;在`\\blog\\themes\\butterfly\\source\\js`新建`utill.js`。\n```js\nclass Util {\n    constructor() {\n        if (Util.instance) return Util.instance;\n        return this.getInstance(...arguments);\n    }\n\n    getInstance() {\n        var instance = {\n            /*\n             *   formatTime 格式化时间（s）为 hour:minutes:seconds\n             *   @params  time  required number (s)\n             *   \n             *   return hour:minutes:seconds string\n             */\n\n            formatTime(time) {\n                //没有传time的时候\n                if (time === undefined) {\n                    this.handlerError(123, {\n                        method: 'formate',\n                        param: 'time'\n                    });\n                    return false;\n                }\n                let _time = Math.floor(time);\n                let _minutes = Math.floor(_time / 60);\n                let _hours = Math.floor(_minutes / 60);\n                let _seconds = _time - (_minutes * 60);\n\n                return (_hours ? this.fillZero(_hours) + ':' : '') + this.fillZero(_minutes - (_hours * 60)) + ':' + this.fillZero(_seconds);\n            },\n            /*\n             *   fillZero 为小于10的数字补0\n             *   @params  num  required number\n             *   return '01'.. string\n             */\n            fillZero(num) {\n                //当没有传time的时候\n                if (num === undefined) {\n                    this.handlerError(123, {\n                        method: 'fillZero',\n                        param: 'num'\n                    });\n                    return false;\n                }\n                //这个函数只是让我们在渲染/显示的时候有一个不同的效果，不要操作原数据\n                return num > 9 ? num : '0' + num;\n            },\n            errors: {\n                123: ({\n                    method,\n                    param\n                }) => {\n                    return method + 'function need a param ' + param;\n                }\n            },\n            handlerError(code, options) { //处理报错\n                console.error('[until error] message' + this.errors[code](options));\n            }\n        }\n        Util.instance = instance;\n        return instance;\n    }\n}\n\n//为了这个工具以后在模块化环境中依然可以使用，需要判断一下，如果是在模块化环境，就将其暴露出去\n//commonJs\nif (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = Util;\n}\n\n//AMD\nif (typeof define === 'function' && define.amd) {\n    define('util', [], function () {\n        return Util;\n    });\n}\n\n```\n\n&emsp;&emsp;引入css（一些高度和细节按需自行调整）：\n```css\n/* 播放器大小 */\n.music-player {\n  width: 570px;\n  height: 500px;\n}\n.music-player h3{\n  margin: 0px 0 1px!important;\n}\n@font-face {font-family: \"iconfont\";\n  src: url('iconfont.eot?t=1537976418058'); /* IE9*/\n  src: url('iconfont.eot?t=1537976418058#iefix') format('embedded-opentype'), /* IE6-IE8 */\n  url('data:application/x-font-woff;charset=utf-8;base64,d09GRgABAAAAAAmcAAsAAAAADgwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADMAAABCsP6z7U9TLzIAAAE8AAAARAAAAFY8lGHxY21hcAAAAYAAAACUAAACBGvSDaxnbHlmAAACFAAABUMAAAbwatoOAWhlYWQAAAdYAAAALwAAADYSwtboaGhlYQAAB4gAAAAcAAAAJAfeA4tobXR4AAAHpAAAAA8AAAAoKAAAAGxvY2EAAAe0AAAAFgAAABYIpgZ4bWF4cAAAB8wAAAAdAAAAIAEYAGNuYW1lAAAH7AAAAUUAAAJtPlT+fXBvc3QAAAk0AAAAZQAAAJSspZ5ZeJxjYGRgYOBikGPQYWB0cfMJYeBgYGGAAJAMY05meiJQDMoDyrGAaQ4gZoOIAgCKIwNPAHicY2BkYWCcwMDKwMHUyXSGgYGhH0IzvmYwYuRgYGBiYGVmwAoC0lxTGByeyf3/z9zwv4EhhrmBoQEozAiSAwD0fA0ZeJztkcENwjAQBMdxCAQhQgU88qYeesBKGoh48aLSS7oIa1+QKIKzxtKedWdpF9gBUdxEDeFNINdL3VD6kWPp19ylzxyoaOxqvSUb57RM6wqbHr76p4Jm/Fx0oNGfUVtabdzrueFfp3I/N9VmPx25hfVOzsqSkzOzwZGX2Ojk2Tk5Oc9lcuR0x6OQE+lIBag+4Pgp1HicbVVrjBNVFJ5z796Zvu482plOH0tLZ9rp7hba0m5bZLuUhwZNQEB2F7airBDlERd5/IX4b+MPE3/wUhMTEkLEQAwkhpAIgcCaGI3xpyQqwb/orgsmGs129Ex3UWJoJufec+43PfN955wZgQjC37/SL6giGEKvIESgHjWNHBpNhnzOQAPOILCaH2psI9xP9BNQ4gNACqb7kBRi7lKVbnEvuU2YhhG4ADuUUOn0bUUpdl4e0JU7J9HAuFYEZ3bWveNOz8wI+PtfTj+ITr7G0GirwWQ1NBDVIWf4wcjRz9ylsQJxH5oFAgNxUEh/Au6r85cx3bTbdC/BdvdjRR84eQcNOV9UlNunSyHFvRAuut/PzEAThmdnMWcP5nxA99F9giZkhKIwJAhmEbyMjYoJKdBFCUQqg6mJUbPegLqDxCOWU29BPQWiAqL0pHO3UAGoFJZaRE2l0+nOo2w6IQPICS1K5CxYnTmj45Noj48FRMKknq8854Ou835PFJoVcrbSBN29rJXqpbB7RacbSJ/cmVD6CIRgs1HWYWuw82UwSBmlgQBl5DjuJyj1oyWLGn5Na7QhKEJaEMCWwdD0qFlFQqh3Dn1JS8Fjn/zeStp2spWwAWy3vDrprcmFhTZw2wl3jxJkduHoSd+rGcV8f9Cb1C/khPXCGGbEBHjZljNYb3hZ8Krm0amksXooER60wHQsUU+DjVI7MkTNFAyBJOrRCio5mIcqPmHUrKDYCMBH1qPkkfPuuolPnx+KxGKRofJHG9sfDq9s8oQtT4VCU7KV5E0i2wneXNn70nLZjgNf/3oJAUnLA8x/PmTvHOBqJA5y662a9yekxI6v3fUejediwN7ZOP42XcUzidAUz/KpUCLLV//EE1l5GNYUOCSzvPXsKm4lOB6HYC9dlw9Bb5YPbQCI5eKLOqDZT34RkqjEWk95SxIlz3j6D0Eam6mKa72hOdQpga1VReynRn3QsRRUoavHogRmtIIqEE44v+HfG+FKIrK/NhGLAeckLkmWOvrasWNkxyFg45KsSuNtSeViuy1yVWqPS6oskZ/95wIhVXUfRBKlrRHD39NLTvd2dskvjEAv2bzbnW6LGpfGxyWueTf+u+/Ow4/0IrVxHvqFljCKTLCeBSzrEvB4VKJpwKoUACuDI4mBegPfC0hSzDfEIvLDghc9CM5rCgxdNBejtf+iJs5E5x5HDcLxeLiq2fzenz7DX82VcXrsqt/wAZUjEfmKTwtSKdsH0JeTIKhJy1as0LuxTaMwuqkbGnkV4BVy91owBHHtejjGg9feZz4oZ6/bFZ/4XdAfnp8L+4M/MKJobMnW4rIXU6ImEzG7q/7M7m9wtjWxeXH3zvMtjAJ77uobb95YnKNb9BZdIzjCJkHIZbAfZawpVq4ILWRR7XJTIIN0a9jd0SUoEWTyDopS9URKgYIR7HA8bUEGZwLxljOM95KrLi8rQAzFp7LJAAlNMtWn6D7WD3NjB4mW0ugp14K5sroI8ZPggccQV912eAEysDwQUTQfmwj0BvYwBroicZanh0bGFE1TxiZPkE+eimBHxtpyOCxvP3qmO783uzzzwubu/Fqix0TKeBUbdPKW91rr0qlipZH+AmGHVeoelUYGu8PQvWHF0e2qY1uihL28wDjKNFsyGxo9q2jk4Jir9jOf3uUUhECXtoFfjjL8duQU1eavIOjwNph7DDoQJP5FkFp2VQ8D35a3qMNwDgmOHKJ5xiVFB8b2IMMJ5tOUSGA5PTGJCmwJy+2xI+ypCHLm6HY5fBTWrOrvd//Ccv8D5gQugwB4nGNgZGBgAOJ0oeli8fw2Xxm4WRhA4PrFk0kI+v9+FgbmDCCXg4EJJAoAItUKtAB4nGNgZGBgbvjfwBDDwgACQJKRARVwAQBHEAJzeJxjYWBgYCECAwADmAApAAAAAAAAOgB0ANwBFAGYAfwCgAL0A3gAAHicY2BkYGDgYghnYGEAASYwjwtI/gfzGQASMwF8AAAAeJxlj01OwzAQhV/6B6QSqqhgh+QFYgEo/RGrblhUavdddN+mTpsqiSPHrdQDcB6OwAk4AtyAO/BIJ5s2lsffvHljTwDc4Acejt8t95E9XDI7cg0XuBeuU38QbpBfhJto41W4Rf1N2MczpsJtdGF5g9e4YvaEd2EPHXwI13CNT+E69S/hBvlbuIk7/Aq30PHqwj7mXle4jUcv9sdWL5xeqeVBxaHJIpM5v4KZXu+Sha3S6pxrW8QmU4OgX0lTnWlb3VPs10PnIhVZk6oJqzpJjMqt2erQBRvn8lGvF4kehCblWGP+tsYCjnEFhSUOjDFCGGSIyujoO1Vm9K+xQ8Jee1Y9zed0WxTU/3OFAQL0z1xTurLSeTpPgT1fG1J1dCtuy56UNJFezUkSskJe1rZUQuoBNmVXjhF6XNGJPyhnSP8ACVpuyAAAAHicbcrBCoNADATQjLau3dWPjBTdaInINqD9+gb06MBc3gxVdCbSfSIq1HjgiQYBLV6ISJRKZp0OKXm1sBjLLNoM6+gYfqxf0SkVc73MZ39r6/2IQ7+bZmM95+7NutlFRH+UdSMxAAAA') format('woff'),\n  url('iconfont.ttf?t=1537976418058') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\n  url('iconfont.svg?t=1537976418058#iconfont') format('svg'); /* iOS 4.1- */\n}\n\n.icon-prev:before { content: \"\\f0069\"; }\n\n.icon-next:before { content: \"\\f006a\"; }\n\n.icon-play:before { content: \"\\e66a\"; }\n\n.icon-pause:before { content: \"\\e76a\"; }\n\n.icon-random:before { content: \"\\e622\"; }\n\n.icon-muted:before { content: \"\\e61e\"; }\n\n.icon-volume:before { content: \"\\e87a\"; }\n\n.icon-loop:before { content: \"\\e66c\"; }\n\n.icon-single:before { content: \"\\e66d\"; }\n\n\n/* 播放器位置 */\n.music-player {\n  position: relative;\n  margin: 0px auto;\n}\n\n/* 歌曲列表 */\n\n.music-player__list {\n  width: 100%;\n  padding: 10px;\n  margin-top: 30px;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 5px;\n  -webkit-box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);\n  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);\n}\n\n.music__list__item {\n  padding-left: 25px;\n  color: #ccc;\n  position: relative;\n  margin-bottom: 10px;\n  font-size: 14px;\n  cursor: pointer;\n}\n\n.music__list__item:last-of-type {\n  margin: 0;\n}\n\n.music__list__item.play {\n  color: #fff;\n}\n\n.music__list__item.play:before {\n  font-family: 'iconfont';\n  content: \"\\e87a\";\n  position: absolute;\n  left: 0px;\n  top: 4px;\n}\n/* 播放器主体 */\n.music-player__main {\n  height: 180px;\n  padding: 25px;\n  box-shadow: 0 0 10px rgb(0 0 0 / 20%);\n  border-radius: 10px;\n  position: relative;\n  overflow: hidden;\n}\n\n/* 播放器主体模糊背景 */\n.music-player__blur {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background-size: 100%;\n  left: 0;\n  top: 0;\n  z-index: -1;\n  -webkit-filter: blur(20px);\n  filter: blur(20px);\n}\n/* 播放器唱片效果 */\n.music-player__disc {\n  float: left;\n  width: 130px;\n  height: 130px;\n  background: url(/img/cd.png) no-repeat center;\n  background-size: 100%;\n  position: relative;\n}\n\n/* 唱片指针 */\n.music-player__pointer {\n  width: 25px;\n  position: absolute;\n  right: -10px;\n  top: 0;\n  -webkit-transform-origin: right top;\n  -ms-transform-origin: right top;\n  transform-origin: right top;\n  -webkit-transform: rotate(-15deg);\n  -ms-transform: rotate(-15deg);\n  transform: rotate(-15deg);\n  -webkit-transition: all 0.3s;\n  -o-transition: all 0.3s;\n  transition: all 0.3s;\n}\n\n/* 唱片指针播放状态 加play类名 */\n.music-player__pointer.play {\n  -webkit-transform: rotate(0deg);\n  -ms-transform: rotate(0deg);\n  transform: rotate(0deg);\n}\n\n/* 唱片歌曲图片 */\n.music-player__image {\n  width: 80px;\n  height: 80px;\n  border-radius: 50%;\n  position: absolute;\n  overflow: hidden;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  margin: auto;\n}\n/* 播放器控件 */\n.music-player__controls {\n  width: 330px;\n  height: 130px;\n  float: right;\n}\n\n/* 歌曲信息 */\n.music__info {\n  width: 100%;\n  height: 50px;\n  margin-bottom: 15px;\n}\n\n.music__info .music__info--title {\n  color: #fff;\n}\n\n.music__info .music__info--title {\n  font-size: 16px;\n}\n/* 控件 */\n\n.player-control {\n  width: 100%;\n}\n\n.player-control__content {\n  overflow: hidden;\n}\n\n/* 播放暂停按钮 */\n.player-control__btns {\n  float: left;\n  overflow: hidden;\n}\n\n.player-control__btn {\n  float: left;\n  margin: 0 5px;\n  font-weight: bolder;\n  color: #fff;\n  cursor: pointer;\n}\n\n.player-control__volume {\n  float: right;\n  overflow: hidden;\n}\n\n.control__volume--progress {\n  float: left;\n  width: 100px;\n  position: relative;\n  top: 8px;\n}\n\n.player__song--timeProgess{\n  font-size: 12px;\n  color: #fff;\n  padding: 0px 3px;\n  background: rgba(0, 0, 0, 0.3);\n  border-radius: 5px;\n}\n\n.player-control__content .nowTime{\n  float: left;\n}\n.player-control__content .totalTime{\n  float: right;\n}\n\n.music-player .progress {\n  background: rgba(0, 0, 0, 0.3);\n  height: 5px;\n  -webkit-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) inset;\n  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) inset;\n  overflow: hidden;\n  margin: 0.5rem 0!important;\n  border-radius: 2px;\n  position: relative;\n  cursor: pointer;\n}\n\n.music-player .progress .back {\n  width: 0px;\n  height: 100%;\n  border-radius: 2px;\n  background: rgb(12, 182, 212);\n}\n\n.music-player .progress .pointer {\n  width: 7px;\n  height: 7px;\n  background: #fff;\n  border-radius: 50%;\n  opacity: 0;\n  -webkit-transition: opacity 0.3s;\n  -o-transition: opacity 0.3s;\n  transition: opacity 0.3s;\n  position: absolute;\n  top: -1px;\n  left: 0;\n}\n\n.music-player .progress:hover .pointer {\n  opacity: 1;\n}\n\n\n/* 播放 画片 动画 */\n\n@-webkit-keyframes disc {\n  from {\n      -webkit-transform: rotate(0deg);\n      transform: rotate(0deg);\n  }\n\n  to {\n      -webkit-transform: rotate(360deg);\n      transform: rotate(360deg);\n  }\n}\n\n@keyframes disc {\n  from {\n      -webkit-transform: rotate(0deg);\n      transform: rotate(0deg);\n  }\n  to {\n      -webkit-transform: rotate(360deg);\n      transform: rotate(360deg);\n  }\n}\n.music-player__image.play {\n  -webkit-animation: disc 5s linear 0s infinite;\n  animation: disc 5s linear 0s infinite;\n}\n/*  播放进度  */\n.player__song--progress {\n  width: 100%;\n  margin-top: 15px;\n}\n.music-player h1, .music-player h2, .music-player h3,.music-player h4, .music-player h5, .music-player h6, .music-player p {\n  margin: 0; padding: 0;\n}\n.music-player li { list-style: none; }\n\n```\n\n&emsp;&emsp;修改`player.js`里`this.songs`的歌曲信息，把音乐换成自己的，接着三连即可。\n>本地浏览可能音乐的进度条无法拖动或者一拖动音乐就回到最开头，问题不大，推送上去就正常了。\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"归档、分类、标签页文章卡片加上所属分类和标签","url":"/article/a19bb7fb.html","content":"\n# 前言\n&emsp;&emsp;如图，上面修改前，下面修改后。\n<img src=/images/23-2.webp width=\"90%\" height=\"90%\">\n\n# 实现\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\includes\\mixins\\article-sort.pug`\n```\n.article-sort-item-info\n    .article-sort-item-time\n        time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n        a.article-sort-item-title(href=url_for(article.path) title=title)= title\n+    .article-meta-wrap\n+        if (theme.post_meta.page.categories && article.categories.data.length > 0)\n+            span.article-sort-item-categories\n+                i.iconfont.icon-fenlei//- 记得改成自己的图标\n+                each item, index in article.categories.data\n+                    a(href=url_for(item.path)).article-meta__categories #[=item.name]\n+                    if (index < article.categories.data.length - 1)\n+                       i.fas.fa-angle-right\n+        if (theme.post_meta.page.tags && article.tags.data.length > 0)\n+            span.article-sort-item-tags\n+                i.iconfont.icon-biaoqian//- 记得改成自己的图标\n+                each item, index in article.tags.data\n+                    a(href=url_for(item.path)).article-meta__tags #[=item.name]\n+                    if (index < article.tags.data.length - 1)\n+                        span.article-meta__link #[='•']\n+        .article-sort-item-time\n+            time.post-meta-date-created(datetime=date_xml(article.date) title=_p('post.created') + ' ' + full_date(article.date))= date(article.date, config.date_format)\n\n```\n\n&emsp;&emsp;增加css：根据自己的实际样式情况进行微调，没有通用css。\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"控制指定单页的背景样式","url":"/article/eb3a4679.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客单页，无论是哔哔，友链，还是关于页，page的背景都是透明的，一开始我以为是在单页的index.md里单独引入css，后来才知道，是直接`#page{background:transparent;}`,这只会让所有非文章、归档、分类、标签的单页背景透明。\n\n&emsp;&emsp;这好啊，果断抄走，然后不出意外，有些单页变得很难看，因为没关侧边栏（侧边栏没透明，page透明了），或因为背景透明后字看不清（友链页），反正，我需要能单独控制单页page的背景样式，说干就干，让不同单页加上不同class，css控制这些class即可。\n<img src=/images/22-1.webp width=\"40%\" height=\"40%\">\n\n***\n\n# 实现\n## 方案一\n&emsp;**让指定单页背景样式相同(如透明)**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制哪些单页的背景就加上is_current('<单页路径>')\nblock content\n+  - let transparent = (is_current('/bb/') || is_current('/charts/')) ? true : false\n-  #page\n+  #page(class= (transparent === true) ? 'transparentpage' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug 这里是让指定单页的背景都透明\n.transparentpage{\n    background:transparent!important;\n}\n\n```\n\n## 方案二\n&emsp;**控制不同单页有不同背景样式**\n&emsp;&emsp;修改`\\themes\\butterfly\\layout\\page.pug`\n```pug 需要控制更多单页就仿照格式写\nblock content\n+  - let bb = is_current('/bb/') ? true : false\n+  - let charts = is_current('/charts/') ? true : false\n-  #page\n+  #page(class= (bb === true) ? 'bb-transparent' : '')(class= (charts === true) ? 'charts-transparent' : '')\n\n```\n\n&emsp;&emsp;然后写css：（别漏了!important）\n```pug\n.bb-transparent{\n    background:transparent!important;\n}\n.charts-transparent{\n    background:blue!important;\n}\n\n```\n\n&emsp;&emsp;此方法存在一个问题：\n&emsp;&emsp;hexo g和hexo s时，会提示:You should not have pug tags with multiple attributes.（您不应该使用具有多个属性的pug标记）\n&emsp;&emsp;这是因为我尝试多次class=()，但实际上，因为路径是唯一的，这不会导致出问题，对hexo渲染没有影响。\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Butterfly给首页首个文章卡片加个class","url":"/article/dbde845d.html","content":"\n# 前言\n&emsp;&emsp;看[@heo](https://blog.zhheo.com/)的博客首页，他的第一个文章卡片是其余卡片宽度的两倍，F12可知是首页的首个文章卡片多了一个class，虽然我的文章卡片暂时没这需求，但刚好有人问怎么才能控制首页第一个文章卡片的样式，也刚好我有思路，就实现一下吧\n&emsp;&emsp;关键就是怎么给首个文章卡片加一个class，我想到了和之前[给文章卡片加上最新文章标志](https://www.chuckle.top/article/2ed7d622.html)差不多的操作\n<img src=/images/21-2.webp width=\"100%\" height=\"100%\">\n***\n\n# 实现\n&emsp;&emsp;先看原来post-ui的结构:``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    .recent-post-item//要在这里加个calss\n    //后面就是文章卡片的具体的内容\n\n```\n\n&emsp;&emsp;可以改成这样，就能将首页第一个文章卡片和其余卡片分开渲染成html，自然，加个class就轻而易举了\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    if (firstpost !== 1 && is_current('/'))\n      - var firstpost = 1\n      .recent-post-item.firstpost-item\n      //首页首个文章卡片的具体的内容（cv原来的就行）\n    else\n      .recent-post-item\n      //其余文章卡片的具体的内容（cv原来的就行）\n\n```\n\n&emsp;&emsp;这样，首页第一个文章卡片就会多一个``firstpost-item``class，控制这个class就能控制样式了\n<img src=/images/21-1.webp width=\"40%\" height=\"40%\">\n\n&emsp;&emsp;而且这样改完pug，首页第一个文章卡片有更多的操作空间，可以完全和其余卡片长得不一样，修改具体内容里的源码即可\n***\n\n# 优化\n&emsp;&emsp;[@heo](https://blog.zhheo.com/)的代码结构优化版本（适合无需对首页第一个卡片进行定制化）\n```pug\nmixin postUI(posts)\n  each article , index in page.posts.data\n    - let lastPost = firstpost !== 1 && is_current('/') ? true : false\n    - var firstpost = 1\n    .recent-post-item(class= (lastPost === true) ? 'firstpost-item' : '')\n    \n```\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Butterfly文章卡片加上最新文章标志","url":"/article/2ed7d622.html","content":"\n# 前言\n&emsp;&emsp;昨天[@Leonus](https://blog.leonus.cn/)大佬用js给首页最新的文章卡片加上了``最新``标志:[几行代码实现最新文章标志 | Leonus](https://blog.leonus.cn/2022/newpost.html)\n&emsp;&emsp;不过每次切换到首页都要执行这个js，不然最新标志就不显示，开启了pjax之后,怎么让这js每次切换到首页都执行是个问题，而且每次都执行也会多吃一些性能\n\n&emsp;&emsp;因为butterfly是按创建时间顺序排序的，最上面的卡片就是最新文章，直接修改文章卡片源码，给第一个卡片加上``最新``标志就行了（当然还要排除手动置顶的文章）\n&emsp;&emsp;这样pug渲染成html时，``最新``标志就写死在那了\n<img src=/images/20-1.webp width=\"30%\" height=\"30%\">\n***\n\n# 实现\n>我这实现看起来挺笨，有大佬有更好的实现方式不\n\n1. 修改``\\blog\\themes\\butterfly\\layout\\includes\\mixins\\post-ui.pug``&emsp;加上三行：\n```pug\n.recent-post-info\n+    if (numberone !== 1 && is_current('/') && (!article.top || (article.new && article.top)))\n+        span.newPost 最新\n+        - var numberone = 1\n```\n\n2. 在你的自定义css文件中，添加如下代码：\n```css\n/* 最新文章图标 */\n.newPost {\n    position: absolute;\n    top: 0;\n    color: rgba(255, 255, 255, 0.92);\n    padding: 0 15px;\n    background-color: #49b0f5b9;\n    border-radius: 0 0 10px 10px;\n    right: 40px;\n}\n@media screen and (max-width:600px){\n  .newPost {\n    right: 0px;\n    padding: 0 12px;\n    border-radius: 0 10px 0px 10px;\n}\n}\n```\n\n***\n\n# 使用\n&emsp;&emsp;当首页没有置顶时，会给第一个卡片加上最新标志\n&emsp;&emsp;当首页有置顶时，会给非置顶的第一个卡片加上最新标志\n\n&emsp;&emsp;显然，这里有bug，如果置顶里的文章就是最新的咋办？\n&emsp;&emsp;只需要在文章头部加上``new: true``就行了\n\n&emsp;&emsp;稍微有点麻烦，所以，建议最新的文章就没必要置顶了，反正不置顶也在第一个\n```\n---\ntitle: aaaaaaaaaa\ntop: 1\n+ new: true\n---\n```\n\n***\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"小米妙享--MIUI的生态互联","url":"/article/eb38f645.html","content":"\n# 引言\n&emsp;&emsp;不少人去年就听说了这个功能，作为小米产品生态构建的重要一环（全局设备互联互通），这个功能我却迟迟没去更新使用，因为它与miui+的割裂导致使用起来比较繁琐，也因为它把平板排除于外，当然最主要是我实在没有这么多设备需要去``流转``。\n&emsp;&emsp;但在最近的更新中，``小米妙享``不仅将miui+给整合进了`妙享中心`，还带上了小米平板5系列，为平板与电脑的互联互通增加了几个重要的功能。\n\n# 如何安装\n&emsp;&emsp;我喜欢小米的一点，就是它将系统功能都作为一个个软件的形式打包，不同批次的软件之间兼容性也不错，除非跨安卓版本才能实现的功能（例如米版的全局手写，这个基于安卓12，自然安卓11用不了），都可以通过安装或更新软件来使用新功能，正好，小米妙享就是这样一个安装即用的系统功能。  \n\n## 平板/手机端\n&emsp;&emsp;我的平板还在13.0.6这个稳定版养老，下载安装最新的`miui+`、`投屏`、`小米互联通信`,手机端就搞定了(没有资格就刷个`Miui解锁小米妙享模块`)。\n\n## 电脑端\n&emsp;&emsp;目前电脑端软件有限制，只有小米电脑上才能使用，但这难不倒酷友们，跟着此帖即可在电脑端安装好妙享中心：[最新miui+（小米妙享）PC版安装及配置教程](https://www.coolapk.com/feed/38357299?shareKey=MzdiMWMzNjNmMTgwNjJmYTcyYmI~&shareUid=4137393&shareFrom=com.coolapk.market_12.0.2)。\n\n# 使用体验\n\n## 互联\n&emsp;&emsp;电脑打开蓝牙，平板打开蓝牙、wifi、小米互传，让设备处于同一网络下，电脑端点击连接，等待`1-2秒`，很快即可连接上。且蓝牙wifi我一般保持常开，平板使用时也是手机或电脑给平板开热点，基本能做到需要就点击连接。\n<img src=/images/19-1.webp width=\"60%\" height=\"60%\"><img src=/images/19-3.webp width=\"60%\" height=\"60%\">\n\n## 平板作为电脑副屏\n&emsp;&emsp;这个功能是这次妙享更新后给米版上的新功能，在连接成功后可以看到两种副屏方式，作为镜像屏，或者扩展屏。选择任意一种副屏方式，同样等待2秒，就可完成副屏的启动。\n&emsp;&emsp;作为一个`无线可触摸`的副屏，使用起来非常舒适。\n<img src=/images/19-2.webp width=\"60%\" height=\"60%\">&emsp;&emsp;侧边栏有一些快捷键：“返回桌面”“多任务”“保存”“返回/撤销上一步操作”“保存截图”“屏幕键盘”“退出”。\n\n### 作为镜像屏\n&emsp;&emsp;利用秒表测试有0.04s延迟（屏幕一半播视频，一半秒表计时，拍照算时差，确保符合正常使用的延迟），实际体验下延迟确实可忽略不计，分辨率1920*1080（等同电脑屏幕分辨率），但帧率在40到60之间波动，习惯了120帧确实有点不舒服，不过也远胜我之前用的spacedesk。\n<img src=/images/19-4.webp width=\"60%\" height=\"60%\">&emsp;&emsp;小米妙享实际上是一个软件，那当然可以上滑挂在后台，或者挂个小窗在前台。  \n\n<img src=/images/19-5.webp width=\"60%\" height=\"60%\">&emsp;&emsp;在电脑端还可以设置侧边栏的位置、使用米板作为电脑的音频输出等。\n\n<img src=/images/19-6.webp width=\"60%\" height=\"60%\">\n\n### 作为扩展屏\n&emsp;&emsp;作为扩展屏时与镜像屏时差不多，同样有低延迟、高分辨率（作为扩展屏时分辨率1920*1200），同样可以挂后台挂小窗，设置侧边栏的位置、使用米板作为电脑的音频输出等。\n&emsp;&emsp;但此时帧率在30到50之间波动，可以感觉到鼠标拖动的略微不顺畅的卡顿，且窗口在平板与电脑直接拖动时，大小变化还有待优化，经常拖到平板还得再手动调小窗口大小。\n<img src=/images/19-7.webp width=\"60%\" height=\"60%\">\n&emsp;&emsp;无论是作为镜像还是扩展屏，吃电脑资源都不多。\n<img src=/images/19-10.webp width=\"70%\" height=\"70%\">\n\n## 平板投屏到电脑\n&emsp;&emsp;应用流转仅限于小米的设备，自然投屏也需要小米笔记本才行，不过酷友[@迷璐](https://www.coolapk.com/u/1189245)的模块可以让其它品牌的电脑也出现在妙享界面，只需要将平板画面拖到电脑的气泡上，1-2秒后，电脑上就有平板的投屏窗口了，投屏后平板可关闭屏幕。\n<img src=/images/19-11.webp width=\"60%\" height=\"60%\">&emsp;&emsp;投屏窗口可最大化可最小化，利用秒表测试有0.07s延迟（主界面播视频，小窗秒表计时，拍照算时差，确保符合正常使用的延迟），分辨率至少有1080p以上，帧数稳稳50-60帧。\n\n<img src=/images/19-12.webp width=\"60%\" height=\"60%\">&emsp;&emsp;值得注意的点是，这不是简单的投屏，投屏后，不仅平板的画面会在电脑上出现个窗口，平板上的所有音频也会用电脑的喇叭输出，而且可以直接使用电脑的键盘、鼠标去控制、操作平板。\n\n## 互通\n&emsp;&emsp;平板端截图，电脑会弹出有图和保存按键的小悬浮窗。\n<img src=/images/19-8.webp width=\"40%\" height=\"40%\">&emsp;&emsp;平板端或电脑端复制文字内容，另一个设备会同步这个内容到剪切板，并弹窗提示，且电脑端的弹窗会显示复制的文字内容。当任意一设备复制的是网址时，悬浮窗还会有直接打开网站的按键。\n\n<img src=/images/19-9.webp width=\"60%\" height=\"60%\">\n\n### 电脑与平板互传文件\n&emsp;&emsp;平板长按文件点分享，选择电脑即可；电脑端使用用小米互传向平板传文件，两种操作都非常方便且快速。\n<img src=/images/19-13.webp width=\"70%\" height=\"70%\">\n\n# 使用感受\n&emsp;&emsp;在简单上手平板与电脑之间的妙享后，可以确定，我以后将经常用到它的功能，实际上我还体验了平板-手机-电脑的三方互联互通，不过任意两个设备互联后，另一个设备就会断开连接（虽然重连很快，但还是很影响体验），所以三方互联的体验并不好，但平板-手机、手机-电脑之间的妙享体验也不错。\n&emsp;&emsp;可以看得出来MIUI还是有认真去做互联互通生态的，未来可期。\n\n# 不足之处\n1. 多设备同时互联体验差。\n2. 作为扩展屏与电脑之间拖动软件窗口，窗口大小自适应效果不好。\n3. 虽然博主安装起来较轻松，但不少酷友倒在了电脑硬件或其它配置上。\n4. 依赖核显（考虑考虑没核显或核显弱的笔记本？）。\n5. 平板投屏到电脑不能像手机与电脑的互联那样，直接拖文件传输。\n6. 手机应用流转到平板居然开倒车！直接全屏，而不是像之前那样在平板上弹出小窗。","tags":["小米妙享","MIUI"],"categories":["其它"]},{"title":"JavaWeb笔记--寄途的初始","url":"/article/7c1f73d5.html","content":"\n咕咕咕（\n","tags":["JAVA","JavaWeb"],"categories":["学习笔记"]},{"title":"JavaSE查缺补漏笔记","url":"/article/3c6a38d9.html","content":"\n>跟着翁恺或者学校的进度学完的JavaSE，如泛型、I/O、线程、映射、反射等等大部分没有提到或只是简略介绍，想要从JavaSE衔接上JavaEE，这些知识不可跳过。\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"超星学习通数据泄露事件记录","url":"/article/af84a159.html","content":"\n# 事件时间轴\n{% timeline 时间轴 ,blue %}\n<!-- timeline 2022-06-20 -->\n1. 学习通被爆有`1.7亿`师生账号信息`数据泄露`  \n包括手机号码、邮箱、姓名、学校、班级、明文密码等信息  \n随后，热搜词条`#学习通数据库疑发生信息泄露#`被撤,词条内容被屏蔽\n<div><img src=/images/13-1.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 上午-->\n`#学习通#`词条登顶微博热搜第一\n很多人发现自己学习通的使用量多达上万、几十万次（图为博主的次数，2万次）\n<div><img src=/images/13-2.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 15:45-->\n学习通就泄露事件做出声明：`目前还未发现数据泄露，确认不存在明文密码泄露。`\n<div><img src=/images/13-3.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n<!-- timeline 2022-06-21 16:17-->\n学习通就异常使用量做出声明：`正常现象。`\n<div><img src=/images/13-4.webp width=\"40%\" height=\"40%\"></div>\n\n<!-- endtimeline -->\n{% endtimeline %}\n\n***\n\n# 事件相关\n1. 2020年超星学习通就被[国家信息安全漏洞共享平台(cnvd)](https://www.cnvd.org.cn/)警告存在`信息泄露漏洞`\n{% link 超星学习通App存在信息泄露漏洞, https://www.cnvd.org.cn/flaw/show/CNVD-2020-61119, %}\n<div><img src=/images/13-5.webp width=\"40%\" height=\"40%\"></div>\n\n2. 著名蓝色机器人发通知与投票：\n<div><img src=/images/13-6.webp width=\"40%\" height=\"40%\"></div>\n\n3. 博主已中招\n<div><img src=/images/13-7.webp width=\"40%\" height=\"40%\"></div>\n\n4. 学习通的一些`免责条款`：总之，无责\n<div><img src=/images/13-8.webp width=\"40%\" height=\"40%\"></div>\n\n\n***\n","tags":["其它"],"categories":["其它"]},{"title":"记一次超声波避障小车比赛","url":"/article/81935dcb.html","content":"\n>去年第一次红外循迹比赛的时候我还没整博客，第二次便记录一下吧\n\n# 比赛简介\n学校机械院举办的智能小车比赛，一学期一次，上次是红外循迹，这次是超声波避障  \n小车是学院统一采购的，第一次去比赛时拿到的是散件，51单片机、电阻、其它芯片等，都得自己焊  \n\n***\n\n# 关于队伍\n一位机械院的同学在酷安私信我参不参加智能小车比赛，我那时还不认识他，但想着反正闲着也是闲着，参加点活动也好，便一拍即合，后面他又拉来了商学院的一位男同学和两位女同学  \n第一次比赛，我们也是唯一有商学院同学的队伍（其它队伍队均两机械两计科），不过我们队也是女同学最多的，Buff加满   \n\n队名我提议是秋名山车队，又是一拍即合  \n\n***\n\n# 关于比赛\n小车在上次比赛时就已搞好，所以这次重点在写个超声波避障程序烧进去  \n作为队里唯一的计科同学，这个程序当然得我搞了  \n但我倒也摸鱼，程序不难，测试过一次没毛病，剩下就是数值的微调（这就是我比赛前一天晚上才去调的原因么（误））\n\n***\n\n# 比赛过程\n过程简单，就是一遍一遍测试，然后改改数值，调调机制，然后队伍抽签轮流上，看谁跑的时间短  \n上午7个队（本来12个队，弃权了5个，新报名的队伍焊坏小车的不少），取前三进入下午复赛  \n\n***\n\n# 结果\n第一次的比赛我们第二，这次还是第二，属于万年老二了  \n上次有初赛复赛都有奖册，我拿了一本，这次只有复赛一本册子，给了队里一位女同学，争取以后人手一本  \n\n***\n\n# 一些图片\n<div><img src=/images/12-1.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=/images/12-2.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=/images/12-3.webp width=\"100%\" height=\"100%\"></div>\n\n<div><img src=/images/12-4.webp width=\"100%\" height=\"100%\"></div>\n\n***","tags":["Chuckle"],"categories":["Chuckle"]},{"title":"FakeLocation模拟校园跑教程","url":"/article/c5d354fd.html","content":"\n我们学校用的是运动世界校园，所以就用这个软件为例，其他软件差不多  \n博主测试设备：红米k40安卓11、红米6pro安卓9  \n>吐槽：这软件，什么都往里塞，天天更新加广告（一指禅干掉）  \n\n# 准备工作\n1、首先是有面具**Root**，而非小米官方等残废root  \n2、下载万恶之源：运动世界校园  \n3、下载安装[FakeLocation1.3.0.2版本](https://wwm.lanzoul.com/iMHUo057ibyb)  \n4、下载安装[隐藏应用列表xp模块](https://wwm.lanzoul.com/iQ6lq057irkd)我使用的版本1.6较老，但能稳定用我也没去升级  \n5、安装lsp/xp框架  \n6、下载安装[Godvip](https://wwm.lanzoul.com/i8RYM057ibzc)  \n\n***\n\n# 隐藏防检测\n\n## 运动世界校园权限设置\n确保权限设置与图一致，关闭miui的模糊定位  \n<div><img src=/images/11-1.webp width=\"90%\" height=\"90%\"></div>\n\n## 隐藏root\n面具本身随机包名安装  \n面具hide对运动世界校园全勾选（如果是24版本的面具，自行去酷安找shamiko模块隐藏root教程，我还没升到24，因为我用hide就能很好地隐藏root）  \n\n## 隐藏应用列表设置\n推荐先看酷安详细图文：[隐藏应用列表使用教程 Pro](https://www.coolapk.com/feed/34458057?shareKey=YjBlYzcxNDgwMzYwNjI4OGIzZmM~)  \n\n简单速通：  \n1、lsp/edxp启用**隐藏应用列表**  \n2、也许需要重启手机  \n3、点击模板管理，启用所有隐藏方式  \n4、选择要隐藏的应用，将FakeLocation、面具、lsp等搞机应用勾选  \n5、对运动校园应用模板  \n<div><img src=/images/11-2.webp width=\"100%\" height=\"100%\"></div>\n\n## 破解FakeLocation\nlsp启用Godvip，模块对FakeLocation起作用  \n\n## FakeLocation设置\n给FakeLocation软件Root权限  \nFakeLocation设置页只打开**模拟GPS信号**  \n<div><img src=/images/11-3.webp width=\"50%\" height=\"50%\"></div>\n\n## 如何模拟跑\n首先到一个较空旷，能接收到gps信号的地方（宿舍阳台、宿舍走廊），拿个椅子坐下，手机关闭wifi（可以开启蓝牙和数据）  \nFakeLocation选择**要模拟的位置**到跑道，当然具体在哪无所谓  \n打开运动软件，**待运动软件接收到gps信号**提示可以开始跑，返回FakeLocation软件，点击**启动模拟**（第一次打开需要等待一会，建议在模拟跑前先开关一次预热），并**打开摇杆**  \n\n摇杆设置：  \n摇杆里的**模拟gps信号**和**步频模拟**都得关掉，不能打开！不能打开！不能打开！   \n<div><img src=/images/11-4.webp width=\"100%\" height=\"100%\"></div>\n\n接着返回运动软件，你会发现显示的位置瞬移到了之前选择的模拟位置处，然后开始运动，要去哪就**用摇杆摇**到哪，步频可以使用其它软件模拟，但**建议抖手**  \n跑完后先结束运动，关闭运动软件，再停止位置模拟  \n\n***\n\n# 可能出现的问题\n1、当摇杆回到中间时（速度为0），运动软件会提示gps信号弱，这是正常现象  \n2、启动模拟后，运动软件上显示的位置没变：杀掉运动软件和FakeLocation，重新操作一次  \n3、启动模拟后，运动软件上显示的位置变了，但一开始运动位置就变回原来位置：杀掉运动软件和FakeLocation，重新操作一次  \n4、被检测到环境异常4：FakeLocation没隐藏好、运动软件检测到gps信号长期未变。请自查有无和教程操作不同的地方  \n\n# 温馨提示\n\n>如有问题可在评论区回复或在酷安找我\n>本教程虽然目前还可行，博主自用了两个学期也没被检测到一次，但安卓设备众多，系统繁杂，不确保教程的通用性\n>Root手机导致手机变砖、假跑被检测到影响体育成绩等后果，博主不承担任何责任\n\n***\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(3)","url":"/article/8636f786.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(2)](https://www.chuckle.top/article/9f2dc6c7.html)\n\n# Swing\n**Swing**是一个为Java设计的GUI工具包，是java的基础类（import javax.swing.*;）  \n在Swing中，所有我们在界面中看到的东西都是**部件**（组件）  \n\n其中容器是一种特殊的部件\n部件可以被放进容器中，当然容器也能放进容器中  \n\nSwing提供了一个底层容器类JFrame，即整个窗口    \n```java JFrame中常用的方法\n//创建一个无标题的窗口\nJFrame()\n//创建标题为s的窗口\nJFrame(String s)\n//设置窗口的初始位置是(a,b),即距屏幕左面a个像素，距屏幕上方b个像素，窗口的宽是width,高是height。\npublic void setBounds(int a,int b,int width,int height)\n//设置窗口的大小。\npublic void setSize(int width,int height)\n//设置窗口的位置，默认位置是(0,0)。\npublic void setLocation(int x,int y)\n//设置窗口是否可见，窗口默认是不可见的。\npublic void setVisible(boolean b)\n//设置窗口是否可调整大小，默认可调整大小。public voiddispose()撤销当前窗口，并释放当前窗口所使用的资源。\npublic void setResizable(boolean b)\n//撤销当前窗口，并释放当前窗口所使用的全部资源\npublic void dispose()\n//设置窗口的扩展状态\npublic void setExtendedState(int state)\n//其中参数state取JFrame类中的下列类常量:\nMAXIMIZED_HORIZ (水平方向最大化)，\nMAXIMIZED_VERT (垂直方向最大化)，\nMAXIMIZED_BOTH (水平、垂直方向都最大化)。\n//该方法用来设置单击窗体右上角的关闭图标后，程序会做出怎样的处理，\npublic void setDefaultCloseOperation(int operation)\n//其中的参数operation取JFrame类中的下列int型static常量，程序根据参数operation取值做出不同的处理:\nDO_NOTHING_ON_CLOSE(什么也不做)，\nHIDE_ON_CLOSE (隐藏当前窗口)，\nDISPOSE_ON_CLOSE (隐藏当前窗口，并释放窗体占有的其他资源)，\nEXIT_ON_CLOSE (结束窗口所在的应用程序)\n```\n\n## add\n通过add把一个部件加到一个容器中  \n部件被加到容器后，就受这个容器所管理  \n容器管理部件的方式叫**布局管理器**  \nJFrame默认采用的布局管理器叫**BorderLayout**,默认把部件放到CENTER  \n```java\ntheView = new View(theField);//theView是一个容器\nJFrame frame = new JFrame();//创建一个底层容器\nframe.add(theView);//把theView容器加到底层容器中。默认为中间\nJButton btnstep =new JButton(\"单步\");//btnstep是一个按钮部件\nframe.add(btnstep, BorderLayout.SOUTH);//把btnstep部件加到底层容器中，且放到南边（窗口最下面）\n```\n\n## BorderLayout\nBorderLayout把整个容器划分为五个部分  \n<div><img src=/images/7-13.webp width=\"60%\" height=\"60%\"></div>\n\n后面放进去的部件会替换掉相同位置的部件（这就是为什么之前界面中只剩下一个按钮了）  \n当有部分没有部件时，其他部分会膨胀，将那个位置所占据  \n\nBorderLayout会根据部件里面的东西来帮我们计算，这个部件需要占据多大的空间 \n\n## 消息机制\n现在我们有了一个按下去没反应的按钮  \n如何让按钮按下去有反应？程序如何知道按钮被按下去了？  \n用户在图形界面做了一些操作，通过一些路径让程序知道，这个路径叫做**消息机制**  \n\nJava的Swing类实现了一个有意思的消息机制  \n```java\nJButton btnstep =new JButton(\"单步\");\nframe.add(btnstep, BorderLayout.SOUTH);\nbtnstep.addActionListener(new ActionListener(){\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tSystem.out.println(\"成功按下!\");\n\t}\n});\n```\n运行一下，当我们点击一次按钮，控制台都会输出一次“成功按下!”\n\n现在程序已经知道按钮被按下，且在上面的古怪代码中能成功做一些我们期望程序做的事（输出点东西）  \n我们可以把输出点东西换成其它事情，在狐狸和兔子中，step()函数控制单步  \n我们只需要做下面一些动作，就能让按钮控制单步  \n```java\nprivate JFrame frame;//把frame从FoxAndRabbit()中拿出来，让它变为FoxAndRabbit类中的成员变量\n···\n//JFrame frame = new JFrame();\nframe = new JFrame();\n···\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n···\n//fab.start(500);把main里的这句去掉，不让程序主动地开始\n``` \n现在每按一次按钮，程序就会运行一步  \n\n按钮自己有代码，知道自己被按下去了，但按钮作为一个早已经定好的类不可能有代码去调用step()\n但实际效果就是，每按一次按钮，step()就会被调用一次，这是怎么做到的？  \n<div><img src=/images/7-14.webp width=\"90%\" height=\"90%\"></div>\n\nJButton类提供了一个接口，只要实现了这个接口的类的对象，都可以通过**addActionListener()**方法**注册**给JButton，当按钮发现自己被按下去了，就会检查有没有东西注册在按钮那，接着找到重写的**actionPerformed()**，这样JButton就知道step()了  \n注册进去的东西，是运行时候一个动态的对象  \n\n这就是**反转控制**（Swing的消息机制）：\n·由按钮公布一个守听者接口和一对注册/注销函数  \n·你的代码实现那个接口，将守听者对象注册在按钮上  \n·一旦按钮被按下，就会反过来调用你的守听者对象的某个函数   \n\n## 内部类、匿名类\n刚刚实现接口的代码看起来十分奇怪\n```java\nbtnstep.addActionListener(new ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n});\n```\n可以换种写法\n```java\n//在类中新增这个类\nprivate class stepListener implements ActionListener {\n\t@Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n\t\tframe.repaint();\t\t\t\n\t}\n}\n···\n//原来的代码替换为这句\nbtnstep.addActionListener(new stepListener());\n```\n在一个类的内部，再定义一个类，这个类就叫**内部类**  \n内部类可以**直接访问**其所处类的**所有**成员  \njava的内部类也是类的成员  \n外部是函数时，只能访问那个函数里**final**的变量   \n\n用匿名类实现接口\n```java\nnew ActionListener(){\n    //实现了ActionListener这个接口的匿名类\n    @Override\n\tpublic void actionPerformed(ActionEvent e) {\n\t\tstep();\n        frame.repaint();\n\t}\n}\n```\n在**new对象**的时候给出的**类的定义**形成了匿名类  \n匿名类可以**继承某类**，也可以**实现某接口**  \nSwingl的消息机制广泛使用匿名类  \n外部是函数时，只能访问那个函数里**final**的变量  \n\n为什么需要匿名类？\nSwing的消息机制决定了，每个部件发出的消息，都需要新的类去实现接口，然后去接收消息，当部件很多时，给每个类起名字非常麻烦   \n\n***\n\n# 一个课程表\n做一个课程表程序，它有8行7列，有表头表示7天，每个格子用户能自己编辑内容  \n效果是这样：  \n<div><img src=/images/7-15.webp width=\"60%\" height=\"60%\"></div>\n\n有前面Swing的基础，我们知道想要有一个窗口，需要用到JFrame类，来创建一个底层窗口  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n现在运行，只有一个空空的窗口，一个空空的容器，我们需要往里面放部件  \n想要一个表格，那就放一个表格进去  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n\t\tJTable table = new JTable());//声明一个表格\n        frame.add(table);//把表格放进去\n        frame.pack();//自动调整窗口大小\n        frame.setVisible(true);//显示窗口\n    }\n}\n```\n运行一下，还是啥都没有，因为我们还没初始化表格，还没给表格它要的数据  \n\n用JTable类可以以表格的形式显示和编辑数据。  \nJTable类的对象并不存储数据，它只是数据的表现。  \nJTable实现了数据与表现的分离  \n\n新建一个KCBData类，作为表格的数据  \n让这个类实现一个叫TableModel的接口  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    @Override\n    public int getRowCount() {\n        return 0;\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 0;\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return false;\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return null;\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n\n    }\n}\n```\nTableModel接口是由JTable提供给我们的  \nTableModel告诉我们，只要实现了它，就能作为数据交给JTable  \n\n完善一下KCBData  \n```java KCBData.java\npackage kcb;\n\nimport javax.swing.event.TableModelListener;\nimport javax.swing.table.TableModel;\n\npublic class KCBData implements TableModel {\n\n    private String[] title = {\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"};//表格标题\n    private String[][] data = new String[8][7];//真正放7天8节课的数据结构\n    //这个data数组里面都是String类型的管理者，所以需要初始化每个管理者去管理一个String类型的空数据\n    public KCBData() {\n        //构造方法,初始化数据,每一行的数据都是空的,即没有数据,这样才能显示表格,否则会报错\n        for (int i = 0; i < data.length; i++) {\n            for (int j = 0; j < data[i].length; j++) {\n                data[i][j] = \"\";//让每一个单元格都是空的\n            }\n        }\n    }\n    @Override\n    public int getRowCount() {\n        return 8;//表格有8行\n    }\n\n    @Override\n    public int getColumnCount() {\n        return 7;//表格有7列\n    }\n\n    @Override\n    public String getColumnName(int columnIndex) {\n        return title[columnIndex];//返回一个表头\n    }\n\n    @Override\n    public Class<?> getColumnClass(int columnIndex) {\n        return String.class;//告诉表格每列的数据类型,每一个都是String类型\n    }\n\n    @Override\n    public boolean isCellEditable(int rowIndex, int columnIndex) {\n        return true;//每个单元格都可以编辑\n    }\n\n    @Override\n    public Object getValueAt(int rowIndex, int columnIndex) {\n        return data[rowIndex][columnIndex];//将每一个单元格的数据返回，让表格拿到\n    }\n\n    @Override\n    public void setValueAt(Object aValue, int rowIndex, int columnIndex) {\n        data[rowIndex][columnIndex] = (String) aValue;//将每一个单元格的数据设置为aValue,即用户输入的数据\n    }\n\n    @Override\n    public void addTableModelListener(TableModelListener l) {\n        //添加监听器\n    }\n\n    @Override\n    public void removeTableModelListener(TableModelListener l) {\n        //移除监听器\n    }\n}\n\n```\n现在表格能拿到数据了，它知道该怎么画一个表格  \n但运行一下，还是没有表头  \n\n这是因为JTable组件显示数据时，如果直接将其放置在Frame的contentPane中则表头一行会显示不出来，如果将其放置在JScrollPane中显示数据的话，表头会自动显示出来。  \n暂时无需关心为什么  \n\n再完善下KCB类，一个课程表就完成了  \n```java KCB.java\npackage kcb;\n\nimport javax.swing.*;\n\npublic class KCB {\n\n    public static void main(String[] args) {\n        JFrame frame = new JFrame();//声明一个窗口\n        JTable table = new JTable(new KCBData());//声明一个表格\n        JScrollPane pane = new JScrollPane(table);//声明一个滚动面板\n        frame.add(pane);//将滚动面板添加到窗口\n        frame.pack();//自动调整窗口大小\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭方式\n        frame.setVisible(true);//显示窗口\n    }\n\n}\n```\n\n## MVC设计模式\n刚刚的课程表结构是这样的  \n<div><img src=/images/7-16.webp width=\"85%\" height=\"85%\"></div>\n\n当JTable决定显示多少列时会调用getColumnCount，当它要显示表头时会调用getColumnName  \n程序运行过程中JTable反过来调用我们自己的KCBData里的方法  \n\n数据由我们自己实现了TableModel的对象来维护，JTable只管表现不管数据  \n\n**MVC**:数据、表现和控制三者分离，各负其责  \n·M=Model（模型)  \n·V=View(表现)  \n·C=Control(控制)  \n\n模型：保存和维护数据，提供接口让外部修改数据，通知表现需要刷新  \n表现：从模型获得数据，根据数据画出表现  \n控制：从用户得到输入，根据输入调整数据  \n\n<div><img src=/images/7-17.webp width=\"85%\" height=\"85%\"></div>\n\n不是由接收到用户输入的代码去修改界面上的显示，而是去修改内部的数据，内部的数据去触发界面的更新  \n\n这样做的好处：每一部分都很单纯，尤其是View表现，只管拿到想要的数据去表现，至于数据是怎么更新，怎么生成的，它统统不管  \n\n在代码实现中，View和Control通常在同个表达界面的类中实现，因为表现和用户控制都是在界面中完成的，这和MVC并不矛盾，只是在具体实现MVC模式时的技巧  \n\n***\n\n# Exception异常\n异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。  \n比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。  \n\n写出下面的程序，idea的编辑器不会指出数组越界的错误，但运行程序控制台会抛出异常  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n}\n```\n\n```java 异常\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat ArrayIndex.main(ArrayIndex.java:4)\n```\n在main里面有Exception异常，问题出在在ArrayIndex的第四行，问题叫做ArrayIndexOutOfBoundsException，即数组越界  \n\n## 两种类型的异常与错误\n\n检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。  \n运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。  \n错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。  \n\n异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。  \n\n## 捕获异常\n当代码某一处可能出现问题、可能出现异常，就可以将这块代码放在一个用于捕捉异常的代码块中  \n```java\ntry\n{\n   // 可能出现异常的程序代码\n}catch(ExceptionName e1)//可以多个catch\n{\n   //处理异常的代码\n}catch(ExceptionName e2)\n{\n   //处理异常的代码\n}finally{\n  //无论是否发生异常，finally 代码块中的代码总会被执行。\n  // 程序代码\n}\n```\n使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。try/catch代码块中的代码称为保护代码  \n\nCatch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。  \n如果发生的异常包含在 catch 块中，异常会被传递到该 catch 块，这和传递一个参数到方法是一样.  \n\n将刚刚数组越界的代码用捕捉异常处理  \n```java ArrayIndex.java\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n        a[10] = 10;\n        System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n运行一下\n```java\nerror\n```\n\n异常是程序运行过程中可能出现的问题，现在这个代码是一定会出错的，我们改造一下  \n```java\nimport java.util.Scanner;\n\npublic class ArrayIndex {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        int idx = 0;\n        Scanner in = new Scanner(System.in);\n        idx = in.nextInt();\n        try{\n            a[idx] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n    }\n}\n```\n\n```java 输出\n输入：2\nhello\n输入：12\nerror\n```\n\n## 异常处理机制\n把可能发出异常的代码放到try里，在try后面用catch去匹配可能出现的异常类型。  \n当try里的代码没有异常，catch里的代码不会被运行，当try里的代码出现异常，try里后续的代码都不会被执行，会直接调到catch里，在catch里处理完异常，会继续往下运行整个程序，而不会回到try。   \n当匹配到一个catch之后，异常就已经被处理完了，不会再去匹配另一个异常。  \n\n运行下面的代码  \n```java\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;\n        System.out.println(\"hello\");\n    }\n    public static void main(String[] args) {\n        try{\n            f();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n当给数组赋值出现异常后，f方法后面的代码都不会被执行，然后回到调用f方法的地方，try会捕捉到f方法的异常，然后传递给catch  \n\n当有异常被抛出时，可以遵循下面的图来判断该在哪个地方处理这个异常  \n<div><img src=/images/7-18.webp width=\"92%\" height=\"92%\"></div>\n\n```java 示例\npublic class ArrayIndex {\n\n    public static void f(){\n        int[] a = new int[10];\n        a[10] = 10;//抛出ArrayIndexOutOfBoundsException异常\n        System.out.println(\"hello\");//异常后面的代码不会被执行\n    }\n\n    public static void g(){\n        f();//f方法抛出异常，异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void h(){\n        int i = 10;\n        if(i < 100){\n            g();//所处不是函数，跳出一层\n        }//异常没有try捕捉，所处是函数，返回调用者\n    }\n\n    public static void k(){\n        try{\n            h();//有try捕捉异常\n        }catch(NullPointerException e){//没有对应catch匹配，退出到外层\n            System.out.println(\"k error\");\n        }//所处是函数\n        //返回调用者\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();//有try捕捉异常\n        }catch(ArrayIndexOutOfBoundsException e){//有对应catch匹配\n            System.out.println(\"error\");//处理异常\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nerror\nmain\n```\n\n## Java 内置异常类\n\n| 异常  | 描述    |\n| -----    | ------ |\n| ArithmeticException  |当出现异常的运算条件时，抛出此异常。例如，一个整数\"除以零\"时，抛出此类的一个实例|\n|ArrayIndexOutOfBoundsException|用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引|\n|ArrayStoreException|试图将错误类型的对象存储到一个对象数组时抛出的异常|\n|ClassCastException|当试图将对象强制转换为不是实例的子类时，抛出该异常|\n|IllegalArgumentException|抛出的异常表明向方法传递了一个不合法或不正确的参数|\n|IllegalMonitorStateException|抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程|\n|IllegalStateException|在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下|\n|IllegalThreadStateException|线程没有处于请求操作所要求的适当状态时抛出的异常|\n|IndexOutOfBoundsException|指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出|\n|NegativeArraySizeException|如果应用程序试图创建大小为负的数组，则抛出该异常|\n|NullPointerException|当应用程序试图在需要对象的地方使用 null 时，抛出该异常|\n|NumberFormatException\t|当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常|\n|SecurityException|由安全管理器抛出的异常，指示存在安全侵犯|\n|StringIndexOutOfBoundsException|此异常由 String 方法抛出，指示索引或者为负，或者超出字符串的大小|\n|UnsupportedOperationException|当不支持请求的操作时，抛出该异常|\n|下面是Java 定义在 java.lang 包中的检查性异常类：||\n|ClassNotFoundException|应用程序试图加载类时，找不到相应的类，抛出该异常|\n|CloneNotSupportedException|当调用 Object 类中的 clone 方法克隆对象，但该对象的类无法实现 Cloneable 接口时，抛出该异常|\n|IllegalAccessException|拒绝访问一个类的时候，抛出该异常|\n|InstantiationException|当试图使用 Class 类中的 newInstance 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常|\n|InterruptedException|一个线程被另一个线程中断，抛出该异常|\n|NoSuchFieldException|请求的变量不存在|\n|NoSuchMethodException|\t请求的方法不存在|\n\n## 异常方法\n当catch匹配到了异常，实际上是拿到了一个异常类型的对象，我们可以让对象做事情  \n```java\npublic class a {\n    public static void main(String[] args) {\n        int[] a = new int[10];\n        try{\n            a[10] = 20;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n            System.out.println(e.getMessage());\n            System.out.println();\n            System.out.println(e);\n            System.out.println();\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nerror\nIndex 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\njava.lang.ArrayIndexOutOfBoundsException: Index 10 out of bounds for length 10\n\tat a.main(a.java:5)\n\n```\n\n| 异常方法  | 描述    |\n| -----    | ------ |\n|String getMessage()|返回关于发生的异常的详细信息。这个消息在Throwable 类的构造函数中初始化了|\n|Throwable getCause()|返回一个 Throwable 对象代表异常原因|\n|String toString()|返回此 Throwable 的简短描述|\n|void printStackTrace()|将此 Throwable 及其回溯打印到标准错误流|\n|StackTraceElement [] getStackTrace()|返回一个包含堆栈层次的数组。下标为0的元素代表栈顶，最后一个元素代表方法调用堆栈的栈底|\n|Throwable fillInStackTrace()|用当前的调用栈层次填充Throwable 对象栈层次，添加到栈层次任何先前信息中|\n\n## throw再度抛出\n当一个异常已经被处理了，将不会再次被捕捉  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){//k中已经处理了异常\n            System.out.println(\"k error\");\n        }\n    }\n\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){//不会再次处理\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nmain\n```\n但可以通过throw主动地再次抛出这个异常  \n```java\npublic class ArrayIndex {\n    public static void k(){\n        try{\n            int[] a = new int[10];\n            a[10] = 10;\n            System.out.println(\"hello\");\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"k error\");\n            throw e;//捕捉到后在此抛出该异常\n        }\n    }\n    public static void main(String[] args) {\n        try{\n            k();\n        }catch(ArrayIndexOutOfBoundsException e){\n            System.out.println(\"error\");\n        }\n        System.out.println(\"main\");\n    }\n}\n```\n```java 输出\nk error\nerror\nmain\n```\n\n## 为什么要异常机制\n我们希望程序能够根据运行过程中可能出现的各种情况进行处理  \n早期，函数都有特定的返回值，通过函数内很多的if-else来判断返回什么，以返回值来做相应处理  \n\n函数内出现很多与功能无关的if-else，会导致函数可读性很差，而且不利于增加新的功能  \n异常机制将业务逻辑与异常处理在代码上分开  \n```java\ntry{\n    //业务逻辑都放在一起\n    open the file;\n    determine its size;\n    allocate that much memory;\n    read the file into memory;\n    close the file;\n    //如果上面的业务逻辑出了问题，就用下面的catch去处理对应的问题\n}catch(fileOpenFailed){\n    doSomething;\n}catch(sizeDeterminationFailed){\n    doSomething;\n}catch(memoryAllocationFailed ){\n    doSomething;\n}catch(readFailed ){\n    doSomething;\n}catch(fileCloseFailed ){\n    doSomething;\n}\n```\n异常机制最大的好处就是清晰地分开了正常的业务逻辑代码和遇到情况时的处理代码  \n\n## 异常的抛出和声明\n在Java中可以自定义异常。  \n1、所有异常都必须是 Throwable 的子类。  \n2、如果希望写一个检查性异常类，则需要继承 Exception 类。  \n3、如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。  \nRuntimeException继承自Exception  \n\n```java 声明一个异常类型\nclass MyException extends Exception{\n}\n```\n```java 声明一个可能会抛出异常的方法\npublic void f() throws MyException{\n    throw new MyException();//抛出一个MyException异常\n}\n```\n所有调用这个方法的地方都必须套上try-catch，来处理可能发生的异常  \n```java\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"error\");\n    }\n}\n```\n\n可以声明并不会真的抛出的异常,但调用该方法的地方必须处理全部可能抛出的异常  \n```java\npublic void f() throws MyException,YouException{\n    throw new MyException();//抛出一个MyException异常\n}\npublic static void main(String[] args) {\n    try{\n        f();\n    }catch(MyException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"MyError\");\n    }catch(YouException e){//必须catch该方法会抛出的异常类型\n        System.out.println(\"YouError\");\n    }\n}\n```\n\n任何继承了Throwable类的对象都可以被throw  \nException类继承了Throwable，我们通常让自定义的异常类从Exception类得到继承  \n\n```java Exception类的两种构造\n//我们在自定义异常类时也通常会有这两种构造\nthrow new Exception();  \nthrow new Exception(\"HELP\");//可以用这个字符串来表达一些东西  \n```\n\n## catch的匹配机制\n抛出子类的异常会被捕捉父类异常的catch给捉到  \n```java\n//声明两个异常类，YouException继承自MyException\nclass MyException extends Exception{}\nclass YouException extends MyException{}\n\npublic class Test{\n\n    public static void f() throws MyException, YouException {\n        throw new YouException();//抛出一个YouException异常\n    }\n\n    public static void main(String[] args) {\n        try{\n            throw new YouException();\n        }catch(MyException e){//MyException匹配到了它的子类YouException\n            System.out.println(\"YouException\");\n        }\n    }\n}\n```\n如果同时捕捉父类子类两个异常，子类catch要写在父类前面，否则会报错  \n```java\ntry{\n    throw new YouException();\n}catch(YouException e){\n    System.out.println(\"YouException\");\n}catch(MyException e){\n    System.out.println(\"YouException\");\n}\n```\n\n捕捉任何异常\n```java\ncatch(Exception e){\n}\n```\n\n### 运行时刻异常\n像ArrayIndexOutOfBoundsException这样java本身提供的异常是不需要声明的，如果需要去声明这些异常，那么每个方法都将带上一长串的声明    \n但是如果没有适当的机制来捕捉，就会最终导致程序终止  \n\n## 异常遇到继承\n当覆盖一个方法的时候，子类不能声明抛出比父类的版本更多的异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public static void f() throws MyException {}\n    public static void main(String[] args) {}\n}\nclass NewClass extends Test{\n    //NewClass'中的f()'与'a'中的'f()'冲突；重写的方法未抛出NewException'\n    public void f() throws NewException {}\n    //正确的\n    public void f() throws YouException {}\n    public void f() throws MyException {} \n    public void f() {} \n}\n```\n\n在子类的构造方法中，必须声明父类可能抛出的全部异常，可以抛出更多异常,可以是父类抛出异常的父类异常  \n```java\nclass MyException extends Exception{}\nclass YouException extends MyException{}\nclass NewException extends Exception{}\n\npublic class Test {\n    public a() throws YouException{}\n    public static void main(String[] args) {}\n}\n\nclass NewClass extends Test {\n    //允许\n    public NewClass() throws YouException{}\n    public NewClass() throws MyException{}\n    public NewClass() throws MyException,NewException{}\n    //不允许\n    public NewClass(){}\n    public NewClass() throws NewException{}\n}\n```\n\n***\n\n# Stream流\n任何程序都有输入输出，会向用户那读点东西，也会向用户那输出点东西  \n所以，任何一个编程语言都给程序员提供了输入输出的方式，让这个程序可以和外界打交道  \n\n对于java语言，以及之后的新语言，处理输入输出的手段叫做**流**  \n\n流是一个抽象、动态的概念，是一连串连续动态的数据集合。  \n流给数据源和程序之间提供了数据信息传输的通道，编程语言提供了多种流用于数据传输  \n\n## Hallo World\n```java\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        System.out.println(\"Hello World!\");\n    }\n}\n```\n这个程序就用到了输出流，把Hallo World输出给用户看  \n**System**是一个类，**out**是这个类的一个静态成员，**println**是这个成员能做的事情  \n实际上，**out**这个成员就是用于做输出的流  \n\n## 流的基础\n在java的基础类库中，所有的输出都基于**OutputStream**类，所有的输入都基于**InputStream**类，这两个类构成了输入和输出的基础  \n\n但这两个类是抽象的，具体使用时应该用它们的子类  \n在这里可以看到java系统类库中所有的包[Java®平台、标准版和Java开发工具包第18版API规范](https://docs.oracle.com/en/java/javase/18/docs/api/index.html)  \n在其中的java.base中有[java.io](https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/io/package-summary.html)，这里面有java输入输出所有相关的东西  \n在里面可以找到**InputStream**和**OutputStream**类，当然这里面还有很多的类，以及其它的东西  \n\n点击InputStream，可以看到这个类的描述，以及它所有的方法  \n<div><img src=/images/7-19.webp width=\"100%\" height=\"100%\"></div>\n\n**InputStream**把外界的输入当做**字节**的流来看待，**OutputStream**也同理，当我们使用这两个类，只能做字节层面上的读和写  \n\n尝试一下：  \n```java\nimport java.io.IOException;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n        byte[] buffer = new byte[1024];//一个1k字节的butter\n        int len = 0;//让系统读取输入流，并将读取到的内容存储到buffer中，返回读取到的字节数\n        try {//所有io的操作都存在风险，所以要捕获异常\n            len = System.in.read(buffer);\n            String s = new String(buffer, 0, len);//将buffer中从0开始到len的这么多个字节构造一个字符串\n            System.out.println(\"读到了：\"+len+\"字节\");//输出读取到的字节数\n            System.out.println(s);//输出字符串\n            System.out.println(\"s的长度：\"+s.length());//输出字符串有多少个字符\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java 输出\nHello World!\n输入:123abc\n读到了：7字节\n123abc\n\ns的长度：7\n\n```\n123abc是6个字节，但后面还有个回车，所以读到7个字节，且输出s时，把回车也输出了  \n\n换个输入：\n```java 输出\nHello World!\n输入：123汉字abc\n读到了：13字节\n123汉字abc\n\ns的长度：9\n\n```\n在UTF-8编码中,一个中文字符等于三个字节，所以一共读到13个字节  \n\n## 文件流\n**System.in**和**System.in**是标准输入和标准输出的流  \n如果想要直接写文件，就需要使用到**文件流**：**FileInputStream**、**FileOutputStream**  \n\n实际工程中已经较少直接对文件进行读写（除了在造轮子）  \n更常用的是以在内存数据或通信数据上建立的流，如数据库的二进制数据读写或网络端口通信  \n具体的文件读写往往有更专业的类，比如配置文件和日志文件  \n\n尝试一下**FileOutputStream**：  \n```java\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            FileOutputStream out = new FileOutputStream(\"a.dat\");//如果文件不存在，则创建，存在则覆盖\n            out.write(buf);//将buf中的数据写入文件\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n用**Hexdump**打开这个16进制文件  \n```\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: 00 01 02 03 04 05 06 07 08 09                      ..........\n\n```\n1到9都已经被写入  \n\n## 流过滤器\n无论是System.in和out还是文件流，都只能处理单个字节，一个个字节地读，一个个字节地写  \n如果要把一个10进制地整数写入到一个文件中，就要同时读写4个字节，显然前面介绍的流无法做到  \n\n**流过滤器**可以在已存在的流的基础上，去增加一层层的过滤器，每一层的过滤器都可以做点事情，其中一些过滤器就可以做int、double这些基础类型数据的读和写  \n\n尝试一下：  \n```java\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            DataOutputStream out = new DataOutputStream(\n                    new BufferedOutputStream(//缓冲输出流\n                            new FileOutputStream(\"a.dat\")));\n            //打开这个文件之后，在上面接了一个缓冲流，缓冲流外面还有一个流，最终得到的是一个DataOutputStream的对象\n            //我们可以往DataOutputStream这个流里面写入数据，数据会被缓冲到缓冲流里面，缓冲流里面的数据会被写入到文件里面\n            int i = 0xcafebabe;\n            out.writeInt(i);//写入一个int类型的数据,DataOutputStream流的writeInt方法可以写入一个int类型的数据\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: CA FE BA BE                                        J~:>\n```\n0xcafebabe这个16进制数已经被写入  \n```java 输出\nHello World!\n-889275714\n```\n0xcafebabe这个16进制的数对应的10进制数是-889275714  \n\n每一层过滤器都可以起到一定的作用，在上面的程序中，BufferedOutputStream起到了缓冲垫作用，DataOutputStream起到了读写基本数据类型的作用  \n\n## 文本的输入和输出\n加上了DataOutputStream也只能以二进制处理基本数据类型，如何处理文本？  \n\n二进制数据采用InputStream/OutputStream  \n文本数据采用Reader/Writer  \n\n但Reader/Writer本身是处理Unicode编码的字符的，如果文件是Unicode编码，可以直接用Reader/Writer处理文件，但一般情况下，文件本身并不是Unicode编码，它可能是GBK，可能是UTF-8  \n在这种情况下，我们需要借助Stream，用字节形式打开文件，再在Stream流的基础上，用过滤器的方式去建立Reader/Writer ，来做文本的输入和输出，**StreamReader**可以将字节流转换为字符流，然后交给Reader/Writer，当然中间可以加上Buffered实现缓冲  \n\n尝试一下：  \n```java\nimport java.io.*;\n\npublic class test {\n    public static void main(String[] args)  {\n        System.out.println(\"Hello World!\");\n        byte[] buf = new byte[10];//10个字节的数组\n        for (int i=0; i<buf.length; i++){\n            buf[i] = (byte)i;//让buf中的每个元素都是i，而且是byte类型\n        }\n        try {\n            PrintWriter out = new PrintWriter(//创建一个输出流,PrintWriter可以通过连接BufferedWriter实现的缓冲功能\n                    new BufferedWriter(//创建一个缓冲流\n                            new OutputStreamWriter(//将字节流转换为字符流\n                                new FileOutputStream(\"a.txt\"))));//创建一个文件输出流\n            //我们做了一个文件流，但它只能处理字节\n            // 在此基础上再做一个桥梁：OutputStreamWriter\n            // 它构建起了Stream和Writer的桥梁，它的输入是OutputStream，输出是Writer\n            int i = 123456;\n            out.println(i);//在PrintWriter的基础上，我们可以用println方法来输出数据\n            out.close();\n            //和上面输出一样，如果要读取一个文件，我们需要做一个桥梁：InputStreamReader\n            //它构建起了Stream和Reader的桥梁，它的输入是InputStream，输出是Reader\n            BufferedReader in = new BufferedReader(// BufferedReader类从字符输入流中读取文本并缓冲字符\n                    new InputStreamReader(//将字节流转换为字符流\n                        new FileInputStream(\"src/test.java\")));//创建一个文件输入流，打开这个程序的源码文件\n            //readLine()方法从字符输入流中读取一行，并返回该行。\n            String line;\n            while ((line = in.readLine()) != null){//当读取到的行不为空时，执行循环，就可以读取整个文件\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n运行：在a.tet文件中有123456字符,控制台也将这整个源码输出了出来  \n\n除了BufferedReader，还有LineNumberReader，里面的getLineNumber()可以读取指定的行  \n\n**FileReader**是InputStreamReader类的子类，所有方法都从父类中继承而来，它可以直接读取一个二进制文件，建立起一个流，然后形成一个Reader    \nFileReader(File file)在给定从中读取数据的Fe的情况下创建一个新FileReader  \nFileReader(String fileName)在给定从中读取数据的文件名的情况下创建一个新FileReader  \nFileReader不能指定编码转换方式  \n\n## 汉字编码问题\nFileOutputStream(\"a.txt\")可以以二进制形式打开一个文件  \nOutputStreamWriter(FileOutputStream(\"a.txt\"))将字节流转换为字符流,如果不指定编码，那么它优先使用程序源码文件的编码去转换这个字节流为字符流，这就很容易导致汉字乱码  \n\n我们可以指定编码进行转换OutputStreamWriter(FileOutputStream(\"a.txt\"),\"utf8\")  \n用utf8去将这个字节流转换成字符流 \n\n当然还有其它方法，这里不展开讲\n\n## 格式化输入输出\n格式化输出：使用printf(\"格式\", );用法和C语言的基本一样，这里不展开讲，博主同样有篇C语言学习笔记  \n\n格式化输入：如果想从一个文本中读取出一些数字，可以在流上构建一个Scanner，然后用next系列的方法去读取数字、单词等等  \n\n## Stream/Reader/Scanner的选择\n<div><img src=/images/7-20.webp width=\"92%\" height=\"92%\"></div>\n\n## 流的应用\n现在已经很少有程序需要用流的方式去打开一个文件，裸地去进行文件读和写的操作，更多地是从某个地方得到了一个流  \n\n### 服务器通信\n下面这个程序将从本地服务器得到一个流，并向这个流写入东西  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n当然，直接运行这个程序一定报错，因为本地没有任何服务器程序在12345端口上听着，连接建立不起来  \n\n使用netcat可以实现监听  \n从[netcat](https://eternallybored.org/misc/netcat/)下载netcat1.12  \n解压后把nc.exe移动到C:\\Windows\\System32目录，压缩包内其它东西用不上  \n然后打开cmd，运行nc -l -p -12345\n\n现在再运行程序，cmd窗口就会输出Hello, world!  \n\n还可以接收服务端的数据  \n```java\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.Socket;\n\npublic class socket {\n    public static void main(String[] args) {\n        try {\n            Socket socket = new Socket(InetAddress.getByName(\"localhost\"), 12345);//创建一个Socket对象，指定服务器地址和端口号\n            PrintWriter out = new PrintWriter(\n                    new BufferedWriter(\n                            new OutputStreamWriter(\n                                    //getOutputStream()方法获取Socket对象的输出流，并构造一个BufferedWriter对象\n                                    socket.getOutputStream())));//创建一个PrintWriter对象，用于向服务器发送信息\n            out.println(\"Hello, world!\");//向服务器发送一行文本\n            out.flush();//刷新缓冲区，将缓冲区中的数据立即发送出去\n            BufferedReader in = new BufferedReader(\n                    new InputStreamReader(\n                            //getInputStream()方法获取Socket对象的输入流，并构造一个BufferedReader对象\n                            socket.getInputStream()));//创建一个BufferedReader对象，用于接收服务器端的信息\n            String line = in.readLine();//读取服务器端的一行文本\n            System.out.println(line);//输出读取的文本\n            out.close();//关闭PrintWriter对象\n            socket.close();//关闭Socket对象\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n在cmd窗口输入任意文本，idea的控制台也会输出这个文本  \n\n### 对象串行化\n写入和读取一个对象，使用ObjectOutputStream和ObjectInputStream，被读写的类要实现Serializable接口  \n```java\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.Serializable;\nimport java.io.*;\n\nclass Student implements Serializable {//可以串行化的类\n    private String name;\n    private int age;\n    private int grade;\n\n    public Student(String name, int age, int grade) {\n        this.name = name;\n        this.age = age;\n        this.grade = grade;\n    }\n\n    public String toString() {\n        return \"Student: \" + name + \" \" + age+ \" \" + grade;\n    }\n}\n\npublic class chh {\n    public static void main(String[] args) {\n        try {\n            Student s1 = new Student(\"zhangsan\", 20, 1);\n            ObjectOutputStream out = new ObjectOutputStream(\n                    new FileOutputStream(\"obj.dat\"));\n            out.writeObject(s1);\n            out.close();\n            ObjectInputStream in = new ObjectInputStream(\n                    new FileInputStream(\"obj.dat\"));\n            Student s2 = (Student) in.readObject();\n            System.out.println(s2);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n```java obj.bat\n  Offset: 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F \t\n00000000: AC ED 00 05 73 72 00 07 53 74 75 64 65 6E 74 98    ,m..sr..Student.\n00000010: 61 28 66 C5 BE 55 BC 02 00 03 49 00 03 61 67 65    a(fE>U<...I..age\n00000020: 49 00 05 67 72 61 64 65 4C 00 04 6E 61 6D 65 74    I..gradeL..namet\n00000030: 00 12 4C 6A 61 76 61 2F 6C 61 6E 67 2F 53 74 72    ..Ljava/lang/Str\n00000040: 69 6E 67 3B 78 70 00 00 00 14 00 00 00 01 74 00    ing;xp........t.\n00000050: 08 7A 68 61 6E 67 73 61 6E                         .zhangsan\n\n```\n```java 输出\nStudent: zhangsan 20 1\n```\n\n***\n\n>完结撒花！\n>javase的学习暂且告一段落，但学习的步伐永不停歇\n>翁恺老师讲的课循序渐进，简洁明了，好评，但课程上只学到流，刚步入javase的高级部分\n>后面还有一个重要部分：线程\n>过段时间实操一个java的管理系统（万物起源管理系统），暂且咕咕咕吧\n","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"给Butterfly加上顶部加载条","url":"/article/13d6481a.html","content":"\n>效果已在本站实装，切换页面顶部有加载进度条\n>参考文章[为Hexo博客添加顶部加载条](https://cloud.tencent.com/developer/article/1960734)\n\n# 旧版顶部长条\n\n## 引入css\n```css\n.pace {\n  -webkit-pointer-events: none;\n  pointer-events: none;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none;\n}\n\n.pace-inactive {\n  display: none;\n}\n\n.pace .pace-progress {\n  background: #e90f92;\n  position: fixed;\n  z-index: 2000;\n  top: 0;\n  right: 100%;\n  width: 100%;\n  height: 2px;\n}\n\n.pace .pace-progress-inner {\n  display: block;\n  position: absolute;\n  right: 0px;\n  width: 100px;\n  height: 100%;\n  box-shadow: 0 0 10px #e90f92, 0 0 5px #e90f92;\n  opacity: 1.0;\n  -webkit-transform: rotate(3deg) translate(0px, -4px);\n  -moz-transform: rotate(3deg) translate(0px, -4px);\n  -ms-transform: rotate(3deg) translate(0px, -4px);\n  -o-transform: rotate(3deg) translate(0px, -4px);\n  transform: rotate(3deg) translate(0px, -4px);\n}\n\n.pace .pace-activity {\n  display: block;\n  position: fixed;\n  z-index: 2000;\n  top: 15px;\n  right: 15px;\n  width: 14px;\n  height: 14px;\n  border: solid 2px transparent;\n  border-top-color: #e90f92;\n  border-left-color: #e90f92;\n  border-radius: 10px;\n  -webkit-animation: pace-spinner 400ms linear infinite;\n  -moz-animation: pace-spinner 400ms linear infinite;\n  -ms-animation: pace-spinner 400ms linear infinite;\n  -o-animation: pace-spinner 400ms linear infinite;\n  animation: pace-spinner 400ms linear infinite;\n}\n\n@-webkit-keyframes pace-spinner {\n  0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-moz-keyframes pace-spinner {\n  0% { -moz-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -moz-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-o-keyframes pace-spinner {\n  0% { -o-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -o-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@-ms-keyframes pace-spinner {\n  0% { -ms-transform: rotate(0deg); transform: rotate(0deg); }\n  100% { -ms-transform: rotate(360deg); transform: rotate(360deg); }\n}\n@keyframes pace-spinner {\n  0% { transform: rotate(0deg); transform: rotate(0deg); }\n  100% { transform: rotate(360deg); transform: rotate(360deg); }\n}\n/* 在下面修改进度条外观 */\n.pace .pace-progress {\n  background: #1ef4fbec; /*进度条颜色*/\n  height: 3px;/* 进度条厚度 */\n}\n.pace .pace-progress-inner {\n  box-shadow: 0 0 10px #1ef4fbce, 0 0 5px #1ecffbd0; /*阴影颜色*/\n}\n.pace .pace-activity {\n  border-top-color: #1edafbe5;\t/*上边框颜色*/\n  border-left-color: #1ef4fbec;\t/*左边框颜色*/\n}\n```\n\n## 引入js\n\n```js\n<script src=\"//cdn.bootcss.com/pace/1.0.2/pace.min.js\"></script>\n```\n\n**然后三连即可**\n\n# 新版胶囊\n<img src=/images/10-1.webp width=\"50%\" height=\"50%\">\n\n\n\n\n\n\n\n","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"基于UptimeRobot的监控面板","url":"/article/8f1fedc5.html","content":"\n>演示：[轻笑的网站监控面板](https://status.chuckle.top/)\n\n# 注册UptimeRobot\n\n填写邮箱以完成注册  \n>[跳转至注册](https://uptimerobot.com/signUp?ref=website-header)\n\n\n# 新建监视器\n点击左上角Add New Monitor  \n<div><img src=/images/9-1.webp width=\"70%\" height=\"70%\"></div>\n\n在弹出窗口填写需要需要监控的站点的相关信息  \n\n<div><img src=/images/9-2.webp width=\"70%\" height=\"70%\"></div>\n\n点击Create Monitor完成创建   \n\n\n# 创建API密钥\n\n点击My Settings\n<div><img src=/images/9-3.webp width=\"70%\" height=\"70%\"></div>\n为监视器创建一个api密钥（也可选择第三个，为所有监视器创建一个密钥）  \n<div><img src=/images/9-4.webp width=\"70%\" height=\"70%\"></div>\n\n# fork监控面板仓库\n选择其中一个fork  \n[yb/uptime-status](https://github.com/yb/uptime-status)  \n[Ice-Hazymoon/status](https://github.com/Ice-Hazymoon/status)  \n\n# 修改config.js\n\n进入刚fork的仓库，打开/public/config.js  \n添加监视器的api密钥  \n>需要监控的站点较多，也可为所有监控器创建一个api密钥填入\n\n```\n ApiKeys: [\n    '在这里粘贴api密钥',\n  ],\n```\n>还可以选择在ApiDomain修改自定义反代域名，详见https://github.com/yb/uptime-status/\n\n# vercel部署\n\n新建一个项目  \nimport监控面板仓库  \n等待几分钟创建完成，点击vist，一个监控面板就完成了  \n<div><img src=/images/9-5.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=/images/9-6.webp width=\"70%\" height=\"70%\"></div>\n\n","tags":["教程"],"categories":["教程"]},{"title":"JAVA/面向对象学习笔记(2)","url":"/article/9f2dc6c7.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n>上接[JAVA/面向对象学习笔记(1)](https://www.chuckle.top/article/bfb663c6.html)\n\n# 城堡游戏（可扩展性）\n整体思路：用Room先初始化5个房间，Room类中有房间名称、四个方向所连接的房间，currentRoom = outside;设置出生点  \n进入goRoom方法，匹配用户输入的方向，让nextroom指向下一个房间，然后让currentRoom = outside;并输出房间信息。  \n大致以此循环  \n \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    public String description;\n    //房间四个方向连接的房间\n    public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = null;//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n```java 输出\n欢迎来到城堡!\n这是一个超级无聊的游戏。\n如果需要帮助，请输入'help'\n\n你在城堡外\n出口有：\neast\nsouth\nwest\n\ngo south\n你在书房\n出口有：\nnorth\neast\n\ngo east\n你在卧室\n出口有：\nwest\n\nhelp\n迷路了吗？你可以做的命令有：go bye help\n如：\tgo east\nbye\n感谢您的光临。再见！\n```\n\n## 消除代码复制\n在printWelcome和goRoom方法中都有一段相同的输出出口方向的代码  \n将这段代码提取出来，做成一个方法，在需要输出房间信息的地方调用即可  \n```java\npublic void showPrompt()\n{\n    // 输出当前房间的描述\n    System.out.println(\"你在\"+ currentRoom);\n    System.out.println(\"出口有：\");\n    if(currentRoom.northExit != null)\n        System.out.println(\"north\");\n    if(currentRoom.eastExit != null)\n        System.out.println(\"east\");\n    if(currentRoom.southExit != null)\n        System.out.println(\"south\");\n    if(currentRoom.westExit != null)\n        System.out.println(\"west\");\n    System.out.println();\n}\n\n```\n\n## 封装\n这个程序没有bug，能正常运行，但不见得是一个好的代码  \n评价一个代码质量的好坏是多元的，尤其是这个代码是否能适应将来的需要  \n\n**可扩展性**：代码是否易于将来增加新的东西\n\n我们想在这个游戏里给每个房间增加两个方向down和up  \n我们需要改的地方很多  \nRoom.java里需要增加两个房间对象public Room downExit;和public Room upExit; setExits方法需要增加两个参数并进行判断  \nGame.java里很多方法也要增加if判断，还要改每个房间的初始化  \n\n总之，想增加一个方向，代码几乎每个地方都要改变  \n\n要想增加可扩展性，首先要降低类和类之间的耦合  \n\n### 用封装来降低耦合\nRoom类和Game类都有大量的代码和出口相关  \n尤其是Game类中大量使用了Room类的成员变量  \n类和类之间的关系称作**耦合**  \n耦合**越低越好**，保持距离是形成良好代码的关键  \n\n我们可以让Room自己告诉Game有哪些出口，出口连接的房间  \n```java Room.java\npackage castle;\n\npublic class Room {\n    //房间名称\n    private String description;\n    //public String description;\n    //房间四个方向连接的房间\n    private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;\n    /*public Room northExit;\n    public Room southExit;\n    public Room eastExit;\n    public Room westExit;*/\n\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        /*String returnString = \"Exits:\";\n        if (northExit != null)\n            returnString += \"north \";\n        if (eastExit != null)\n            returnString += \"east \";\n        if (southExit != null)\n            returnString += \"south \";\n        if (westExit != null)\n            returnString += \"west \";\n        return returnString;*/\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);\n\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n        /*System.out.println(\"现在你在:\" + currentRoom);\n        System.out.println(\"出口有：\");\n        //输出当前房间的出口\n        if(currentRoom.northExit !=null)\n            System.out.print(\"north \");\n        if(currentRoom.eastExit !=null)\n            System.out.print(\"east \");\n        if(currentRoom.southExit !=null)\n            System.out.print(\"south \");\n        if(currentRoom.westExit !=null)\n            System.out.print(\"west \");\n        System.out.println();*/\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 在当前房间的出口中查找与用户输入的方向相同的房间\n        /*if(direction.equals(\"north\")){\n            nextRoom = currentRoom.northExit;\n        }\n        if(direction.equals(\"east\")){\n            nextRoom = currentRoom.eastExit;\n        }\n        if(direction.equals(\"south\")){\n            nextRoom = currentRoom.southExit;\n        }\n        if(direction.equals(\"west\")){\n            nextRoom = currentRoom.westExit;\n        }*/\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n            /*System.out.println(\"你在\"+ currentRoom);\n            System.out.println(\"出口有：\");\n            if(currentRoom.northExit != null)\n                System.out.println(\"north\");\n            if(currentRoom.eastExit != null)\n                System.out.println(\"east\");\n            if(currentRoom.southExit != null)\n                System.out.println(\"south\");\n            if(currentRoom.westExit != null)\n                System.out.println(\"west\");\n            System.out.println();*/\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n        /*System.out.println(\"出口有：\");\n        if(currentRoom.northExit != null)\n            System.out.println(\"north\");\n        if(currentRoom.eastExit != null)\n            System.out.println(\"east\");\n        if(currentRoom.southExit != null)\n            System.out.println(\"south\");\n        if(currentRoom.westExit != null)\n            System.out.println(\"west\");\n        System.out.println();*/\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n\n### 用接口来实现聚合\n原本Room有什么出口，连接着什么房间，Game是能直接获取使用的  \n现在我们在Room中实现了两个接口getExitDesc和getExit,把方向的细节彻底隐藏在Room类内部  \n今后方向如何实现就和外部无关了  \n\n### 用容器来实现灵活性\n在Room当中，有四个Room对象，用于保存这个房间连接着的四个房间（null，或者房间名）  \n这种一一对应的关系，可以使用HashMap去实现  \n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n    /*private Room northExit;\n    private Room southExit;\n    private Room eastExit;\n    private Room westExit;*/\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    /*public void setExits(Room north, Room east, Room south, Room west)//设置房间的四个方向的连接\n    {\n        if (north != null)\n            northExit = north;\n        if (east != null)\n            eastExit = east;\n        if (south != null)\n            southExit = south;\n        if (west != null)\n            westExit = west;\n    }*/\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        /*if (northExit != null)\n            builder.append(\"north \");\n        if (eastExit != null)\n            builder.append(\"east \");\n        if (southExit != null)\n            builder.append(\"south \");\n        if (westExit != null)\n            builder.append(\"west \");*/\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n        /*if (direction.equals(\"north\"))\n            return northExit;\n        if (direction.equals(\"east\"))\n            return eastExit;\n        if (direction.equals(\"south\"))\n            return southExit;\n        if (direction.equals(\"west\"))\n            return westExit;\n        return null;*/\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n\n    public Game()//构造函数\n    {\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        /*outside.setExits(null,lobby,study,pub);\n        lobby.setExits(null,null,null,outside);\n        pub.setExits(null,outside,null,null);\n        study.setExits(outside,bedroom,null,null);\n        bedroom.setExits(null,null,null,study);*/\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n\n    private void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }\n        System.out.println(\"感谢您的光临。再见！\");\n        in.close();//关闭Scanner\n    }\n}\n```\n//现在当我们想增加出口方向，很简单  \nlobby.setExits(\"up\", pub);  \npub.setExits(\"down\", lobby);  \n\n这里发生了什么？  \n将lobby的出口方向和对应房间传给它的setExits的方法后  \nlobby里面的容器就会多一对出口和房间的对应关系  \nlobby里面的getExitDesc、getExit方法以及未来可能加入的新方法，都遍历这个容器  \n所以，增加出口和连接的房间，只需要调用setExits方法，去往lobby里的容器写入东西即可  \n\n现在，对于增加出口来说，已经具有了可扩展性\n\n### 以框架+数据来提高可扩展性\n我们原来用硬编码去保存room的出口  \n现在我们用容器，HashMap和对应的方法（接口方法）组成了一个框架，数据就是放在HashMap里的东西  \n在这个框架中要增加出口很容易  \n\n启发：  \n命令的解析是否可以脱离if-else  \n定义一个Handler来处理命令  \n用Hash表来保存命令和Handler之间的关系  \n\n现在我们可以用相同的思路去解决用户命令（help，go，bye）的硬编码问题  \n一个字符串对应调用一个方法，这显然也是一一对应的关系  \n但容器**只能放对象**，一个方法不能放进容器中  \n\n### 如何把方法放进容器中\n创建一个Handler类，然后把每个命令创建为Handler的子类  \n将命令字符串和Handler子类的对象一一对应放入HashMap中  \n将功能在Handler的子类的doCmd方法中实现  \n在game中通过父类对象管理者去管理子类对象（从HashMap中获取子类对象），管理者调用doCmd方法即可  \n\n```java Room.java\npackage castle;\n\nimport java.util.HashMap;\n\npublic class Room {\n    //描述\n    private String description;\n    //用HashMap来保存这个房间连接着的四个房间\n    private HashMap<String, Room> exits = new HashMap<String, Room>();\n\n    public Room(String description)//初始化房间名\n    {\n        this.description = description;\n    }\n\n    public void setExits(String direction, Room room) {\n        exits.put(direction, room);//将出口方向和连接的房间放进容器中\n    }\n\n    @Override\n    public String toString() {\n        return description;//输出房间名\n    }\n\n    public String getExitDesc() {\n        //返回一个字符串，来表达房间的出口\n        //一般我们不使用String去做拼接，因为每次加都会产生一个新的String类型的对象，系统开销会很大，而是使用StringBuilder\n        StringBuilder builder = new StringBuilder(\"出口有：\");\n        for (String direction : exits.keySet()) {\n            builder.append(direction);\n            builder.append(\" \");\n        }\n        return builder.toString();\n    }\n\n    public Room getExit(String direction) {\n        //返回指定方向的连接房间\n        return exits.get(direction);//直接从HashMap中获取房间，如果没有容器会自动返回null\n    }\n}\n```\n```java Game.java\npackage castle;\n\nimport java.util.*;\n\npublic class Game {\n    private Room currentRoom;//创建一个Room对象，用于保存当前房间\n    //创建一个HashMap对象，用于保存所有的命令处理器\n    private HashMap<String, Handler> handlers = new HashMap<String, Handler>();\n\n    public Game()//构造函数\n    {\n        //将字符串和命令处理器对应\n        handlers.put(\"go\",new HandlerGo(this));//把game对象作为参数传入HandlerGo类，让HandlerGo能管理game\n        handlers.put(\"help\",new HandlerHelp(this));\n        handlers.put(\"bye\",new HandlerBye(this));\n        creatRooms();//创建房间\n    }\n\n    private void creatRooms()//创建一个房间\n    {\n        Room outside, lobby,pub,study,bedroom;//创建5种房间\n\n        // 制造5种房间\n        outside = new Room(\"城堡外\");\n        lobby = new Room(\"大堂\");\n        pub = new Room(\"小酒吧\");\n        study = new Room(\"书房\");\n        bedroom = new Room(\"卧室\");\n\n        // 初始化房间的出口\n        outside.setExits(\"east\", lobby);\n        outside.setExits(\"south\", study);\n        outside.setExits(\"west\", pub);\n        lobby.setExits(\"west\", outside);\n        pub.setExits(\"east\", outside);\n        study.setExits(\"north\", outside);\n        study.setExits(\"east\", bedroom);\n        bedroom.setExits(\"west\", study);\n        //现在当我们想增加出口方向，很简单\n        lobby.setExits(\"up\", pub);\n        pub.setExits(\"down\", lobby);\n\n        currentRoom = outside; //从城堡门外开始\n    }\n\n\n    private void printWelcome()//输出欢迎信息\n    {\n        System.out.println();\n        System.out.println(\"欢迎来到城堡!\");\n        System.out.println(\"这是一个超级无聊的游戏。\");\n        System.out.println(\"如果需要帮助，请输入'help'\");\n        System.out.println();\n        showPrompt();\n    }\n\n    //  以下为用户命令\n\n    /*private void printHelp()//帮助菜单\n    {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }*/\n\n    public void goRoom(String direction)\n    {\n        Room nextRoom = currentRoom.getExit(direction);//创建一个Room对象，用于保存下一个房间\n        // 如果找到了下一个房间，则进入下一个房间\n        if(nextRoom == null){\n            System.out.println(\"那里没有门！\");\n        }\n        else{\n            currentRoom = nextRoom;//让当前房间等于下一个房间\n            // 输出当前房间的描述\n            showPrompt();\n        }\n    }\n\n    public void showPrompt()\n    {\n        // 输出当前房间的描述\n        System.out.println(\"你在\"+ currentRoom);\n        //调用房间的getExitString()方法，输出当前房间的出口\n        System.out.println(currentRoom.getExitDesc());\n    }\n\n    public void play(){//游戏开始\n        Scanner in = new Scanner(System.in);\n        while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            Handler handler = handlers.get(words[0]);//获取用户输入的命令,从HashMap中获取对应的子类对象,让handler管理这个对象\n            String value = \"\";//保存命令的字符串\n            if(words.length > 1)//判断是不是bye命令\n            {\n                value = words[1];//获取参数\n            }\n            if(handler != null){//如果命令存在\n                handler.doCmd(value);//调用命令处理器\n                if ( handler.isBye() ) {//如果命令处理器返回true，则退出游戏\n                    System.out.println(\"感谢您的光临。再见！\");\n                    break;\n                }\n            }\n        }\n        in.close();//关闭Scanner\n    }\n\n    public static void main(String[] args) {\n        /*Scanner in = new Scanner(System.in);*/\n        //通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。\n        Game game = new Game();\n        game.printWelcome();//输出欢迎信息\n        game.play();\n        /*while (true)//进入游戏主体，游戏结束时退出循环\n        {\n            String line = in.nextLine();//控制台输入一行\n            String[] words = line.split(\" \");//以空格为分隔符，把用户输入的字符串分割成字符串数组\n            //判断是go还是help\n            if ( words[0].equals(\"help\")){\n                game.printHelp();//输出帮助信息\n            }else if ( words[0].equals(\"go\")){\n                game.goRoom(words[1]);//将用户输入的方向传给goRoom方法\n            }else if ( words[0].equals(\"bye\")){\n                break;//如果用户数据为bye，则退出游戏\n            }\n        }*/\n        //System.out.println(\"感谢您的光临。再见！\");\n        //in.close();//关闭Scanner\n    }\n}\n```\n```java Handler.java\npackage castle;\n\npublic class Handler {\n    protected Game game;//创建一个Game对象的管理者，为了方便设为protected\n    public Handler(Game game) {\n        this.game = game;//两个game管理者管理同一个Game对象\n    }\n\n    public void doCmd(String word) {}//一个接口，用于运行命令\n    public boolean isBye() { return false; }\n}\n```\n```java HandlerBye.java\npackage castle;\n\npublic class HandlerBye  extends Handler {\n    //必要的构造器\n    public HandlerBye(Game game) {\n        super(game);\n    }\n    @Override\n    public boolean isBye() {\n        return true;\n    }\n}\n```\n```java HandlerHelp.java\npackage castle;\n\npublic class HandlerHelp extends Handler {\n    //必要的构造器\n    public HandlerHelp(Game game) {\n        super(game);\n    }\n    @Override\n    public void doCmd(String word) {\n        System.out.println(\"迷路了吗？你可以做的命令有：go bye help\");\n        System.out.println(\"如：\\tgo east\");\n    }\n}\n```\n```java HandlerGo.java\npackage castle;\n\npublic class HandlerGo extends Handler {\n    public HandlerGo(Game game) {\n        super(game);//现在HandlerGo能管理game对象了\n    }\n    //help和bye都与game无关，但go需要调用goRoom方法，所以需要拿到game对象的管理者\n    public void doCmd(String word) {\n        game.goRoom(word);//调用game的goRoom方法\n    }\n\n}\n```\n>HandlerGo在未来有更好的方法去实现，现在还是用管理者吧\n\n如果要加入新的命令，也非常简单  \n创建一个新的Handler子类，在里面实现命令的功能  \n在Game的构造器中将命令字符串和Handler的子类对象放进去  \n\n现在这个城堡游戏已经有极高的可扩展性了  \n>这个城堡游戏例子非常全面，偶尔回来看看这个例子，是个不错的选择\n\n***\n\n# 抽象abstract\n关键字：**abstract**\n```java\npublic abstract class Shape {//抽象类\n    public abstract void draw(Graphics g);//抽象方法不带{}，即不带方法体\n}\n```\n抽象方法：表达概念，但无法实现具体功能（代码）的方法  \n抽象类：表达概念而无法构造出实体（对象）的类  \n\n有抽象方法的类**一定**是抽象类  \n抽象类不能**制造**对象，但是可以**定义**类变量（任何继承了抽象类的非抽象类的对象可以使用赋给这个类变量，即任何抽象类的子类的对象都可以由这个类变量来管理）  \n抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。  \n\n继承自抽象类的子类必须覆盖父类中的抽象方法，否则自己成为抽象类（即子类必须实现抽象父类的抽象方法）\n\n## 两种抽象\n与具体相对  \n·表示一种概念而非实体  \n与细节相对  \n·表示在一定程度上忽略细节而着眼大局  \n\n*** \n\n# 细胞自动机\n\n死亡：如果活着的邻居的数量小于2或大于3，则死亡  \n新生：如果正好有3个邻居活着，则新生其他情况则保持原状  \n\n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n \npublic class Cell {\n\tprivate boolean alive = false;//默认为死亡状态\n\t\n\tpublic void die() { alive = false; }//让细胞死亡\n\tpublic void reborn() { alive = true; }//让细胞重生\n\tpublic boolean isAlive() { return alive; }//返回细胞状态,判断细胞是否存活\n\t//绘制细胞\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tg.drawRect(x, y, size, size);//画个空心矩形\n\t\tif ( alive ) {//如果细胞存活\n\t\t\tg.fillRect(x, y, size, size);//画个实心矩形\n\t\t}\n\t}\n}\n\n```\n\n```java CellMachine.java\npackage cellmachine;\n\nimport javax.swing.JFrame;\n\nimport cell.Cell;\nimport field.Field;\nimport field.View;\n\npublic class CellMachine {\n\n\tpublic static void main(String[] args) {\n\t\t//数据准备阶段,画出一个细胞网格\n\t\tField field = new Field(30,30);//一个30*30的网格\n\t\t//遍历网格，每个网格都有一个细胞\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tfield.place(row, col, new Cell());//每个细胞都有一个状态，初始状态为死亡\n\t\t\t}\n\t\t}\n\n\t\t//遍历每个细胞，设置初始细胞的生存状态\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t//利用随机数让整个网格的五分之一的细胞生存\n\t\t\t\tif ( Math.random() < 0.2 ) { //Math.random()返回0~1之间的随机数\n\t\t\t\t\tcell.reborn();//reborn()方法设置细胞的生存状态为true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        //在窗口中显示细胞网格\n\t\tView view = new View(field);//将网格传入View类中\n\t\tJFrame frame = new JFrame();//创建一个JFrame对象,是java当中的窗口,用来显示细胞网格\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);//设置窗口关闭时的操作\n\t\tframe.setResizable(false);//设置窗口不可改变大小\n\t\tframe.setTitle(\"Cells\");//设置窗口的标题\n\t\tframe.add(view);//将网格添加到窗口中\n\t\tframe.pack();//设置窗口的大小\n\t\tframe.setVisible(true);//设置窗口可见,即显示出来\n\n\t\t//模拟细胞网格的运行\n\t\t//遍历整个网格,取出每个细胞\n\t\tfor ( int i=0; i<1000; i++ ) {//进行1000次模拟\n\t\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {//遍历每一行\n\t\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {//遍历每一列\n\t\t\t\t\tCell cell = field.get(row, col);//获取(row,col)位置上的细胞\n\t\t\t\t\tCell[] neighbour = field.getNeighbour(row, col);//获取(row,col)位置上的细胞的邻居\n\t\t\t\t\tint numOfLive = 0;//计数器，记录邻居中活细胞的个数\n\t\t\t\t\t//遍历邻居，计算邻居中有多少个细胞是活的\n\t\t\t\t\tfor ( Cell c : neighbour ) {\n\t\t\t\t\t\tif ( c.isAlive() ) {//如果邻居中有一个细胞是活的\n\t\t\t\t\t\t\tnumOfLive++;//让计数器加一\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//控制台输出当前细胞的状态\n\t\t\t\t\tSystem.out.print(\"[\"+row+\"][\"+col+\"]:\");//打印细胞的位置\n\t\t\t\t\tSystem.out.print(cell.isAlive()?\"live\":\"dead\");//打印细胞的状态\n\t\t\t\t\tSystem.out.print(\":\"+numOfLive+\"-->\");//打印细胞的邻居中有多少个细胞是活的\n\t\t\t\t\t//写入下一次的细胞状态\n\t\t\t\t\tif ( cell.isAlive() ) {//如果当前细胞是活的\n\t\t\t\t\t\tif ( numOfLive <2 || numOfLive >3 ) {//判断是否满足让细胞死的条件条件\n\t\t\t\t\t\t\tcell.die();//让细胞死\n\t\t\t\t\t\t\tSystem.out.print(\"die\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ( numOfLive == 3 ) {//如果当前细胞是死的，判断是否满足让细胞活的条件条件\n\t\t\t\t\t\tcell.reborn();//让细胞活\n\t\t\t\t\t\tSystem.out.print(\"reborn\");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"UPDATE\");\n\t\t\tframe.repaint();//整个Field都更新好后，画出棋盘\n\t\t\t//延时\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Field {\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;//一个二维数组field，存放每个格子（细胞）\n\t//构造器，初始化棋盘\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\tpublic int getWidth() { return width; }\n\tpublic int getHeight() { return height; }\n\t//添加细胞\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\t//获取某个格子\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\t//获取周围细胞\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor ( int i=-1; i<2; i++ ) {\n\t\t\tfor ( int j=-1; j<2; j++ ) {\n\t\t\t\tint r = row+i;\n\t\t\t\tint c = col+j;\n\t\t\t\tif ( r >-1 && r<height && c>-1 && c<width && !(r== row && c == col) ) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        //toArray会自动把一个Cell[]数组装好，让返回这个数组\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\t//清空所有格子\n\tpublic void clear() {\n\t\tfor ( int i=0; i<height; i++ ) {\n\t\t\tfor ( int j=0; j<width; j++ ) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -5258995676212660595L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\n\t//构造器\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t//每次当窗口被重绘时调用，被调用时会得到一个Graphics对象，即当前要画的对象\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);//调用父类的paint方法\n\t\t//绘制网格\n\t\tfor ( int row = 0; row<theField.getHeight(); row++ ) {//行\n\t\t\tfor ( int col = 0; col<theField.getWidth(); col++ ) {//列\n\t\t\t\tCell cell = theField.get(row, col);//得到每个格子的对象\n\t\t\t\tif ( cell != null ) {//如果该格子有对象\n\t\t\t\t\tcell.draw(g, col*GRID_SIZE, row*GRID_SIZE, GRID_SIZE);//绘制该格子\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth()*GRID_SIZE+1, theField.getHeight()*GRID_SIZE+1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tField field = new Field(10,10);\n\t\tfor ( int row = 0; row<field.getHeight(); row++ ) {\n\t\t\tfor ( int col = 0; col<field.getWidth(); col++ ) {\n\t\t\t\tfield.place(row, col, new Cell());\n\t\t\t}\n\t\t}\n\t\tView view = new View(field);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(view);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n}\n\n```\n\n## Cell、Field、View的关系\nField只需要管好数据以及提供数据  \nView只管拿到数据之后按数据把整个网格都重新画一遍  \n而Cell只管自己应该画空心还是实心，Field要就提供给它  \n\n不去精心设计哪个局部需要更新，需要更新就整个重画   \n这样简化了程序逻辑，是在计算机运算速度提高的基础上实现的  \n<div><img src=/images/7-8.webp width=\"80%\" height=\"80%\"></div>\n\n## 数据与表现分离\n程序的业务逻辑与表现无关  \n-表现可以是图形的也可以是文本的  \n-表现可以是当地的也可以是远程的  \n\n需要不同表现，那就用不同表现的代码去取数据，然后表现出来  \n\n## 责任驱动的设计\n将程序要实现的功能分配到合适的类/对象中去是设计中非常重要的一环  \n\n将功能拆分成很多个部分，每个部分只做自己擅长做的、简单的事  \n\n## 网格化\n图形界面本身有更高的解析度，但是将画面网格化以后，数据就更容易处理了  \n\n无需关心x、y轴坐标，只需知道要操作的对象在第几行第几列\n\n***\n\n# 狐狸和兔子\n细胞自动机是细胞在一个网格上，每个细胞都有两种状态  \n\n现在要模拟一个有狐狸和兔子的农场：   \n·狐狸和兔子都有年龄，且有规律增加  \n·当年龄到了一定的上限就会自然死亡  \n·狐狸可以随机决定在周围的兔子中吃一个，吃了后年龄上限会提高  \n·狐狸和兔子可以随机决定生一个小的，放在旁边的空的格子里  \n·如果不吃也不生，狐狸和兔子可以随机决定向旁边空的格子移一步  \n\n这比只有细胞，细胞只有两种状态要复杂得多  \n\n## 源码\n这个没注释，原理和细胞自动机差不多  \n```java Cell.java\npackage cell;\n\nimport java.awt.Graphics;\n\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\n\n```java Animal.java\npackage animal;\n\nimport java.util.ArrayList;\nimport field.Location;\n\npublic abstract class Animal {\n\n\tprivate int ageLimit;\n\tprivate int breedableAge;\n\tprivate int age;\n\tprivate boolean isAlive = true;\n\n\tpublic Animal(int ageLimit, int breedableAge) {\n\t\tthis.ageLimit = ageLimit;\n\t\tthis.breedableAge = breedableAge;\n\t}\n\n\tprotected int getAge() {\n\t\treturn age;\n\t}\n\n\tprotected double getAgePercent() {\n\t\treturn (double) age / ageLimit;\n\t}\n\n\tpublic abstract Animal breed();\n\n\tpublic void grow() {\n\t\tage++;\n\t\tif (age >= ageLimit) {\n\t\t\tdie();\n\t\t}\n\t}\n\n\tpublic void die() {\n\t\tisAlive = false;\n\t}\n\n\tpublic boolean isAlive() {\n\t\treturn isAlive;\n\t}\n\n\tpublic boolean isBreedable() {\n\t\treturn age >= breedableAge;\n\t}\n\n\tpublic Location move(Location[] freeAdj) {\n\t\tLocation ret = null;\n\t\tif (freeAdj.length > 0 && Math.random() < 0.02) {\n\t\t\tret = freeAdj[(int) (Math.random() * freeAdj.length)];\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"\" + age + \":\" + (isAlive ? \"live\" : \"dead\");\n\t}\n\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\treturn null;\n\t}\n\n\tprotected void longerLife(int inc) {\n\t\tageLimit += inc;\n\t}\n}\n\n```\n\n```java Fox.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.ArrayList;\n\nimport cell.Cell;\n\npublic class Fox extends Animal implements Cell {\n\n\tpublic Fox() {\n\t\tsuper(20, 4);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));// (int)((20-getAge())/20.0*255)));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.05) {\n\t\t\tret = new Fox();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Fox:\" + super.toString();\n\t}\n\n\t@Override\n\tpublic Animal feed(ArrayList<Animal> neighbour) {\n\t\tAnimal ret = null;\n\t\tif (Math.random() < 0.2) {\n\t\t\tret = neighbour.get((int) (Math.random() * neighbour.size()));\n\t\t\tlongerLife(2);\n\t\t}\n\t\treturn ret;\n\t}\n}\n\n```\n\n```java Rabbit.java\npackage animal;\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport cell.Cell;\n\npublic class Rabbit extends Animal implements Cell {\n\n\tpublic Rabbit() {\n\t\tsuper(10, 2);\n\t}\n\n\t@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(255, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n\n\t@Override\n\tpublic Animal breed() {\n\t\tAnimal ret = null;\n\t\tif (isBreedable() && Math.random() < 0.12) {\n\t\t\tret = new Rabbit();\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Rabbit:\" + super.toString();\n\t}\n}\n```\n\n```java Field.java\npackage field;\n\nimport java.util.ArrayList;\nimport cell.Cell;\n\npublic class Field {\n\n\tprivate static final Location[] adjacent = {\n\t\t\tnew Location(-1, -1), new Location(-1, 0), new Location(-1, 1),\n\t\t\tnew Location(0, -1), new Location(0, 0), new Location(0, 1),\n\t\t\tnew Location(1, -1), new Location(1, 0), new Location(1, 1)\n\t};\n\n\tprivate int width;\n\tprivate int height;\n\tprivate Cell[][] field;\n\n\tpublic Field(int width, int height) {\n\t\tthis.width = width;\n\t\tthis.height = height;\n\t\tfield = new Cell[height][width];\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\tpublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n\n\tpublic Cell get(int row, int col) {\n\t\treturn field[row][col];\n\t}\n\n\tpublic Cell[] getNeighbour(int row, int col) {\n\t\tArrayList<Cell> list = new ArrayList<Cell>();\n\t\tfor (int i = -1; i < 2; i++) {\n\t\t\tfor (int j = -1; j < 2; j++) {\n\t\t\t\tint r = row + i;\n\t\t\t\tint c = col + j;\n\t\t\t\tif (r > -1 && r < height && c > -1 && c < width && !(r == row && c == col)) {\n\t\t\t\t\tlist.add(field[r][c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Cell[list.size()]);\n\t}\n\n\tpublic Location[] getFreeNeighbour(int row, int col) {\n\t\tArrayList<Location> list = new ArrayList<Location>();\n\t\tfor (Location loc : adjacent) {\n\t\t\tint r = row + loc.getRow();\n\t\t\tint c = col + loc.getCol();\n\t\t\tif (r > -1 && r < height && c > -1 && c < width && field[r][c] == null) {\n\t\t\t\tlist.add(new Location(r, c));\n\t\t\t}\n\t\t}\n\t\treturn list.toArray(new Location[list.size()]);\n\t}\n\n\tpublic boolean placeRandomAdj(int row, int col, Cell cell) {\n\t\tboolean ret = false;\n\t\tLocation[] freeAdj = getFreeNeighbour(row, col);\n\t\tif (freeAdj.length > 0) {\n\t\t\tint idx = (int) (Math.random() * freeAdj.length);\n\t\t\tfield[freeAdj[idx].getRow()][freeAdj[idx].getCol()] = cell;\n\t\t\tret = true;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic Cell remove(int row, int col) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = null;\n\t\treturn ret;\n\t}\n\n\tpublic void remove(Cell cell) {\n\t\tfor (int row = 0; row < height; row++) {\n\t\t\tfor (int col = 0; col < width; col++) {\n\t\t\t\tif (field[row][col] == cell) {\n\t\t\t\t\tfield[row][col] = null;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void clear() {\n\t\tfor (int i = 0; i < height; i++) {\n\t\t\tfor (int j = 0; j < width; j++) {\n\t\t\t\tfield[i][j] = null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void move(int row, int col, Location loc) {\n\t\tfield[loc.getRow()][loc.getCol()] = field[row][col];\n\t\tremove(row, col);\n\t}\n}\n```\n\n```java Location.java\npackage field;\n\npublic class Location {\n\n\tprivate int row;\n\tprivate int col;\n\n\tpublic Location(int row, int col) {\n\t\tthis.row = row;\n\t\tthis.col = col;\n\t}\n\n\tpublic int getRow() {\n\t\treturn row;\n\t}\n\n\tpublic int getCol() {\n\t\treturn col;\n\t}\n}\n```\n\n```java View.java\npackage field;\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport javax.swing.JPanel;\nimport cell.Cell;\n\npublic class View extends JPanel {\n\tprivate static final long serialVersionUID = -2417015700213488315L;\n\tprivate static final int GRID_SIZE = 16;\n\tprivate Field theField;\n\tpublic View(Field field) {\n\t\ttheField = field;\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tsuper.paint(g);\n\t\tg.setColor(Color.GRAY);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tg.drawLine(0, row * GRID_SIZE, theField.getWidth() * GRID_SIZE, row * GRID_SIZE);\n\t\t}\n\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\tg.drawLine(col * GRID_SIZE, 0, col * GRID_SIZE, theField.getHeight() * GRID_SIZE);\n\t\t}\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tcell.draw(g, col * GRID_SIZE, row * GRID_SIZE, GRID_SIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic Dimension getPreferredSize() {\n\t\treturn new Dimension(theField.getWidth() * GRID_SIZE + 1, theField.getHeight() * GRID_SIZE + 1);\n\t}\n}\n```\n\n```java FoxAndRabbit.java\npackage foxnrabbit;\n\nimport java.util.ArrayList;\nimport javax.swing.JFrame;\nimport animal.Animal;\nimport animal.Fox;\nimport animal.Rabbit;\nimport cell.Cell;\nimport field.Field;\nimport field.Location;\nimport field.View;\n\npublic class FoxAndRabbit {\n\n\tprivate Field theField;\n\tprivate View theView;\n\n\tpublic FoxAndRabbit(int size) {\n\t\ttheField = new Field(size, size);\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tdouble probability = Math.random();\n\t\t\t\tif (probability < 0.05) {\n\t\t\t\t\ttheField.place(row, col, new Fox());\n\t\t\t\t} else if (probability < 0.15) {\n\t\t\t\t\ttheField.place(row, col, new Rabbit());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttheView = new View(theField);\n\t\tJFrame frame = new JFrame();\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tframe.setResizable(false);\n\t\tframe.setTitle(\"Cells\");\n\t\tframe.add(theView);\n\t\tframe.pack();\n\t\tframe.setVisible(true);\n\t}\n\n\tpublic void start(int steps) {\n\t\tfor (int i = 0; i < steps; i++) {\n\t\t\tstep();\n\t\t\ttheView.repaint();\n\t\t\ttry {\n\t\t\t\tThread.sleep(200);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void step() {\n\t\tfor (int row = 0; row < theField.getHeight(); row++) {\n\t\t\tfor (int col = 0; col < theField.getWidth(); col++) {\n\t\t\t\tCell cell = theField.get(row, col);\n\t\t\t\tif (cell != null) {\n\t\t\t\t\tAnimal animal = (Animal) cell;\n\t\t\t\t\tanimal.grow();\n\t\t\t\t\tif (animal.isAlive()) {\n\t\t\t\t\t\tLocation loc = animal.move(theField.getFreeNeighbour(row, col));\n\t\t\t\t\t\tif (loc != null) {\n\t\t\t\t\t\t\ttheField.move(row, col, loc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// eat\n\t\t\t\t\t\t// animal.eat(theField);\n\t\t\t\t\t\tCell[] neighbour = theField.getNeighbour(row, col);\n\t\t\t\t\t\tArrayList<Animal> listRabbit = new ArrayList<Animal>();\n\t\t\t\t\t\tfor (Cell an : neighbour) {\n\t\t\t\t\t\t\tif (an instanceof Rabbit) {\n\t\t\t\t\t\t\t\tlistRabbit.add((Rabbit) an);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!listRabbit.isEmpty()) {\n\t\t\t\t\t\t\tAnimal fed = animal.feed(listRabbit);\n\t\t\t\t\t\t\tif (fed != null) {\n\t\t\t\t\t\t\t\ttheField.remove((Cell) fed);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// breed\n\t\t\t\t\t\tAnimal baby = animal.breed();\n\t\t\t\t\t\tif (baby != null) {\n\t\t\t\t\t\t\ttheField.placeRandomAdj(row, col, (Cell) baby);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttheField.remove(row, col);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFoxAndRabbit fab = new FoxAndRabbit(50);\n\t\tfab.start(500);\n\t}\n}\n\n```\n\n## 项目结构及分析\n<div><img src=/images/7-9.webp width=\"40%\" height=\"40%\"></div>\n\n在英文中Cell有两种意思，格子、细胞  \n在刚刚到细胞自动机中，Cell类表达细胞，或者没有细胞的空格子，这很合理  \n\n狐狸和兔子类有很多相似的属性和动作，所以它们应该有一个父类  \n但这个父类不应该是Cell，Cell在这个程序中应该表达有东西或没东西的格子才合理  \n所以这个父类应该是Animal  \n\n现在类之间关系是这样的：  \n<div><img src=/images/7-10.webp width=\"100%\" height=\"100%\"></div>\n\n在细胞自动机中我们通过place(r,c,cell)将Cell放进网格中  \n但现在Fox、Rabbit和Cell没有联系，无法将它们放进网格中  \n如果按照之前的思路，Fox、Rabbit应该也是Cell的子类，但多继承是不被允许的（除了C++）  \n\n如果让Animal从Cell继承，这在语意上是模糊的，动物不应该是一种格子（虽然这样做能实现）  \n\n## 接口\n接口是纯抽象类  \n·所有的成员函数都是抽象函数  \n·所有的成员变量都是public static final  \n\n类表达一个具体的东西，而接口表达一种概念、一种规范  \n接口规定了长什么样，但是不管里面有什么  \n\n我们可以将Cell类改造成接口： \n```java Cell\nimport java.awt.Graphics;\npublic interface Cell {\n\tvoid draw(Graphics g, int x, int y, int size);\n}\n```\nCell现在的作用：所有实现了Cell这个接口的类，都应该有draw这个方法  \n在这个程序中，只要实现了这个方法的类的对象，都可以直接放到Field中  \n\n为什么Cell接口只要求实现draw方法？  \n因为将来View只需要拿Cell去draw，所以只需要要求放到Field里的类的对象实现draw方法  \n\n现在类之间关系是这样的：  \n<div><img src=/images/7-11.webp width=\"100%\" height=\"100%\"></div>\n\n现在Fox、Rabbit的对象都可以放进Field里（Field需要一个Cell，而Fox、Rabbit都实现了Cell）  \n\n### implements\n用关键字implements让类实现接口  \n```java\npublic class Fox extends Animal implements Cell{\n    //Fox是一种Animal，它实现了Cell\n}\n```\n在Field的place方法中,place需要一个Cell类的对象  \nCell本身是一个接口，它本身是抽象的，不可能有对象  \n但**所有实现了Cell接口**的对象都可以交给Cell对象的管理者  \n```java\npublic Cell place(int row, int col, Cell o) {\n\t\tCell ret = field[row][col];\n\t\tfield[row][col] = o;\n\t\treturn ret;\n\t}\n```\n当Fox实现Cell后，就必须重写Cell中的方法  \n把draw方法实际地做出来  \n```java\n@Override\n\tpublic void draw(Graphics g, int x, int y, int size) {\n\t\tint alpha = (int) ((1 - getAgePercent()) * 255);\n\t\tg.setColor(new Color(0, 0, 0, alpha));\n\t\tg.fillRect(x, y, size, size);\n\t}\n```\n类用extends,接口用implements  \n类可以实现很多接口  \n接口可以继承接口，但不能继承类  \n接口不能实现接口  \n\n### interface\n声明一个接口  \n```java\npublic interface Cell{//接口\n}\npublic class Cell{//类\n}\n```\ninterface是一种特殊的class，它替代掉了class  \n\n### 面向接口的编程方式\n在上面的程序中，Field需要一个能draw的类的对象，然后Field提供了一个Cell接口，所有实现了这个接口的东西都可以交给Field，而它不关心这个东西是什么，只需要符合接口即可  \n\n设计程序时先定义接口，再实现类  \n任何需要在函数间传入传出的一定是接口而不是具体的类  \n是Java成功的关键之一，因为极适合多人同时写一个大程序：每个人只需要用接口去提出要求，其他人根据借口实现具体的类   \n也是Java被批评的要点之一，因为代码量膨胀起来很快，显得程序十分臃肿  \n\n## 增加一个按钮\n\n在狐狸与兔子程序的图形界面中增加一个按钮，按一下执行一步   \n\n在FoxAndRabbit.java中，这么一段代码生成了一个窗口  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\nframe.pack();\nframe.setVisible(true);\n```\n首先要在窗口中增加一个按钮  \n```java\ntheView = new View(theField);\nJFrame frame = new JFrame();\nframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\nframe.setResizable(false);\nframe.setTitle(\"Cells\");\nframe.add(theView);\n//有一个类叫JButton，做一个叫btnstep的对象\nJButton btnstep =new JButton(\"单步\");\n//把这个按钮加到窗口中\nframe.add(btnstep);\nframe.pack();\nframe.setVisible(true);\n```\n运行一下\n<div><img src=/images/7-12.webp width=\"30%\" height=\"30%\"></div>\n\n整个窗口只剩下了我们加进去的这个按钮,解决这个问题我们需要了解Swing  \n\n***\n\n>下接[JAVA/面向对象学习笔记(3)](https://www.chuckle.top/article/8636f786.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"Butterfly魔改","url":"/article/ab2d75d5.html","content":"\n# 最新文章标志\n{% link 给首页文章卡片加上最新文章标志,/article/2ed7d622.html,%}<img src=/images/20-1.webp width=\"30%\" height=\"30%\">\n\n# 首页第一个卡片加个class\n{% link 首页第一个卡片加个class,/article/dbde845d.html,%}<img src=/images/21-1.webp width=\"40%\" height=\"40%\">\n\n# 加载进度条\n{% link 一个加载进度条,/article/13d6481a.html,%}<img src=/images/10-1.webp width=\"40%\" height=\"40%\">\n\n# 控制单页背景样式\n{% link 给指定单页加个class以控制其背景样式,/article/eb3a4679.html,%}<img src=/images/22-1.webp width=\"40%\" height=\"40%\">\n\n# 归档、分类、标签页文章卡片加上所属分类和标签\n{% link 给归档、分类、标签页文章卡片的标题下方加上所属分类和标签,/article/a19bb7fb.html,%}<img src=/images/23-2.webp width=\"80%\" height=\"80%\">\n\n# 添加音乐页面\n{% link 添加音乐页面,/article/3322c8a8.html,%}<img src=/images/24-1.webp width=\"40%\" height=\"40%\">\n\n# 给网站增加悬浮伸缩侧边栏\n{% link 给网站增加悬浮伸缩侧边栏,/article/fab5c3df.html,%}<img src=/images/25-1.webp width=\"40%\" height=\"40%\">\n\n***\n\n>咕咕咕~~\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"JAVA/面向对象学习笔记(1)","url":"/article/bfb663c6.html","content":"\n>所看教程（视频）：《浙江大学-翁恺-Java-面向对象程序设计》\n>作为我自己的复习笔记，也可以当做该视频的同步笔记\n\n# 面向对象\n\n## 什么是面向对象\n面向对象是把**一组数据结构**和**处理他们的方法**组成对象。  \n把具有**相同行为**的对象归纳成**类**  \n通过**封装**隐藏类的内部细节  \n通过**继承**使类得到泛化  \n通过**多态**实现基于对象类型的动态分派 \n\n## 只能操作对象\n一切事物都是调用加封装的结果  \n程序实现的一切功能都是**调用**加**封装**的结果  \n程序调用一个个对象  \n封装的也是一个个对象\n\n## 基于对象编程\n同一个事物，构成它的对象能有多种划分方式  \n机器语言、汇编语言将电路上的开关，由1和0组成的指令作为对象  \n\nc语音将对象界定为一个个**数据**和一个个**算法**  \njava将**数据和算法的结合**作为一个对象    \n\n数据和算法分开的编程：面向过程编程  \n数据和算法结合的编程：面向对象编程  \n\n## 面向过程与面向对象\n面向过程关注如何实现，关注如何做，将一个要实现的、复杂的功能，用一个或多个大函数去实现，再抽丝剥茧，用更多的函数去实现这些函数。  \n面向对象关注数据，方法就在这，处理什么数据（对象）  \n\n面向对象中也有面向过程的代码，只是重点不在如何做，而是对对象的**抽象**与**扩展**  \n对于实现功能的核心算法，面向对象与面向过程并无区别，c语言也可通过结构体与函数指针实现面向对象    \n\n面向对象的**封装**、**继承**和**多态**，使得代码、功能的扩展、复用变得非常容易  \n\n这两种编程思想都是为了解决实际的问题  \n\n{% folding, 如何烧水  %}\n**转自互联网**  \n面向过程的烧水：  \n读取热水壶内水的水温，缓存  \n电热装置将发热量缓存  \n损耗算法读取发热量，并将将水的提升温度缓存  \n与水温相加  \n将这个数值重新赋给水温  \n直到温度达到沸点，完成烧水    \n\n面向对象的烧水：  \n定义热水壶类，继承自盛水容器，温度改变装置，温度计，水温控制接口  \n实例化一个热水壶类对象，命名为「我的热水壶」  \n为终止温度赋值：水.沸点  \n我的热水壶.温度处理(终止温度);  \n\n另：个人实现的烧水方法，仅图一乐：  \n为热水壶类实装烧水接口：实装水温监视事件  \n为热水壶类实装烧水接口：定义一个水温枚举器  \n为热水壶类实装烧水接口：实装温度处理方法  \n执行流程：  \n1.执行继承自盛水容器类的盛水方法  \n2.注册继承自温度改变装置类的温度监视事件  \n3.遍历水温枚举器：如果水温提升，则返回当前水温  \n4.如果返回值接近终止温度，跳出枚举过程，完成烧水。  \n5.否则，继续遍历枚举器。  \n\n你肯定会问这哪里优雅了，确实，看起来是复杂了不少，但再仔细想一想，这一整套流程只要稍加修改，稍加改变接口实现，你就可以直接用这个「热水壶类」实现一个热水器，甚至还可以是一个冰箱。  \n毕竟烧的又不一定是水，又不一定要烧水，又不一定要用壶烧水，又不一样要是个烧水壶  \n{% endfolding %}\n\n***\n\n# 对象与类\n对象是实体，需要被创建，可以为我们做事情    \n类是规范，根据类的定义来创建对象    \n\n一个类可以有多个对象  \n\n动物是一个类，每个对象，猫，狗，都是动物类的实体    \n我们用类制造出对象，再给对象所需要的数据，对象可以利用这些数据去做事情，我们大可无需知道对象是如何利用这些数据的，因为我们只要求，这个对象能实现一些功能  \n\n## 面向对象的思维\n我们看到一个事物  \n它有什么东西？  \n能干什么？  \n\n## 第一个程序：自动售货机\n售货机（VendingMachine）有什么？  \n商品的价格：price  \n显示的余额：balance  \n卖了多少钱：total  \n\n售货机能干什么？  \n输出一些提示：showPromot  \n取得一些钱：insertMomey  \n告诉用户余额：showBalance\n给我们商品（食物）：getFood  \n告诉商家总收入：showTotal\n\n我们需要设计VendingMachine这个类，这个类有3个属性，有5个动作（方法）  \n```java\nimport java.util.Scanner;\n//创建一个类\npublic class VendingMachine {\n    int price = 80;//商品价格(假设就只有一个商品，且价格固定)\n    int balance = 0;//当前余额\n    int total = 0;//总收入\n    int amount = 0;//钱\n    Scanner s=new Scanner(System.in);\n\n    void showPromot() {\n        //输出提示\n        System.out.println(\"欢迎！\");\n    }\n\n    void insertMomey(){\n        // 投入钱，更新余额\n        System.out.print(\"请充值余额：\");\n        amount = s.nextInt();\n        balance = balance + amount;\n    }\n\n    void showBalance(){\n        //输出余额\n        System.out.println(\"现在余额： \"+ balance);\n    }\n\n    void getFood(){\n        //给食物\n        if (balance >= price) {\n            System.out.println(\"给你。\");\n            balance = balance - price;\n            total = total + price;\n        }\n        else{\n            System.out.println(\"没有足够的余额！\");\n        }\n    }\n\n    void showTotal(){\n        System.out.println(\"目前总收入：\"+total);\n    }\n}\n```\n有了这个类，就可以通过类去制造一个对象,并让对象去实现一些功能\n```java\npublic class Main {\n    public static void main(String[] args) {\n        //制作一个对象\n        VendingMachine vm = new VendingMachine();\n        boolean t = true;\n        vm.showPromot();\n        vm.showBalance();\n        while (t) {\n            vm.insertMomey();\n            vm.getFood();\n            vm.showBalance();\n            vm.showTotal();\n        }\n    }\n}\n```\n运行结果：  \n```\n欢迎！\n现在余额： 0\n请充值余额：100\n给你。\n现在余额： 20\n目前总收入：80\n请充值余额：20\n没有足够的余额！\n现在余额： 40\n目前总收入：80\n请充值余额：40\n给你。\n现在余额： 0\n目前总收入：160\n请充值余额：\n```\n\n## 创建对象\n使用new运算符，来创建这个类的一个对象  \n然后将这个对象交给这个类型的一个变量  \nVendingMachine vm = new VendingMachine();  \n\n**对象变量是对象的管理者**  \n\n## 让对象做事情\n使用 . 运算符  \nvm.insertMomey();  \nvm.getFood();  \n通过.运算符调用某个对象的方法  \n\n## 成员变量、成员方法\n类定义了**对象中**所具有的变量，这些变量称作成员变量  \n每个对象有自己的变量，和同一个类的其他对象是分开的  \n在方法中可以直接写成员变量（方法）的名字来访问成员变量（方法）（省去了this关键字）  \n\njava会给成员变量默认0值\n\n成员变量（方法）分为实例变量（方法）和类变量（方法）  \n加了static的就是类变量（方法）  \n\n### 类变量\n声明类变量： **static** <类型> <变量名>  \n\n访问类变量：  \n通过对象访问：<对象名>.<类变量名>  \n通过类访问：<类名>.<类变量名>  \n\n类变量不属于任何一个对象，属于这个类，但任何一个对象都拥有这个变量  \n\n修改类变量的值，所有对象中的该变量的值都会改变  \n\n类变量的初始化只会进行一次（在类的装载时）  \n\n### 类方法\n声明类方法： **static** <返回类型> <方法名>() {  }  \n\nstatic方法只能调用static方法，只能访问static变量   \n\n类方法可以通过类的名字去访问，也可以通过对象去访问  \n\n\n## 本地（局部）变量\n定义在**方法内部**的变量是本地变量  \n本地变量的生存期和作用域都是方法内部  \n\n本地变量没被赋值，会被禁止使用  \n\n成员变量的生存期是对象的生存期，作用域是类内部的成员方法 \n\n### var局部变量\n使用var时必须指出初始值(不可以是null)  \nvar <变量名> = <值>;  \n编译器可以推断出该变量的类型，且之后该变量的类型都是确定的，不可以给该变量赋其它类型的值\n\n## 对象初始化\n可以在定义成员变量的地方直接赋值  \nint price = 80;  \n\n在创建一个对象的过程中，会首先去做各种初始化的动作\n\n### 构造方法\n与类同名的函数，没有返回值  \n在创建一个对象时会自动调用的方法\n应该是public\n```java  \nVendingMachine(){\n    total = 10;\n}\n\nVendingMachine(int price ){\n    this.price = price;\n}\n```\n### 方法重载\n一个类里可以有多个**不同参数**的构造方法  \n创建对象的时候给出不同的参数值，就会自动调用不同的构造方法  \n通过this()还可以在构造方法中调用其他构造方法，写在第一行，且只能使用一次    \n一个类里的同名但参数表不同的方法构成了重载关系  \n\n## 对象的识别\n通过巧妙的思想，识别不同出对象的特点，让类更通用  \n例如，要实现一个时钟  \n可以设计一个类，通过这个类可以制造出时、分、秒三个对象  \n\n## 对象的交互\n时、分、秒三个对象可以共同组成一个时钟对象  \n控制时、分、秒之间的交互在时钟对象的方法中完成  \n```java Display.java\npublic class Display {\n    private int value = 0;\n    private int limit = 0;\n\n    public Display(int limit){\n        this.limit = limit;\n    }\n\n    public void increase(){\n        value++;\n        if(value == limit){\n            value = 0;\n        }\n    }\n\n    public int getValue(){\n        return value;\n    }\n\n}\n```\n\n```java Clock.java\npublic class Clock {\n    Display hour = new Display(24);\n    Display minute = new Display(60);\n    Display second = new Display(60);\n\n    public void start() {\n        while (true) {\n            second.increase();\n            if (second.getValue() == 0) {\n                minute.increase();\n                if (minute.getValue() == 0) {\n                    hour.increase();\n                }\n            }\n            System.out.printf(\"%02d:%02d:%02d\\n\", hour.getValue(), minute.getValue(), second.getValue());\n        }\n    }\n}\n```\n\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        Clock clock = new Clock();\n        clock.start();\n    }\n}\n```\n\n***\n\n# 访问属性\n**private**：这个成员是私有的，只有在类的内部（成员方法和定义初始化 ）才能访问  \n一般来说，成员变量都该是private   \n**这个限制是对类的而不是对对象的**：同一个类的不同对象可以互相访问对方的成员变量  \n\n**public**：任何人都可以访问  \n任何人指的是在任何类的方法或定义初始化中可以使用  \n使用指的是调用、访问或定义变量  \n很多的成员方法都是public \npublic的类，类名和文件名要一致，一个编译单元只能有一个public的类  \n\n**protected**：受保护的成员  \n\n**friendly**：默认属性，友好的成员  \n\n| 访问属性  | 本类    | 同包       | 子类      |   其它  |\n| -----    | ------ | --------- | ------   |   ---  |\n| private  |   √    |           |          |        |\n| friendly |     √  |   √       |          |        |\n| protected|   √    |     √     |     √    |        |\n| public   |     √  |     √     |      √   |   √    |\n\n***\n\n# 包package\n包是java管理类的一个机制  \n源文件中同名类要在**不同**包内  \n\n声明该类的指定包名  \npackage <包名>;  \n\n包名中的.代表文件夹的层次  \n\n没有package语句的源程序都将视为在同一个无名包内  \n\n## import\n使用import语句引入包中的类和接口  \n\nimport test.Hallo  \ntest包中的Hallo类  \n\n只要用到的类和本类不在同一个包内，就要import它  \n\n如果不使用import，当要用到类时要给出全名：<包名>.<类名>  \n\n引入一个包内的所有东西：import <包名>.*;（注意同名类的冲突） \n\n***\n# NoteBook例子\n记事本可以做什么？  \n1、能存储记录  \n2、不限制能存储的记录的数量  \n3、能知道已经存储的记录的数量  \n4、能查看存进去的每一条记录  \n5、能删除一条记录  \n6、能列出所有的记录  \n\n确定需求后，进行接口设计  \n```java 接口设计\npublic class NoteBook {\n\n    public void add(String s) {\n        //添加内容\n    }\n\n    public int getSize() {\n        //放了多少个\n        return 0;\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return \" \";\n    }\n\n    public boolean removeNote(int index) {\n        //删除\n        return true;\n    }\n\n    public String[] list() {\n        //返回全部内容\n    }\n\n}\n\n```\n接口设计完，考虑实际功能的实现，首先是数据的存放  \n\n## 顺序容器\n```java\nprivate ArrayList<String> notes = new ArrayList<String>();  \n```\n用来存放String的一个ArrayList  \nArrayList内的东西是有顺序的，是加入数据的顺序，形成对应下标的索引（从0开始）  \n\n这种类型叫做范型类：泛型类封装不特定于特定数据类型的操作  \n这种范型类是一种容器  \n\n容器类有两个类型：容器的类型、元素的类型  \n\n利用容器类的方法可以实现需要的功能  \nnotes.add(s);  //向容器添加数据\nnotes.size();  //容器存了多少个东西\nnotes.get(1); //得到1位置处的数据\n\n完成全部功能接口\n```java NoteBook.java\nimport java.util.ArrayList;\n\npublic class NoteBook {\n    private ArrayList<String> notes = new ArrayList<String>();//容器类\n\n    public void add(String s) {\n        //添加内容\n        notes.add(s);\n    }\n\n    public void add(String s, int location) {\n        //加到指定位置前，后面的内容下标后推\n        notes.add(location, s);\n    }\n\n    public int getSize() {\n        //放了多少个\n        return notes.size();\n    }\n\n    public String getNote(int index) {\n        //得到指定位置的内容\n        return notes.get(index);\n    }\n\n    public void removeNote(int index) {\n        //删除，后面下标前移，因为remove方法自会抛异常，所以无需返回boolean\n        notes.remove(index);\n    }\n\n    public String[] list() {\n        //返回全部内容\n        String[] a = new String[notes.size()];\n\n        //for (int i=0; i< notes.size(); i++){\n        //    a[i] = notes.get(i);\n        //}\n        notes.toArray(a);//会自己把数组按顺序填好\n        //要熟悉系统类库里有的方法，无需重复造轮子\n        return a;\n    }\n\n}\n```\n写出上层程序\n```java Main.java\npublic class Main {\n    public static void main(String[] args) {\n        NoteBook nb = new NoteBook();\n\n        nb.add(\"first\");\n        nb.add(\"second\");\n        System.out.println(nb.getSize());\n        System.out.println(nb.getNote(1));\n\n        nb.add(\"third\", 1);\n        System.out.println(nb.getNote(1));\n        System.out.println(nb.getNote(2));\n        System.out.println(nb.getSize());\n\n        nb.removeNote(1);\n        String[] b = nb.list();\n        for (String s : b) {\n            System.out.println(s);\n        }\n    }\n\n}\n\n```\n输出：\n```\n2\nsecond\nthird\nsecond\n3\nfirst\nsecond\n```\n\n## 对象数组\n```java\nString[] a = new String[notes.size()];  \n```\n对象数组中的每个元素都是对象的管理者而非对象本身  \n当创建了一个对象数组，只是管理者们被创建了，但对象还没有，得想办法把每个对象创建出来  \n\n### for-each循环\n对于普通数组：  \n```java\nint[] a = new int[10];\nfor (int i = 0; i < a.length; i++) {\n    a[i] = i;//赋值\n}\nfor ( int k : a ) {\n    System.out.println(k);\n    k++;//每个k都是a中元素的复制品，不会起作用\n}\n```\n对于对象数组：  \n```java\nValue[] a = new Value[10]; \nfor (int i=0; i< 10; i++){\n    a[i] = new Value[];\n    a[i].set(i);\n}\nfor ( Value v : a ){\n    System.out.println(v.get());\n    v.set(0);//起作用，因为对象数组存的是对象管理者，v=a[i]，v也会成为对象管理者\n}\n```\n\n\n## 集合容器\n集合容器内所有元素都不相同  \n而且里面的元素不排序  \n```java\nHashSet<String> s = new HashSet<String>();\ns.add(\"first\");\ns.add(\"second\");\ns.add(\"first\");\nSystem.out.println(s);//容器都可以这样输出\n```\n输出：\n```java\n[second, first]\n```\n\n## public String toString\n在java中只要类中实现了这样一个方法  \n就可以直接用对象名输出这个对象  \n容器当中都有这样一个方法 \n```java\npublic String toString(){  \n    return \"\";  \n}  \n```\n\n## Hash表\n例子：数字与美元硬币名字对应，查找硬币名称  \n1=penny  \n5=nickel  \n10=dime  \n25=quarter  \n50=half-dollar\n\n定义接口：\n```java\npublic class Coin {\n    public String getName(int amount){\n            return  \"\";\n    }\n}\n```\n为什么不用switch-case？  \n体现在代码中的硬编码越少越好  \n\n使用Hash表（一种数据结构）  \n在这个表中，所有东西是以一对值放入的，一个叫做key（键），一个叫做值  \n一个key对应一个值，可以用key取值  \nHash表中的元素没有顺序  \n```java Coin.java\nimport java.util.HashMap;\n\npublic class Coin {\n    //不能使用int，容器当中所有的类型都得是对象,而不能是基本类型\n    //Integer是int的包裹类型\n    private HashMap<Integer, String> coinnames = new HashMap<Integer, String>();\n\n    public Coin(){\n        coinnames.put(1, \"penny\");//1对应penny\n        coinnames.put(10, \"dime\");\n        coinnames.put(25, \"quarter\");\n        coinnames.put(50, \"half-dolar\");\n        \n        System.out.println(coinnames.keySet().size());//keySet()，把所有key做为一个HashSet的集合给你，在这个集合可以得到size\n        System.out.println(coinnames);//也可以直接输出\n        coinnames.put(50, \"五十\");//会替换掉前面的\n        System.out.println(coinnames);\n        for (Integer k : coinnames.keySet()){//遍历Hash表\n            String s = coinnames.get(k);\n            System.out.println(s);\n        }\n    }\n\n    public String getName(int amount){\n        if (coinnames.containsKey(amount))\n            return coinnames.get(amount);\n        else\n            return  \"NOT FOUND\";//不判断的话，不存在会返回null\n    }\n\n\n}\n```\n```java Main.java\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int amount = in.nextInt();\n        Coin coin = new Coin();\n        String name = coin.getName(amount);\n        System.out.println(name);\n    }\n}\n```\n输出：\n```java\n10\n4\n{1=penny, 50=half-dolar, 25=quarter, 10=dime}\n{1=penny, 50=五十, 25=quarter, 10=dime}\npenny\n五十\nquarter\ndime\ndime\n```\n\n***\n\n# 继承与子类\n\n## 媒体资料库设计\n和NoteBook一样，需要设计一个类,用类去表达一种媒体（CD,DVD）  \n然后用一个媒体类的容器去装媒体对象，一个资料库就完成了  \n\nCD有什么？  \n名称：title  \n艺术家：artist  \n多少首歌：numofTracks  \n持续时间：playingTime  \n是否被借出：gotIt  \n描述：comment  \n\n能做什么？\n输出一些信息：print\n\n```java CD.java\npublic class CD{\n    private String title;\n    private String artist;\n    private int numofTracks;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        System.out.print(title+\":\");\n        System.out.println(artist);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.list();\n    }\n}\n```\n现在资料库中已经可以存各种CD媒体了  \n但我们还想在资料库中存DVD媒体或者其它媒体类型  \n\n当然，我们可以再创建一个类表示DVD\n```java DVD.java\npublic class DVD{\n    private String title;\n    private String director;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        this.director = director;\n        this.title = title;\n        this.playingTime = playingTime;\n        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        System.out.print(title+\":\");\n        System.out.println(director);\n    }\n}\n```\n设计好类后在Database.java里创建一个放DVD的容器,以及配套的方法    \n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n    private ArrayList<CD> listCD = new ArrayList<CD>();\n    //+\n    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n\n    public void add(CD cd){\n        listCD.add(cd);\n    }\n    //+\n    public void add(DVD dvd){\n        listCD.add(dvd);\n    }\n\n    public void list(){\n        for (CD cd : listCD){\n            cd.print();\n        }\n        //+\n        for(DVD dvd : listDVD){\n            dvd.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        //+\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n现在资料库中能存放两种媒体  \n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \n我们创建了一个资料库类  \n资料库类里有两个容器，用来存放两种不同类型的媒体的对象管理者  \n\n<div><img src=/images/7-1.webp width=\"70%\" height=\"70%\"></div>\n\n这样的结构虽然能实现我们需要的功能，但DVD和CD类几乎一模一样   \n出现了很多代码复制，这是代码质量不良的表现  \n当我们需要修改print，add等方法，就得逐个去改  \n当我们需要新增一种媒体，就得为它做很多的工作  \n\n## 继承\nCD和DVD类很相似，我们可以从中提取一些它们共有的东西封装成一个类Item  \nItem可以表达CD或者DVD  \n而Database只需管Item  \n\n```java Item.java\npublic class Item {\n    private String title;\n    private int playingTime;\n    private boolean gotIt = false;\n    private String comment;\n\n    public Item(String title, int playingTime, boolean gotIt, String comment) {\n        this.title = title;\n        this.playingTime = playingTime;\n        this.gotIt = gotIt;\n        this.comment = comment;\n    }\n\n    public Item(){\n\n    }\n\n    public void print() {\n        System.out.print(title+\":\");\n    }\n\n}\n```\n```java CD.java\npublic class CD extends Item{\n//    private String title;\n    private String artist;\n    private int numofTracks;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public CD(String title, String artist, int numofTracks, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n//        this.title = title;\n        this.artist = artist;\n        this.numofTracks = numofTracks;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"CD:\");\n        super.print();\n        System.out.println(artist);\n    }\n}\n```\n```java DVD.java\npublic class DVD extends Item{\n//    private String title;\n    private String director;\n//    private int playingTime;\n//    private boolean gotIt = false;\n//    private String comment;\n\n    public DVD(String title, String director, int playingTime, String comment) {\n        super(title, playingTime, false, comment);\n        this.director = director;\n//        this.title = title;\n//        this.playingTime = playingTime;\n//        this.comment = comment;\n    }\n\n    public void print() {\n        System.out.print(\"DVD:\");\n        super.print();\n        System.out.println(director);\n    }\n}\n```\n```java Database.java\nimport java.util.ArrayList;\n\npublic class Database {\n//    private ArrayList<CD> listCD = new ArrayList<CD>();\n//    private ArrayList<DVD> listDVD = new ArrayList<DVD>();\n    private ArrayList<Item> listItem = new ArrayList<Item>();\n\n//    public void add(CD cd){\n//        listCD.add(cd);\n//    }\n//\n//    public void add(DVD dvd){\n//        listCD.add(dvd);\n//    }\n    public void add(Item item){\n        listItem.add(item);\n    }\n\n    public void list(){\n//        for (CD cd : listCD){\n//            cd.print();\n//        }\n//        for(DVD dvd : listDVD){\n//            dvd.print();\n//        }\n        for (Item item : listItem){\n            item.print();\n        }\n    }\n\n    public static void main(String[] args) {\n        Database db = new Database();\n        db.add(new CD(\"abc\",\"aaa\",4,60,\"bb\"));\n        db.add(new CD(\"adc\",\"dgh\",5,40,\"ak\"));\n        db.add(new DVD(\"add\",\"eee\",45,\"qqq\"));\n        db.list();\n    }\n}\n```\n运行一下： \n```java 输出\nCD:abc:aaa\nCD:adc:dgh\nDVD:add:eee\n```\n上面发生了什么？  \nCD extends Item：CD扩展了Item  \n即CD变成了Item的子类  \n这就是**继承**  \nCD得到了Item里所有的东西  \n\n<div><img src=/images/7-2.webp width=\"70%\" height=\"70%\"></div>\n\n## 子类与父类\n当父类里的东西是private时  \nprivate String title;  \n子类得到了这个东西，但不能用（可以通过父类的方法去用）  \n解决办法：将private改成protect  \n但这样不好，有很多时候父类和子类不在同一个包内  \n\ntitle本来就是父类的东西  \n可以让title在父类中初始化完，再让子类得到title  \n```java\npublic Item(String title) {\n    this.title = title;\n}\n```\n在子类构造器中使用super()来得到父类的title  \n```java\n public CD(String title) {\n    super(title);\n}\n```\n\n### super()\n当程序初始化对象时，会先运行super()  \n然后去运行父类的构造器，再回来继续运行自己的构造器  \n\nsuper():去父类调用一个没有参数的构造器  \nsuper(<参数>):去父类调用一个有对应参数的构造器  \n\n当子类没有super(),会默认去调用父类没有参数的构造器  \n\n通过super关键字来实现对父类成员的访问，用来引用当前对象的父类  \nsuper.<父类成员>  \n\n通过this来区分子类父类中的同名成员  \nthis.aaa();   // this 调用自己的方法  \nsuper.aaa();  // super 调用父类方法  \n\n## 子类和子类型\n类定义了类型  \n子类定义了子类型  \n\n子类的对象可以被当作父类的对象来使用  \n-赋值给父类的变量（父类的对象管理者可以管理子类的对象）  \n<div><img src=/images/7-3.webp width=\"70%\" height=\"70%\"></div>\n\n-传递给需要父类对象的方法  \n\n\n-放进存放父类对象的容器里  \n<div><img src=/images/7-4.webp width=\"70%\" height=\"70%\"></div>\n\n<div><img src=/images/7-5.webp width=\"35%\" height=\"35%\"></div>\n\n***\n\n# 多态\n## 多态变量\n所有的**对象变量**都是**多态**的（它们能保存不止一种类型的对象，不同时刻可以放不同类型的对象（例如父类的对象变量放子类的对象））  \n它们可以保存的是声明类型的对象，或声明类型的子类的对象  \n\n当把**子类的对象**赋给**父类的变量**的时候，就发生了**向上造型**  \n\n每一个java的对象变量，都具有两个类型  \n一个是**声明类型**  \n一个是**动态类型**  \n有时候两者是一致的，有时候又不一样  \n\n这就是变量的多态（在运行过程中，它所管理的对象类型是会变化的）  \n\n## 造型\n造型：把一个类型的**对象**，赋给另一个类型的**变量**\n\n对象变量的赋值并不是把一个对象赋给另一个对象（注在c++中可以做两个对象之间的赋值）  \n而是让这两个对象的管理者去**管理同一个对象**  \n```java\nString s = \"hello\";\n//原本这个String类型的对象变量s管理着一个对象\n//这个对象里面有个\"hello\"\ns = \"bye\";\n//后来s去管理另一个对象，里面有\"bye\"\n```\n并不是将bye替换掉hello，java不能做这种事  \n\njava中”=“的赋值运算，实际上是在改变指向  \n```java\nString s = \"hello\";\nString t = \"bye\";\ns = t;\n//原本s和t各管理一个对象，现在s和t管理同一个对象，里面有”hello“\n```\n当给一个**对象变量**管理着与它声明（静态）类型**不符**的对象时，就发生了**造型**  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\n//把子类的对象赋给父类的变量，让父类的对象变量去管理子类的对象\n```\n父类对象是不能直接赋给子类对象变量的\n但可以强制把父类对象当成子类的对象，然后去造型  \n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nItem item = cd;\nCD cc = item;//不行。父类对象不能直接交给子类对象变量去管理\nCD cc = (CD)item;//行，因为item已经管理着一个CD的对象了\n//强制把item的类型当做CD\n```\n如果没有Item item = cd;\n```java CD是Item的子类\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\n//Item item = cd;\nCD cc = (CD)item;//编译可以通过，但运行会出错\n```\n将一个变量强制造型成另一个类型，然后赋给另一个变量  \nCD cc = (CD)item;  \n只有当item这个变量**实际管理**着CD类型的对象才不会出错  \n\n在C语言中，有类似写法，但是是类型转换（对于基本类型int、double，java也能强制类型转换）  \nint i = (int)10.2;//强制类型转换\n这与造型是不同的  \n类型转换是将10.2变成了10  \n但造型只是把item当做CD类型来看待  \nitem本身还是Item类型  \n\n(类型名)对象名：将一个对象当做这个类型来看待  \n\n### 向上造型\n向上造型是特殊的造型，无需写(父类类型)  \n拿一个子类的对象，当作父类的对象来用  \n向上造型总是安全的  \n\n## 方法调用的绑定\n```java\npublic void list(){\n    for (Item item : listItem){\n        item.print();\n    }\n}\n```\nitem每次循环管理的对象不一样，甚至管理的对象的类型也不一样，可以是CD或是DVD  \n当item管理CD(DVD)类型的对象时，去调用print方法，调用的是CD(DVD)类型里的print  \n\n\n当通过对象变量调用方法的时候，调用哪个方法这件事情叫做绑定  \n-静态绑定：根据变量的声明类型来决定  \n-动态绑定：根据变量的动态类型来决定  \n在成员函数中调用其他成员函数也是通过this这个对象变量来调用的  \n\njava默认所有的绑定都是动态绑定  \n\n### 覆盖\n子类和父类中存在**名称和参数表**完全相同的函数，这一对函数构成**覆盖**关系  \n通过父类的变量调用存在覆盖关系的函数时，调用变量当时所**管理的对象**所属的类的函数  \n这是一种动态绑定  \n\n## 多态总结\n多态性是对象多种表现形式的体现  \n\n通过一个变量去调用一个函数，我们不去判断变量运行中实际类型是什么，我们只想它能print  \n多态是**同一个行为**具有多个**不同表现形式或形态**的能力  \nitem是CD类型时它这样print，是DVD类型时那样print，但都是print行为  \n\n***\n\n# 类型系统\n\n## Object类\njava中所有类都是Object类型的子类  \n这是一种单根结构  \n<div><img src=/images/7-6.webp width=\"70%\" height=\"70%\"></div>\n\n发生继承时，父类所有public的东西子类都会得到  \n所以java中所有的类，都从Object类中得到了两个函数  \n-toString()  \n-equals()  \n\n## toString()\ntoString()会返回一个字符串，用来表达对象  \n\n当一个类中没有toString()方法时，会调用继承自Object类的toString()  \n```java\nCD cd = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd.toString());\nSystem.out.println(cd);//和上面的效果一个月，编译器会知道这个地方需要调用toString()\n\nString s = \"aa\"+cd;//编译器知道这个地方需要调用toString()\nSystem.out.println(s);\n```\n```java 输出\nCD@3d075dc0\n//类型名+一个类似地址、编号的东西\nCD@3d075dc0\naaCD@3d075dc0\n```\n显然，默认的表达这个对象的toString(),是返回一个类型名+一个类似地址、编号的东西  \n\n我们可以在类中自定义一个toString()  \n即设计一个表达对象的toString()  \n```java\n@Override\npublic String toString() {\n    return \"CD{\" +\n            \"artist='\" + artist + '\\'' +\n            \", numofTracks=\" + numofTracks +\n            '}';\n    }\n```\n```java 输出\nCD{artist='aaa', numofTracks=4}\n```\n\n## equals()\n\n==**无法**比较两个对象的内容是否相同，只能比较这两个对象变量是否管理着同一个对象    \n我们需要使用equals()去比较内容  \n\n当类中没有equals()，会调用继承自Object类的equals()  \n```java\nCD cd1 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nCD cd2 = new CD(\"abc\",\"aaa\",4,60,\"bb\");\nSystem.out.println(cd1.equals(cd2));\n```\n```java 输出\nfalse\n```\nObject这个公共父类的equals()无法知道它的子类长什么样子，所以也无法比较这两个对象内容是否相等  \nObject的equals()实际上也是在比较两个对象变量是否管理着同一个对象\n\n我们需要使用自定义的equals()去比较内容  \n```java\n@Override\npublic boolean equals(Object o) {\n    CD cc = (CD) o;//将Object o看作是CD类型的\n    return numofTracks == cc.numofTracks && artist.equals(cc.artist);\n}\n```\n```java 输出\ntrue\n```\n\n## @Override\n作用：告诉编译器，这个函数覆盖了父类的同属性、同名、同参方法  \n也可能会在代码界面报错，如果这个函数没有和父类的同名方法有相同属性、参数\n\n不带@Override，如果自定义的equals()和父类的同属性、同名、同参  \n那么也会覆盖掉父类的，@Override只是起帮助检查作用  \n\n***\n\n# 可扩展性\n现在要往Database这个资料库里增加新的媒体类型，是一件非常容易的事情    \n```java VideoGame.java\npublic class VideoGame extends Item {\n    private int numberofPlayers;\n\n    public VideoGame(String title, int playingTime, boolean gotIt, String comment, int numberofPlayers) {\n        super(title, playingTime, gotIt, comment);\n        this.numberofPlayers = numberofPlayers;\n    }\n\n    public void print() {\n        System.out.print(\"VideoGame:\");\n        super.print();\n        System.out.println(numberofPlayers);\n    }\n}\n```\n<div><img src=/images/7-7.webp width=\"70%\" height=\"70%\"></div>\n\n只需要增加一个子类，然后构造一下，覆盖下方法，父类完全不需要去动  \n这种特性叫**可扩展性**：代码无需修改即可扩展去适应新的数据、新的内容  \n\n如果需要修改去适应新的数据、新的内容，则叫**可维护性**  \n\n***\n\n>下接[JAVA/面向对象学习笔记(2)](https://www.chuckle.top/article/9f2dc6c7.html)","tags":["JAVA","JavaSE"],"categories":["学习笔记"]},{"title":"C语言单链表菜品管理系统","url":"/article/a696e8fe.html","content":"\n# 简介\n我的大一上学期期末项目，也是C语言的期末大作业。  \n\n使用单链表进行菜品信息的存储，系统有菜品的增删改查、排序、安全输入、统计、随机输出和文件输入输出等功能。 \n\n现在回去看代码想给自己一锤子（误）\n\n***\n\n# 包含文件\n<div><img src=/images/6-8.webp width=\"70%\" height=\"70%\"></div>\n\n***\n\n# 函数说明\n<div><img src=/images/6-9.webp width=\"70%\" height=\"70%\"></div>\n<div><img src=/images/6-10.webp width=\"70%\" height=\"70%\"></div>\n\n***\n# 代码\n```c 900行有点长\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <time.h>\n#include <windows.h>\n\n#define SIZE1 100 //名称，价格等字数\n#define SIZE2 200 //限制评价字数\n\ntypedef struct _node\n{\t\t\t\t\t\t\t//链表的节点结构体\n\tchar name[SIZE1];\t\t//菜品名称\n\tchar restaurant[SIZE1]; //饭店名字\n\tfloat price;\t\t\t//菜的价格\n\tint fraction;\t\t\t//菜的评分\n\tchar comment[SIZE2];\t//菜品评价\n\tstruct _node *next;\n} Node;\ntypedef struct _list //方便对链表操作\n{\n\tNode *head;\n\tNode *pa;\n\tNode *pb;\n\tNode *pc;\n} List;\n//菜单\nvoid menu(void);\t\t\t   //一级菜单\nvoid menu_inquire(List *list); //二级菜单_查询菜单\nvoid help(void);\t\t\t   //二级菜单_帮助菜单\nint menu_sort(List *list);\t   //三级菜单_排序方法\n//对节点操作\nvoid add(List *list);\t  //添加节点\nvoid delete (List *list); //删除节点\nvoid revise(List *list);  //修改节点\n//安全输入\nchar *s_gets(char *st, int n); //安全输入字符\nint get_int(void);\t\t\t   //安全输入int型\nfloat get_float(void);\t\t   //安全输入float型\n//链表的输出和操作\nvoid inquire_all(List *list);\t\t\t//输出链表全部节点\nvoid inquire_one(List *list);\t\t\t//输出链表指定菜名节点\nvoid inquire_restaurant(List *list);\t//输出链表指定饭店节点\nvoid inquire_part_price(List *list);\t//输出一定价格以下的菜品(这功能。。贫穷)\nvoid inquire_part_fraction(List *list); //输出一定评分以上的菜品\nvoid average_percentage(List *list);\t//查询某饭店或食堂的平均价格和评分\nvoid output(Node *p);\t\t\t\t\t//方便输出\nvoid random_menu(List *list);\t\t\t//随机输出一道菜\nvoid empty(List *list);\t\t\t\t\t//清空链表\n//文件操作\nvoid save(List *list);\t   //保存\nvoid read_txt(List *list); //读取文件_初始链表\n//单链表的排序\nvoid sort_ascending(List *list);\t\t //菜品按价格从低到高排序\nvoid sort_descending(List *list);\t\t //菜品按价格从高到低排序\nvoid sort_score(List *list);\t\t\t //菜品按评分从高到低排序\nint calculate(List *list);\t\t\t\t //计算出单链表的节点个数\nvoid swap1(List *list, List *list_swap); //单链表冒泡排序的算法块1\nvoid swap2(List *list, List *list_swap); //单链表冒泡排序的算法块2\n//其他\nint random_number(List *list); //随机生成不大于节点数的整数\nvoid color(int a);\t\t\t   //控制台文本颜色\n//______________________________________________________\n//------------------------------------------------------\nint main() //主函数\n{\n\t//system(\"chcp 65001\");//GB2313\n\t//system(\"chcp 936\");//UTF8\n\t//system(\"cls\");\n\tmenu(); //输出功能菜单\n\t//佛祖开光无bug\n\treturn 0;\n}\n//菜单\nvoid menu() //一级菜单\n{\n\tint options, z = 1;\n\tList list;\n\tlist.head = NULL;\t\t\t\t   //head指向空，链表不存在\n\tFILE *fp = fopen(\"Menu.txt\", \"a\"); //若无Menu.txt文件，则创建一个\n\tfclose(fp);\n\tread_txt(&list); //读入txt中的数据，初始化链表\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(14);\n\t\tprintf(\"|                    菜品信息系统             \\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"|********************系统功能菜单*********************\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|1、使用帮助|                       \\n\");\n\t\tprintf(\"|*******************|2、添加菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|3、删除菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|4、查询菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|5、修改菜品信息|                    \\n\");\n\t\tprintf(\"|*******************|6、今天吃什么|                     \\n\");\n\t\tprintf(\"|*******************|7、清空所有数据|                     \\n\");\n\t\tprintf(\"|*******************|8、保存|\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|*******************|0、退出系统|                       \\n\");\n\t\tcolor(12);\n\t\tprintf(\"|!!!前请先保存再退出系统,否则数据会丢失!!!\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0; //跳出循环\n\t\t\tprintf(\"即将退出系统。\\n\");\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\thelp();\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tadd(&list);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tdelete (&list);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tmenu_inquire(&list);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\trevise(&list);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\trandom_menu(&list);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tempty(&list);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tsave(&list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n\tsystem(\"pause\");\n}\nvoid help() //二级菜单_帮助菜单\n{\n\tsystem(\"cls\");\n\tprintf(\"\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tcolor(15);\n\tprintf(\"|使用帮助：\\n\");\n\tprintf(\"|1、本菜品信息系统可供用户自行修改内容\\n\");\n\tprintf(\"|2、因为考虑到不同饭店有同样名称的菜品，本系统允许菜品名称有重复\\n\");\n\tprintf(\"|3、请勿输入错误信息，以免造成程序出错\\n\");\n\tprintf(\"|4、关闭系统前记得保存！否则数据会丢失\\n\");\n\tprintf(\"|5、有bug联系1934009145@qq.com\\n\");\n\tprintf(\"|6、github地址:github.com/qxchuckle/Dishes-Management-System\\n\");\n\tcolor(2);\n\tprintf(\"|-----------------------------------------------------------------\\n\");\n\tprintf(\"\\n\");\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid menu_inquire(List *list) //二级菜单_查询菜单\n{\n\tint options, z = 1;\n\tList *p = list;\t\t\t//方便传结构体指针\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！无法查询！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn; //为空结束函数\n\t}\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、查询全部菜品信息\\n\");\n\t\tprintf(\"|2、按菜名查询菜品信息\\n\");\n\t\tprintf(\"|3、查询饭店或食堂的全部菜品信息\\n\");\n\t\tprintf(\"|4、查询某价格以下的全部菜品\\n\");\n\t\tprintf(\"|5、查询某评分以上的全部菜品\\n\");\n\t\tprintf(\"|6、查询某饭店或食堂的平均价格、评分和价格区间占比\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_all(p);\n\t\t\treturn;\n\t\tcase 2:\n\t\t\tinquire_one(p);\n\t\t\treturn;\n\t\tcase 3:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_restaurant(p);\n\t\t\treturn;\n\t\tcase 4:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_price(p);\n\t\t\treturn;\n\t\tcase 5:\n\t\t\tif (menu_sort(p))\n\t\t\t\tinquire_part_fraction(p);\n\t\t\treturn;\n\t\tcase 6:\n\t\t\taverage_percentage(p);\n\t\t\treturn;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t}\n\t}\n}\nint menu_sort(List *list) //三级菜单_排序方法\n{\n\tint options, z = 1, n = 1;\n\tList *p = list;\n\twhile (z)\n\t{\n\t\tsystem(\"cls\");\n\t\tprintf(\"\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(15);\n\t\tprintf(\"|1、按价格从低到高排序\\n\");\n\t\tprintf(\"|2、按价格从高到低排序\\n\");\n\t\tprintf(\"|3、按评分从高到低排序\\n\");\n\t\tprintf(\"|4、不排序\\n\");\n\t\tprintf(\"|0、返回主菜单\\n\");\n\t\tcolor(2);\n\t\tprintf(\"|-----------------------------------------------------\\n\");\n\t\tcolor(11);\n\t\tprintf(\"请输入功能序号：\");\n\t\tcolor(15);\n\t\toptions = get_int();\n\t\tswitch (options)\n\t\t{\n\t\tcase 0:\n\t\t\tz = 0;\n\t\t\treturn z;\n\t\tcase 1:\n\t\t\tsort_ascending(p);\n\t\t\treturn n;\n\t\tcase 2:\n\t\t\tsort_descending(p);\n\t\t\treturn n;\n\t\tcase 3:\n\t\t\tsort_score(p);\n\t\t\treturn n;\n\t\tcase 4:\n\t\t\treturn n;\n\t\tdefault:\n\t\t\tcolor(12);\n\t\t\tprintf(\"无该功能，请重新输入\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\tcolor(15);\n\t\t}\n\t}\n}\n//对节点操作\nvoid add(List *list) //添加节点\n{\n\tfloat k = 1;\n\tint n = 0, i = 0;\n\tNode *last = list->head;\n\tNode *p1 = (Node *)malloc(sizeof(Node)), *p; //给节点分配空间\n\tp1->next = NULL;\n\tsystem(\"cls\");\n\tputs(\"开始录入菜品：\\n----------------\\n\");\n\tputs(\"请输入菜品名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->name, SIZE1);\n\t} while (strlen(p1->name) == 0);\n\tputs(\"请输入菜品所属饭店or食堂名称：\");\n\tdo\n\t{\n\t\ts_gets(p1->restaurant, SIZE1);\n\t} while (strlen(p1->restaurant) == 0);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(p1->name, p->name) || strcmp(p1->restaurant, p->restaurant)))\n\t\t{\n\t\t\tcolor(12);\n\t\t\tprintf(\"该饭店/食堂内已存在同名菜品！\\n\");\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t}\n\tputs(\"请输入菜品的价格：\");\n\tp1->price = get_float();\n\tputs(\"请输入0-10的整数对菜品进行评分：\");\n\tdo\n\t{\n\t\tn = get_int();\n\t\tif (n >= 0 && n <= 10) //判断评分是否是0-10\n\t\t{\n\t\t\tp1->fraction = n;\n\t\t\ti = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor(12);\n\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (!i);\n\tputs(\"请对菜品进行评价：\");\n\tdo\n\t{\n\t\ts_gets(p1->comment, SIZE2);\n\t} while (strlen(p1->comment) == 0);\n\tif (last) //如果last有值，则说明head已指向链表第一个节点\n\t{\n\t\twhile (last->next)\n\t\t{\n\t\t\tlast = last->next; //last始终指向最后一个节点\n\t\t}\n\t\tlast->next = p1; //在最后一个节点后面再加一个节点\n\t}\n\telse\n\t{\n\t\tlist->head = p1; //如果last为NULL，则要将head指向第一个节点\n\t}\n\tcolor(11);\n\tputs(\"录入成功！\");\n\tsystem(\"pause\");\n}\nvoid delete (List *list) //删除节点\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL)\n\t{ //判断链表是否为空\n\t\tprintf(\"还未存入任何菜品！删除失败！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入你要删除的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next)\n\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t   //遍历链表\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要修改的节点\n\t\t{\n\t\t\tn++;   //记录找到了\n\t\t\tif (q) //判断找到的是不是第一个节点\n\t\t\t{\n\t\t\t\tq->next = p->next; //让该节点的前一个节点都next指向后一个节点\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlist->head = p->next; //让head的next指向后一个节点\n\t\t\t}\n\t\t}\n\t}\n\tif (!n)\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n删除成功%d道菜。\\n\", n);\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid revise(List *list) //修改节点\n{\n\tfloat k = 1;\n\tint n = 0, m = 0, i = 0;\n\tchar a[SIZE1];\n\tchar b[SIZE1];\n\tNode *p, *q;\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tprintf(\"还未存入任何菜品！无法修改！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tsystem(\"cls\");\n\tprintf(\"请输入要修改的菜品的名称：\");\n\ts_gets(a, SIZE1);\n\tprintf(\"请输入菜品所属饭店名称：\");\n\ts_gets(b, SIZE1);\n\tfor (q = NULL, p = list->head; p; q = p, p = p->next) //遍历链表\n\t{\n\t\tif (!(strcmp(a, p->name) || strcmp(b, p->restaurant))) //判断是否找到要删除的节点\n\t\t{\n\t\t\tn++; //记录找到\n\t\t\tprintf(\"\\n原来的菜品信息:\\n\");\n\t\t\tprintf(\"|菜名:%s\\n\", p->name);\n\t\t\tprintf(\"|所属:%s\\n\", p->restaurant);\n\t\t\tprintf(\"|价格:%.2f\\n\", p->price);\n\t\t\tprintf(\"|评分:%d\\n\", p->fraction);\n\t\t\tprintf(\"|评价:%s\\n\", p->comment);\n\t\t\tprintf(\"\\n\");\n\t\t\tputs(\"请修改菜品的价格：\");\n\t\t\tp->price = get_float();\n\t\t\tputs(\"请输入0-10的整数以修改菜品的评分：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\tm = get_int();\n\t\t\t\tif (m >= 0 && m <= 10)\n\t\t\t\t{\n\t\t\t\t\tp->fraction = m;\n\t\t\t\t\ti = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcolor(12);\n\t\t\t\t\tputs(\"评分不在规定范围内，请重新输入：\");\n\t\t\t\t\tcolor(15);\n\t\t\t\t}\n\t\t\t} while (!i);\n\t\t\tputs(\"请修改对菜品的评价：\");\n\t\t\tdo\n\t\t\t{\n\t\t\t\ts_gets(p->comment, SIZE2);\n\t\t\t} while (strlen(p->comment) == 0);\n\t\t}\n\t}\n\tif (n)\n\t{\n\t\tprintf(\"\\n修改完成。\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"\\n没有这道菜！\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\n//安全输入\nchar *s_gets(char *m, int n) //安全输入字符\n{\n\tchar *p;\n\tchar *find;\n\tp = fgets(m, n, stdin);\n\tif (p)\n\t{\n\t\tfind = strchr(m, '\\n'); //查找换行符\n\t\tif (find)\t\t\t\t//如果地址不是NULL\n\t\t\t*find = '\\0';\t\t//在此处放一个空字符\n\t\telse\n\t\t\twhile (getchar() != '\\n')\n\t\t\t\tcontinue;\n\t}\n\treturn p;\n}\nint get_int() //安全输入int型\n{\n\tint n;\n\tchar ch;\n\twhile (scanf(\"%d%*c\", &n) != 1)\n\t{\n\t\twhile ((ch = getchar()) != '\\n')\n\t\t\tputchar(ch);\n\t\tcolor(4);\n\t\tprintf(\" 不是一个正整数！\\n请您重新输入：\\n\");\n\t\tcolor(15);\n\t}\n\treturn n;\n}\nfloat get_float() //安全输入float型\n{\n\tfloat n = 1;\n\tchar ch;\n\tdo\n\t{\n\t\tif (n <= 0)\n\t\t{ //用户输入不是正数输出提示\n\t\t\tcolor(12);\n\t\t\tputs(\"请重新输入一个正数！\");\n\t\t\tcolor(15);\n\t\t}\n\t\twhile (scanf(\"%f%*c\", &n) != 1)\n\t\t{\n\t\t\twhile ((ch = getchar()) != '\\n')\n\t\t\t\tputchar(ch);\n\t\t\tcolor(12);\n\t\t\tprintf(\" 不是一个正数！\\n请您重新输入：\\n\");\n\t\t\tcolor(15);\n\t\t}\n\t} while (n <= 0);\n\treturn n;\n}\n//链表的输出和操作\nvoid inquire_all(List *list) //输出链表全部节点\n{\n\tNode *p;\n\tint n = 1;\n\tsystem(\"cls\");\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tprintf(\"\\n第%d道菜:\", n);\n\t\toutput(p);\n\t\tn++;\n\t}\n\tcolor(11);\n\tprintf(\"\\n所有菜品查询完毕\\n\");\n\tsystem(\"pause\");\n}\nvoid inquire_one(List *list) //输出指定菜名\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的菜品名称：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->name)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_restaurant(List *list) //输出指定饭店所有菜品\n{\n\tint n = 0;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要找的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_price(List *list) //输出一定价格以下的菜品(这功能。。贫穷)\n{\n\tint n = 0;\n\tfloat money, k = 1;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入封顶价格：\");\n\tmoney = get_float();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->price <= money) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tsystem(\"pause\");\n}\nvoid inquire_part_fraction(List *list) //输出一定评分以上的菜品\n{\n\tint n = 0;\n\tint score;\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入最低评分：\");\n\tscore = get_int();\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (p->fraction >= score) //判断是否符合要求\n\t\t{\n\t\t\toutput(p); //调用函数输出节点信息\n\t\t\tn++;\t   //记录找到多少节点\n\t\t}\n\t}\n\tprintf(\"\\n共查找到%d道菜\\n\", n);\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid average_percentage(List *list) //查询某饭店或食堂的平均价格和评分\n{\n\tint n = 0;\n\tfloat sum1 = 0, sum2 = 0, b[5] = {0};\n\tchar a[SIZE1];\n\tNode *p;\n\tsystem(\"cls\");\n\tprintf(\"请输入你要查的饭店或食堂：\");\n\ts_gets(a, SIZE1);\n\tfor (p = list->head; p; p = p->next) //遍历链表\n\t{\n\t\tif (!strcmp(a, p->restaurant)) //判断是否找到\n\t\t{\n\t\t\tsum1 += p->price;\t //累加价格\n\t\t\tsum2 += p->fraction; //累加评分\n\t\t\tif (p->price <= 5)\n\t\t\t{\n\t\t\t\tb[0]++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (p->price <= 10)\n\t\t\t\t{\n\t\t\t\t\tb[1]++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (p->price <= 15)\n\t\t\t\t\t{\n\t\t\t\t\t\tb[2]++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (p->price < 20)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[3]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tb[4]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tn++; //记录找到多少节点\n\t\t}\n\t}\n\tcolor(11);\n\tif (n)\n\t{\n\t\tprintf(\"该饭店/食堂的一共有%d道菜\\n平均价格是：%.2f\\t平均评分是：%.2f\\n\", n, sum1 / n, sum2 / n);\n\t\tprintf(\"其中：\\n0~5元占:%.1f%%\\n5~10元占:%.1f%%\\n10~15元占:%.1f%%\\n\", b[0] / n * 100, b[1] / n * 100, b[2] / n * 100);\n\t\tprintf(\"15~20元占:%.1f%%\\n20元以上占:%.1f%%\\n\\n\", b[3] / n * 100, b[4] / n * 100);\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"无该饭店或食堂！\\n\\n\");\n\t}\n\tcolor(11);\n\tsystem(\"pause\");\n}\nvoid output(Node *p) //方便输出\n{\n\tprintf(\"\\n|菜名:%s\\n\", p->name);\n\tprintf(\"|所属:%s\\n\", p->restaurant);\n\tprintf(\"|价格:%.2f\\n\", p->price);\n\tprintf(\"|评分:%d\\n\", p->fraction);\n\tprintf(\"|评价:%s\\n\", p->comment);\n}\nvoid random_menu(List *list) //随机输出一道菜\n{\n\tsystem(\"cls\");\n\tif (list->head == NULL) //判断链表是否为空\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tList *q = list;\n\tNode *p = list->head;\n\tint n = random_number(q), i = 1; //将随机出来的数赋予n，并初始i等于第一道菜，判断数字是否相等，即可找到那个随机出来的菜\n\twhile (p != NULL)\n\t{\n\n\t\tif (i == n) //借助随机数来随机输出菜\n\t\t{\n\t\t\toutput(p);\n\t\t\tcolor(11);\n\t\t\tsystem(\"pause\");\n\t\t\treturn;\n\t\t}\n\t\ti++;\n\t\tp = p->next;\n\t}\n}\nvoid empty(List *list) //清空链表\n{\n\tNode *p, *q;\n\tint n;\n\tsystem(\"cls\");\n\tcolor(12);\n\tprintf(\"此操作将清空所有数据！\\n输入 1 继续，输入 0 取消：\\n\");\n\tdo\n\t{\n\t\tn = get_int();\n\t} while (!(n == 0 || n == 1));\n\tif (n == 1)\n\t{\n\t\tfor (p = list->head; p; p = q) //遍历链表\n\t\t{\n\t\t\tq = p->next;\n\t\t\tfree(p);\n\t\t}\n\t\tlist->head = NULL;\n\t\tprintf(\"清除完成！\\n\");\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n}\n//文件操作\nvoid save(List *list) //保存\n{\n\tif (list->head == NULL)\n\t{\n\t\tcolor(12);\n\t\tprintf(\"还未存入任何菜品！保存为空！\\n\");\n\t\tcolor(11);\n\t\tsystem(\"pause\");\n\t\treturn;\n\t}\n\tNode *p = list->head;\n\tFILE *fp = fopen(\"Menu.txt\", \"w\");\n\tif (fp)\n\t{\n\t\twhile (p)\n\t\t{\n\t\t\tfprintf(fp, \"\\n%s %s %0.2f %d %s\", p->name, p->restaurant, p->price, p->fraction, p->comment);\n\t\t\tp = p->next;\n\t\t}\n\t\tfclose(fp);\n\t\tcolor(11);\n\t\tprintf(\"\\n保存成功\\n\");\n\t\tsystem(\"pause\");\n\t}\n\telse\n\t{\n\t\tcolor(12);\n\t\tprintf(\"保存失败，请自查或联系作者\");\n\t}\n}\nvoid read_txt(List *list) //读取文件_初始链表\n{\n\tint i = 1;\n\tNode *last;\n\tNode *p1;\n\tint a = 1;\n\tchar f[5];\n\tFILE *fp = fopen(\"Menu.txt\", \"r\");\n\tfgets(f, 10, fp); //读取第一行，并进入下一行，防止bug\n\twhile (!feof(fp)) //当读取到文件结束符跳出循环结束读取\n\t{\n\t\tlast = list->head;\n\t\tp1 = (Node *)malloc(sizeof(Node));\n\t\tp1->next = NULL;\n\t\tfscanf(fp, \"%s%s%f%d%s\", p1->name, p1->restaurant, &p1->price, &p1->fraction, p1->comment);\n\t\tif (last)\n\t\t{\n\t\t\twhile (last->next)\n\t\t\t{\n\t\t\t\tlast = last->next;\n\t\t\t}\n\t\t\tlast->next = p1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlist->head = p1;\n\t\t}\n\t}\n\tfclose(fp);\n}\n//单链表的冒泡排序，这指来指去，作者一口气写完到断气的，不想加注释了，应该会有更好的算法，咕咕咕，以后优化\nvoid sort_ascending(List *list) //菜品按价格从低到高排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price > list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_descending(List *list) //菜品按价格从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->price < list_swap.pc->price)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid sort_score(List *list) //菜品按评分从高到低排序\n{\n\tint n = 0, i, k, num;\n\tList *p = list;\n\tNode *p1 = list->head, *p2, *p3;\n\tList list_swap;\n\tn = calculate(p);\n\tlist_swap.pa = p1;\n\tlist_swap.pb = p2;\n\tlist_swap.pc = p3;\n\tfor (i = 0; i < n - 1; i++)\n\t{\n\t\tlist_swap.pa = list->head;\t\t   //当前\n\t\tlist_swap.pb = NULL;\t\t\t   //前一个\n\t\tlist_swap.pc = list_swap.pa->next; //下一个\n\t\tfor (k = 0; k < n - i - 1; k++)\n\t\t{\n\t\t\tif (list_swap.pa->fraction < list_swap.pc->fraction)\n\t\t\t{\n\t\t\t\tswap1(p, &list_swap);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswap2(p, &list_swap);\n\t\t\t}\n\t\t}\n\t}\n}\nint calculate(List *list) //计算出单链表的节点个数\n{\n\tint n = 0;\n\tNode *p = list->head;\n\twhile (p->next != NULL)\n\t{\n\t\tn++;\n\t\tp = p->next;\n\t}\n\treturn n + 1;\n}\nvoid swap1(List *list, List *list_swap) //单链表冒泡排序的算法块1\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pb->next = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\telse\n\t{\n\t\tlist->head = list_swap->pa->next;\n\t\tlist_swap->pa->next = list_swap->pc->next;\n\t\tlist_swap->pc->next = list_swap->pa;\n\t}\n\tlist_swap->pb = list_swap->pc;\n\tlist_swap->pc = list_swap->pa->next;\n}\nvoid swap2(List *list, List *list_swap) //单链表冒泡排序的算法块2\n{\n\tif (list_swap->pb)\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list_swap->pb->next;\n\t}\n\telse\n\t{\n\t\tlist_swap->pa = list_swap->pa->next;\n\t\tlist_swap->pc = list_swap->pa->next;\n\t\tlist_swap->pb = list->head;\n\t}\n}\n//其他\nint random_number(List *list) //随机生成不大于节点数的整数\n{\n\tint n = 0, m = 0, sum = 1, i = 0;\n\tList *q = list;\n\tsrand((unsigned)time(NULL) * 12);\n\tm = calculate(q);\n\ti = m;\n\twhile (m > 0)\n\t{\n\t\tsum = sum * 10;\n\t\tm = m / 10;\n\t}\n\twhile (1)\n\t{\n\t\tn = rand() % sum;\n\t\tif (n <= i && n > 0)\n\t\t{\n\t\t\ti = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn i;\n}\nvoid color(int a) //控制台文本颜色\n{\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), a); //更改控制台文字颜色\n}\n\n```\n***\n\n# 部分功能截图\n**主菜单**\n<div><img src=/images/6-1.webp width=\"50%\" height=\"50%\"></div>\n\n**查找功能**\n<div><img src=/images/6-2.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=/images/6-5.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=/images/6-6.webp width=\"50%\" height=\"50%\"></div>\n<div><img src=/images/6-7.webp width=\"50%\" height=\"50%\"></div>\n\n**排序**\n<div><img src=/images/6-3.webp width=\"50%\" height=\"50%\"></div>\n\n**修改功能**\n<div><img src=/images/6-4.webp width=\"45%\" height=\"45%\"></div>\n\n***\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["C语言"],"categories":["项目"]},{"title":"C语言学习笔记","url":"/article/13675369.html","content":"\n# 整数运算\n两个整数运算结果也只能是整数  \na+=5等价于a=a+5  \na*=b+5等价于a=a*(b+5)  \na++等a+=1等a=a+1  \na++是a加1以前的值，++a是a加1后的值  \n运算符优先级：算数>关系>赋值，判断是否相等的优先级比大于小于低\n***\n# 所表达的数的范围\nchar< short<int< float<double\n***\n# sizeof()\nsizeof()是一个运算符,给出某个类型或变量在内存中所占据的字节数  \nsizeof()是静态运算符,它的结果在编译时刻就决定了，不要在 sizeof的括号里做运算,这些运算不会做的\n***\n# unsigned\nunsigned：如果一个字面量常数想要表达自己是 unsigned,可以在后面加u或U，255U用l或L表示long(long)  \nunsigned的初衷并非扩展数能表达的范围,而是为了做纯二进制运算,主要是为了移位\n***\n# 整数的输入输出\n只有两种形式:int或 long long  \n%d: int  \n%u: unsigned  \n%ld: longlong  \n%lu: unsigned long long\n***\n# 选搔整数类型\n为什么整数要有那么多种?为了准确表达内存,做底层程序的需要  \n没有特殊需要,就选int  \n现在的CPU的字长普遍是32位或64位,一次内存该写就是个int,一次计算也是一个int,选择更短的类型不会更快,甚至可能更慢  \n现代的编译器一般会设计内存对齐,所以更短的类型实际在内存中有可能也占据一个int的大小(虽然sizeof告诉你更小)\n***\nunsigned与否只是输出的不同,内部计算是一样的  \nprintf输出inf表示超过范围的浮点数:±∞  \nprint输出nan表示不存在的浮点数  \n带小数点的字面量是 double而非 float  \nfloat需要用或F后綴来表明身份  \n1.234f\n***\n判断两个浮点数是否相等可能失败  \nfabs(fl-2)< le-2//两个浮点数相减的绝对值小于一个很小的数，可认为两个浮点数相等\n***\n# 选浮点类型\n如果没有特殊需要,只使用 double  \n现代CPU能直接对 double做硬件运算,性能不会比float差,在64位的机器上,数据存儲的速度也不比float慢\n***\n# 自动类型转换\n当运算符的两边出现不一致的类型时,会自动转换成較大的类型  \n大的意思是能表达的数的范围更大  \nchar——> short——>int——>long——>long long  \nint——> float——> double  \n对于 printf,任何小于int的类型会被转换成int，float会被转换成 double  \n但是scanf不会,要输入short,需要%hd\n***\n# 强制类型转换\n要把一个量强制转换成另一个类型(通常是較小的类型),需要:(类型)值  \n比如：  \n(int)10.2  \n(short)32  \n注意这时候的安全性,小的变量不总能表达大的量  \n(short)32768  \n只是从那个变量计算出了一个新的类型的值,它并不改变那个变量,无论是值还是类型都不改变  \n强制类型转换的优先级高于四则运算\n***\n# 逻辑运算符优先级:\n!>&&>||\n***\n# 短路\n逻辑运算是自左向右进行的,如果左边的结果已经能够决定结果了,就不会做右边的计算  \na==6&&b==1  \na==6&&b+=1  \n对于&&,左边是 false时就不做右边了  \n对于‖,左边是true时就不做右边了  \n***\n# tip1\n不要把赋值,包括复合赋值组合进表达式!  \n一个代码内有重复相似段是程序质量不良的表现  \n函数是一块代,接收零个或多个参数做一件事情,并返回零个或一个值\n***\n# 数组的大小\nsizeof给出整个数组所占据的内容的大小,单位是字节  \nsizeof(a)/sizeof(a[0])  \nsizeof(a[0])给出数组中单个元素的大小,于是相除就得到了数组的单元个数  \n这样的代码,一旦修改数组中初始的数据,不需要修改遍历的代吗\n***\n# 数组的操作\n遍历数组：通常都是使用for循环,让循环变量i从0到<数组的长度,这样循环体内最大的正好是数组最大的有效下标  \n数组作为函数的参数时:不能在[]中给出数组的大小，不能再利用 sizeof来计算数组的元素个数!  \n数组作为函数参数时,往往必再用另一个参数来传入数组的大小\n# 作为参数的指针\nvoid f(int * p)  \n在被调用的时候得到了某个变量的地址  \nint i=O; f(&i)  \n在函数里面可以通过这个指针访问外面的这个  \n函数参数表中的数组实际上是指针  \nsizeof(a)==sizeof(int *)  \n但是可以用数组的运算符进行运算\n***\n# 指针是const\n表示一旦得到了某个变量的地址,不能再指向其他变量  \nint *const q=&i;//q是 const  \n*q=26;//OK  \nq++; //ERROR\n***\n# 所指是 const\n表示不能通过这个指针去修改那个变量(并不能使得那个变量成为 const)  \nconst int *p=&i  \n*p= 26; //ERROR!  \ni=26;//OK  \nP=&i;//OK\n***\n# const\nlnt i  \nconst int* p1 =&i  \nint const* p2=&i  \nint *const p3=&i  \n判断哪个被const了的标志是const在*的前面还是后面  \n*const p指针不许动  \nconst *p指针不许动变量\n***\n## 转换\n总是可以把一个非 const的值转換成 const的  \nvoid f(const int* x)  \nint a =15:  \nf(&a);//ok  \nconst int b = a  \nf(&b);//ok  \nb =a+1: // Error  \n当要传递的参数的类型比地址大的时候,这是常用的手段:既能用比較少的字节数传递值给参数,又能避免函数对外面的变量的修改\n***\n## const数组\nconst int a[]={1,2,3,4,5,6};  \n数组变量已经是 const的指针了,这里的 const表明数组的每个单元都是 const Int所以必须通过初始化进行赋值\n***\n## 保护数组值\n因为把数组传入函数时传递的是地址,所以那个函数内部可以修改数组的值  \n为了保护数组不被函数破坏,可以设置参数为 const  \nint sum(const int a[], int length);\n***\n# 指针\nint *p ：指针加一p+1是指加上一个sizeof(int)，将指针移到下一个单元  \nint *p=a[];  \n*p -->a[0]  \n*(p+1)-->a[1]  \n*(p++)可以遍历数组\n***\n给一个指针加|表示要让指针指向下一个变量  \nint a[l0]  \nint *p= a  \n*(p+1)-->a[1]  \n如果指针不是指向一片连分配的空间,如数组,则这种运算没有意义  \n*(p+n)<-->a[n]  \n*p*q两个指针相减p-q，等于q加多少个单元等于p\n***\n*p++  \n取出p所指的那个数据来,完事之后顺便把移到下一个位置去  \n*的优先级然高,但是没有++高  \n常用于数组类的连续空间操作  \n在某些CPU上,这可以直接被翻译成一条汇编指令\n\n指针乘除无意义\n***\n## 指针遍历数组方法 \n```\n*p a[10]\np=a\nfor(i=0;i<sizeof(a)/sizeof(a[0]); i++ ){\nprintf(\"%d\\n\", acri[i]);\n}  \na[9]=-1//在数组末尾放入一个特殊的东西\nwhile(*p!=-1){\nprintf(\"%d\\n\",*p++);\n}\n```\n***\n## 指针比較\n<,<=,==,>,>=,!=都可以对指针做  \n比较它们在内存中的地址  \n数组中的单元的地址肯定是线性从小到大递增的\n***\n## 0地址\n当然你的内存中有0地址,但是0地址通常是个不能随便碰的地址  \n所以你的指针不应该具有0值  \n\n因此可以用0地址来表示特殊的事情:  \n1返回的指针是无效的  \n2指针没有被真正初始化(先初始化为0)  \n\nNULL（必须是大写）是一个预定定义的符号,表示0地址  \n有的编译器不愿意你用0来表示0地址\n***\n## 指针的类型\n无论指向什么类型,所有的指针的大小都是一样的,因为都是地址  \n但是指向不同类型的指针是不能直接互相赋值的  \n这是为了避免用错指针\n## 指针的类型转换\nvoid*表示不知道指向什么东西的指针  \n计算时与char*相同(但不相通)\n\n指针也可以转换类型  \nint*p =&i  \nvoid*p<-->(void *)p  \n这并没有改变p所指的变量的类型,而是让后人用不同的眼光通过p看它所指的变量  \n我不再当你是int,我认为你就是个void!\n***\n## 用指针来做什么\n需要传入較大的数据时用作参数  \n传入数组后对数组做操作  \n函数返回不止一个结果是  \n需要用函数来修改不止一个变量  \n动态申请的内存\n***\n# 内存操作\n## malloc(跟系统要一块内存)\n```\n#include <stdlib. h>\nvoid*malloc(size_t size)\n//向malloc申请的空间的大小是以字节为单位返回的结果是void,需要类型转换为自己需要的类型\n(int *)malloc(n*sizeof(int))\n```\n如果申请失敗则返回0,或者叫做NULL\n***\n## free()\n把申请得来的空间还给“系统”  \n申请过的空间,最终都应该要还  \n只能还申请来的空间的首地址\n## free常见问题\n申请了没free—>长时间运行内存逐漸下降  \n新手:忘了  \n老手:找不到合的free的时机  \nfree过了再free  \n地址变过了,直接去free\n***\n# 字符串\nchar a[]={'h','a','l','l','o','!'}//字符数组  \nchar a[]={'h','a','l','l','o','!','\\0'}//字符串\n***\n以0(整数0)结尾的一串字符  \n0或'\\0'是一样的,但是和0不同  \n0标志字符串的结束,但它不是字符串的一部分  \n计算字符串长度的时候不包含这个0  \n字符串以数组的形式存在,以数组或指针的形式访问  \n更多的是以指针的形式  \nstring.h里有很多处理字符串的函数\n***\n```\nchar*str=\"Hello\"\nchar word[]=\"Hello\"\nchar linel[10]=\"Hello\"\n```\n***\n## 字符串常量\nChar* s=\"Hello, world\"  \n●s是一个指针,初始化为指向一个字符串常量 \n●由于这个常量所在的地方,所以实际上s是 const  \nchar*s,但是由于历史的原因,编译器接受不带const的写法  \n●但是试图对s所指的字符串做写入会导致严重的后果\n***\nchar S[]=\"Hello, world\"//这个字符串就在我这里  \nChar* s=\"Hello, world\"//指向某个地方的字符串  \n数组:这个字符串在这里(作为本地变量,空间自动被回收)  \n指针:这个字符串不知道在哪里(处理参数,动态分配空间)  \n如果要构造一个字符串一>数组  \n如果要处理一个字符串一>指针\n***\n## 字符串输入输出\n```\nchar string[8];\nscanf(\"%s\", string);\nprintf(\"%s\", string);\n//scanf读入一个単词(到空格、tab或回车为止)\n//scanf是不安全的,因为不知道要该入的内容的长度\nscanf(\"%7s\", string)\n//在%和s之间的数字表示最多允许该入的字符的数量,这个数字应该比数组的大小小\n```\n***\n## 空字符串\n```\nchar buffer[100]=\"\";\n//这是一个空的字符串, buffer[O]==\"\\0\";\nchar buffer[]=\"\";\n//这个数组的长度只有1\n```\n***\n## 复制一个字符串\n```\nchar*dst=(char*)malloc(strlen(src)+1)\nstrcpy(dst, src)\n```\n***\n# 枚挙\n枚挙是一种用戶定义的数据类型,它用关键字enum以如下语法来声明  \nenum枚挙类型名字{名字0,……,名字n};  \n\n枚挙类型名字通常并不真的使用,要用的是在大括号里的名字,因为它们就是就是常量符号,它们的类型是int,值则依次从0到n。如：  \nenum colors {red, yellow, green};  \n就创建了三个常量,red的值是0, yellow是1,而 green是2。  \n当需要一些可以排列起来的常量值时,定义枚举的意义就是给了这些常量值名字。\n>声明枚挙量的时候可以指定值\n>enum COLOR {RED=1, YELLOW, GREEN =5};\n\n***\n\n# 结构\n## 声明结构的形式\n```\nstruct point{\nint X;\nInt y;\n};\nstruct point p1, p2\n//pl和p2都是 point里面有x和y的值\n\nstruct {\nInt x;\nint y;\n}pl, p2;\n//pl和p2都是一种无名结构,里面有x和y\n\nstruct point {\nInt x;\nint y;\n}pl, p2;\n//pI和p2都是point, 里面有x和y的值t\n```\n>和本地变量一样,在函数内部声明的结构类型只能在函数内部使用  \n>所以通常在函数外部声明结构类型,这样就可以被多个函数所使用了\n\n***\n## 结构指针\n和数组不同,结构变量的名字并不是结构变量的地址,必须使用&运算符\n```\nstruct date*pdate= &today;\n```\n***\n## 结构作为函数参数\n```\nint numberofdays(struct date d)\n```\n整个结构可以作为参数的值传入函数  \n这时候是在函数内新建一个结构变量,并复制调用者的结构的值  \n也可以返回一个结构  \n这与数组完全不同\n***\n## 指向结构的指针\n```\nstruct date {\nint month;\nint day;\nint yeari;\n}myday;\nstruct date *p =&myday;\n(*p).month 12;\np->zmonth 12;\n//用->表示指针所指的结构变量中的成员\n```\n***\n# 全局变量初始化\n没有做初始化的全局变量会得到0值  \n指针会得到NULL值  \n只能用编译时刻已知的值来初始化全局变量  \n它们的初始化发生在main函数之前  \n全局变量不应该和另一个全局变量有联系  \n同名变量，本地变量优先级高于全局变量，即本地变量隐藏了全局变量\n***\n# 静态本地变量（全局生存期，本地作用域）\n在本地变量定义时加上 static修饰符就成为静态本地变量  \n当函数离开的时候,静态本地变量会銖存在并保持其值  \n静态本地变量的初始化只会在第一次进入这个函数时做（只做一次初始化）,以后进入函数时会保持上次离开时的值  \n静态本地变量实际上是特殊的全局变量，它们位于相同的内存区域  \n静态本地变量具有全局的生存期,函数内的局部作用域  \nstatic在这里的意思是局部作用域(本地可访问)\n>不要使用全局变量来在函数间传递参数和结果  \n>尽量避免使用全局变量  \n>丰田汽车的案子  \n>使用全局变量和静态本地变量的函数是线程不安全的  \n\n***\n# 返回指针的函数\n返回本地变量的地址是危险的  \n返回全局变量或静态本地变量的地址是安全的  \n返回在函数内 malloc的内存是安全的,但是容易造成问题  \n最好的做法是返回传入的指针\n***\n# 编译预处理指令\n#开头的是编译预处理指令  \n它们不是C语言的成分,但是C语言程序离不开它们\n***\n## #define(纯文本替换)\n#define用来定义一个宏  \n#define<名字><值>  \n注意没有结尾的分号,因为不是C的语句  \n名字必颁是一个单词,值可以是各种东西  \n在C语言的编译器开始编译之前,编译预处理程序  \n(cpp)会把程序中的名字换成值  \n完全的文本替换  \nacc-save-temps\n***\n## 宏\n如果一个宏的值中有其他的宏的名字,也是会被替换的  \n如果一个宏的值超过一行,最后一行之前的行末需要加  \\   \n宏的值后面出现的注释不会被当作宏的值的一部分\n***\n### 预定义的宏\n```\n_LINE_\n_FILE_\n_DATE_\n_TIME_\n_STDC_\n```\n### 带参数的宏\n```\n#define cube(x) ((x)*(x)*(x))\n```\n在大型程序的代吗中使用非常普遍  \n可以非常复杂,如“产生”函数:在#和##这两个运算符的帮助下  \n存在中西方文化差异  \n部分宏会被inline函数替代\n***\n# 变量的声明\nint i;是变量的定义  \nextern int i;是变量的声明\n***\n# 声明和定义\n声明是不产生代码的东西  \n函数原型  \n变量声明  \n结构声明  \n宏声明  \n枚挙声明  \n类型声明  \ninline函数  \n定义是产生代码的东西  \n头文件放声明是规则\n***\n# 重复声明\n同一个编译单元里,同名的结构不能被重复声明  \n如果你的头文件里有结构的声明,很难这个头文件不会在一个编译单元里被#include多次，所以需要\"标准头文件结构\"\n***\n# 标准头文件结构(宏的if)\n```\n#ifndef _LIST_HEAD_\n#define _LIST_HEAD_\n#include \"node.h\"\ntypedef struct _list{\n    Node* head\n    Node* tail\n}List\n#endif\n//运用条件编译和宏,保证这个头文件在一个编译单元中只会被#include一次\n#pragma once//也能起到相同的作用,但是不是所有的编译器都支持\n```\n\n# 链表\n>0建一个node结构  \n>1首选有个node结构(作为节点)，结构里有int(或者其他类型)变量去存数据，还有个同样结构的*next(next要等于下一个节点)（套娃）  \n>2读入数据，并新建一个node结构p，要让一个node结构head始终等于链表第一个节点  \n>3要有一个node结构last，每次要让last从head开始，直到last->next是空的，然后让next等于新的p结构（这样就链起来了）  \n>4每次读入新的数据，就新建一个p，然后让last从head开始遍历链表，直到last->next是空的，然后然后让next等于新的p结构  \n\n**要在函数内改变指针的指向，就要传指针的指针进去**\n***\n## 遍历链表\n```\nfor(p=list.head; p; p=p->next){}\n//单用一个指针p可以遍历链表\n```\n\n但要让删除链表中某一结点，需要另一个指针q，q一开始为null，后来始终指向p前一个节点  \n当p找到了要删除的节点，就让q->next等于p->next，然后free(p)  \nfor(q=null，p=list.head; p; q=p，p=p->next){}  \n当然还要判断链表的第一个元素是不是我们要删除的  \n如果是，就不能让q->next等于p->next，因为q一开始是NULL  \n我们应该让head->next等于p->next，然后free(p)  \n>\".\"一般情况下读作\"的”。  \n>\"->\"一般读作\"指向的结构体的\"。  \n\n***\n## 清除整个链表\n```\nfor(p=head;p;p=q){\n     q=p->next;\n     free(p)\n}\n//先让指针p等于head，让q始终指向p的下一个节点，然后free(p),再让p=q，p去等于下一个节点\n```\n\n***\n# main()\nmain(成为C语言的入口函数其实和C语言本身无关,你的代码是被一小段叫做启动代的程序所调用的,它需要叫做main的地方)  \n操作系统把你的可执行程序装载到内存里,启动运行,然后调用你的main函数  \n在不同操作系统，入口函数可能不是main()\n***","tags":["C语言"],"categories":["学习笔记"]},{"title":"博客搜索挂了解决方法","url":"/article/f8c79a1b.html","content":">省流助手：删除所有local-search.js中下面这行代码\n>window.pjax && window.pjax.refresh($resultContent)\n\n# 遇到的问题\n我使用的是本地搜索，local-search，装好后一直正常使用，也没去动过配置\n前天捣鼓着博客，突然发现博客部署到github上后搜索挂了\n<img src=/images/4-2.webp width=\"60%\" height=\"60%\">\n一直卡在数据库加载中\n\n但是，部署在本地，搜索却一切正常\n<img src=/images/4-3.webp width=\"60%\" height=\"60%\">\n尝试过重装插件，清除浏览器缓存，search.xml改为json，但过一会又挂了\n\n看网上也有不少人遇到这种问题，却找不到解决办法\n\n***\n\n# 解决过程\nlocal-search会请求生成在本地的search.xml，也就是数据库加载中里的“数据库”\n\n部署在本地时正常请求\n<img src=/images/4-8.webp width=\"80%\" height=\"80%\">\n而部署在github时没有请求\n<img src=/images/4-9.webp width=\"65%\" height=\"65%\">\n直接访问search.xml正常，不是search.xml的问题\n<img src=/images/4-5.webp width=\"60%\" height=\"60%\">\n查看报错，看起来是这个js的问题\n<img src=/images/4-6.webp width=\"60%\" height=\"60%\">\n本地找到local-search.js，这三个代码都一样\n<img src=/images/4-7.webp width=\"60%\" height=\"60%\">\njs中只有一处pjax报错\n<img src=/images/4-10.webp width=\"60%\" height=\"60%\">\n类型“Window & typeof globalThis”上不存在属性“pjax”。ts(2339)  \n\n\n看不懂这种报错，但问题多半就是这行代码导致的，查看整个js后，尝试删除此行\n```\nwindow.pjax && window.pjax.refresh($resultContent)\n```\n删除后，搜索挂了的问题解决，博客正常请求search.xml\n<img src=/images/4-8.webp width=\"70%\" height=\"70%\">\n\n但点击搜索结果后pjax失效，具体表现是aplayer停止播放音乐\n\n看来是pjax的bug，不过感知不强，其余地方的pjax仍然生效\n\n暂时先这样，以后找到更好的解决办法再更新\n\n***","tags":["Butterfly","Hexo"],"categories":["Hexo"]},{"title":"Hexo博客的基本操作","url":"/article/aa2a7b7e.html","content":"\n> **Hexo官方文档:**[Hexo](https://hexo.io/zh-cn/docs)\n\n# Hexo操作\n\n## 指令\n\n```js 新建文章，在blog\\source\\_posts\nhexo new post (文章名称)\n```\n```js 新建页面，在blog\\source\nhexo new page (页面名称)\n```\n```js 清除缓存文件 (db.json) 和已生成的静态文件 (public)\nhexo clean\n```\n```js 生成静态文件\nhexo g\n```\n```js 启动服务器，访问网址:http://localhost:4000\nhexo s\n```\n```js 部署网站\nhexo d\n```\n```js hexo三连,四连\nhexo cl && hexo g && hexo s\nhexo cl && hexo g && gulp && hexo d\n```\n```js push三连\ngit add .\ngit commit -m \"github action update\"\ngit push origin master\n```\n<br>\n\n## 文章操作\n\n>**Markdown 教程**\n>[菜鸟教程](https://www.runoob.com/markdown/md-tutorial.html)\n>[官网--Markdown基本语法](http://markdown.p2hp.com/basic-syntax/)\n\n\n> **blog\\scaffolds中修改三种文章模板**\n\n>*斜体文本* &emsp;\\*斜体文本\\* \n>**粗体文本** &emsp;\\*\\*粗体文本\\*\\*\n>***粗斜体文本*** &emsp;\\*\\*\\*粗斜体文本\\*\\*\\* \n>~~横线删除~~ &emsp;\\~\\~横线删除\\~\\~ \n\n>***水平分割线\n\n```html 文字蓝链 \n文字内容[tittle](https://*******)\n```\n```html 文章中自定义文本，size文字大小，face字体，color颜色，&emsp空格\n<font size=\"2\" face=\"verdana\" color=\"blue\" >&emsp;这是一个文本</font>\n\n```\n```html 插入自定义图片,\n\n<div align=left><img src=1.png width=\"25%\" height=\"25%\"></div>\n\n<div align=left><img src=1.png><img src=2.png></div>\n\n![文本](图片地址 \"鼠标悬停弹出文本提示\")\n```\n***\n","tags":["Hexo"],"categories":["Hexo"]},{"title":"测试用文章","url":"/article/d87f7e0c.html","content":"\n111111111232232\n12312321wqeqeqsdasafafawfcnasjcnjs\ntestawdfawfaafawaaaaaaaaaaaaaaaaaaa\nrgsesgesgesgsedsadadasda\n罗素·贝克曾经说过，一个人即使已登上顶峰，也仍要自强不息。我希望诸位也能好好地体会这句话。 那么， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 hexo的发生，到底需要如何做到，不hexo的发生，又会如何产生。 歌德在不经意间这样说过，没有人事先了解自己到底有多大的力量，直到他试过以后才知道。这句话语虽然很短，但令我浮想联翩。 hexo，到底应该如何实现。 了解清楚hexo到底是一种怎么样的存在，是解决一切问题的关键。 生活中，若hexo出现了，我们就不得不考虑它出现了的事实。 我们一般认为，抓住了问题的关键，其他一切则会迎刃而解。 总结的来说， 带着这些问题，我们来审视一下hexo。 经过上述讨论现在，解决hexo的问题，是非常非常重要的。 所以， 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 我们不得不面对一个非常尴尬的事实，那就是， hexo因何而发生?这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 生活中，若hexo出现了，我们就不得不考虑它出现了的事实。 德谟克利特曾经说过，节制使快乐增加并使享受加强。我希望诸位也能好好地体会这句话。 hexo的发生，到底需要如何做到，不hexo的发生，又会如何产生。 带着这些问题，我们来审视一下hexo。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。 一般来说， hexo，发生了会如何，不发生又会如何。 现在，解决hexo的问题，是非常非常重要的。 所以， 要想清楚，hexo，到底是一种怎么样的存在。 hexo，到底应该如何实现。 本人也是经过了深思熟虑，在每个日日夜夜思考这个问题。\n<img src=\"https://cdn.nlark.com/yuque/0/2022/png/26795473/1659838729962-11aa244b-c946-45ac-bedb-c2278df4a1ce.png\" width=\"50%\" height=\"50%\">"},{"title":"第一篇文章：一点小小的说明与介绍","url":"/article/ff73d561.html","content":"\n# 本博的说明\n\n1.目前记录自己学习编程之路\n\n2.酷安机佬分享搞机\n\n3.记录日常\n\n4.欢迎交换友链\n\n5.更多\n\n***\n\n# 写博原因\n>不写博客不知道自己多牛B，写了博客就知道自己多lowB\n>~~博客不是你想写，想写就能写，这玩意儿需要大量知识，沉淀，研究，总结~~\n>博客就是自己想什么就写什么的哈，比如有个瞬间想法也可以写进去，记录下来！何必在意那么多！\n>~~把工作中需要用的技术和实现代码写到博客里，下次再用上就直接复制粘贴~~\n>>来自评论区[bilibili评论区](https://www.bilibili.com/video/BV1334y1q72q) \n\n写博明确的好处————CodeSheep\n1.培养总结能力\n2.面试加分项\n3.让自己的知识在某个地方留下痕迹，不流失\n4.加深对技术点的理解(写的过程=复现)\n5.帮助自己创建一个属于自己的知识体系\n6.踩坑记录\n7.获得阅读量，提高知名度，结交志同道合的朋友\n8.提高表达与写作能力\n9.·····\n\n**总之写博是提升自己方便自己的好途径**\n作为一只计科大一<font size=2>~~带学牲~~</font>，未来的程序员，写博是必要的\n\n***\n\n# CodeSheep的tip\n>写博客可以系统地整合自己某一阶段的学习成果\n\n>博客的方向：\n>可复现，能否解决实际问题\n\n>注意：\n>尊重知识产权，用别人的代码或者语言，记得表明来源。\n\n>入门：\n>备忘录，基础理解，踩坑的记录分享、学习笔记\n>实战类：\n>环境搭建，操作记录\n\n***\n\n# 为什么用hexo搭博客\n\n1.静态博客够用了\n\n2.hexo用的人多，遇到问题百度好解决\n\n3.主题丰富\n\n4.无需服务器 ~~部署到github/gitee无需软妹币~~\n\n>100天后我还是把博客主线路部署在腾讯云了，用上腾讯云与又拍云的cdn速度就是快\n","tags":["Chuckle"],"categories":["Chuckle"]}]